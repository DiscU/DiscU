<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="Microsoft.CSharp" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<# 
GenerateClasses(); 
#>
<#+
void GenerateClasses()
{
	WriteLine("// ===========================================================================");
	WriteLine("// Generated by {0}", System.IO.Path.GetFileName(Host.TemplateFile));
	WriteLine("// ===========================================================================");
	WriteLine("");
	WriteLine("using System;");
	WriteLine("using Newtonsoft.Json;");
	WriteLine("");
	WriteLine("namespace OneOf");
	using(new WriteIndent(this))
	{
		for (var i = 2; i < 10; i++)
			WriteOneOf(true, i);

		for (var i = 2; i < 10; i++)
			WriteOneOf(false, i);

		for (var i = 1; i < 10; i++)
			WriteSwitcher(i);

		for (var i = 1; i < 10; i++)
			WriteMatcher(i);
	}
}
string GenerateGenericArgs(IEnumerable<int> ints, string typePrefix = "T", string withResult = null)
{
    return string.Join(", ", ints.Select(e => typePrefix + e)) + (withResult != null ? ", " + withResult : "");
}
void WriteOneOf(bool isStruct, int countOfgenericParams) 
{
	var genericArg = GenerateGenericArgs(Enumerable.Range(0, countOfgenericParams));
	var structOrClass = isStruct ? "struct" : "class";
	var typeName = isStruct ? "OneOf" : "OneOfBase";

    WriteLine("[JsonConverter(typeof(OneOfJsonConverter))]");
	WriteLine($"public {structOrClass} {typeName}<{genericArg}> : IOneOf");
	using(new WriteIndent(this))
	{
		WriteLine("readonly object value;");

		// =============== Constructors
		// must only be called after value has been validated to be Tn
	    
		WriteLine("");
		WriteLine($"{typeName}(object value)");
		using(new WriteIndent(this))
		{
			WriteLine($"this.value = value;");
		}

		if (!isStruct)
		{
			WriteLine("");
			WriteLine($"protected {typeName}()");
			using(new WriteIndent(this))
			{
				WriteLine("this.value = this;");
			}
		}

		// =============== Create
	    
		WriteLine("");
		WriteLine($"internal static {typeName}<{genericArg}> Create(object value)");
		using(new WriteIndent(this))
		{
			for(var parmIndex = 0; parmIndex < countOfgenericParams; parmIndex ++)
			{
				WriteLine($"if (value is T{parmIndex}) return new {typeName}<{genericArg}>((T{parmIndex})value);");
			}

			WriteLine($"throw (value == null) ? new ArgumentNullException(\"value\") : new ArgumentException(\"value\");");
		}

		// =============== IOneOf implementation

		WriteLine("");
		WriteLine("object IOneOf.Value => value;");

		// =============== Is

		WriteLine("");
		WriteLine($"public bool Is<T>() => (this.value is T);");

		// =============== As

		WriteLine("");
		WriteLine($"public T As<T>()");
		using(new WriteIndent(this))
		{
			WriteLine($"if (this.value is T) return (T)this.value;");
			WriteLine("");
			WriteLine("throw new InvalidOperationException();");
		}

		// =============== ToOneOf
		// Use slower Create method which does type checks at runtime as compiler couldn't check them for us.

		WriteLine("");
		for(var newIndex = 2; newIndex < 10; newIndex ++)
		{
			var otherGenericArgs = string.Join(", ", Enumerable.Range(0, newIndex).Select(e => "N" + e));

			WriteLine($"public {typeName}<{otherGenericArgs}> ToOneOf<{otherGenericArgs}>() => {typeName}<{otherGenericArgs}>.Create(value);");
		}

		// =============== implicit conversion to T
		// Use fast Ctor as compiler can check types for us.

		WriteLine("");
		for(var parmIndex = 0; parmIndex < countOfgenericParams; parmIndex ++)
		{
			WriteLine($"public static implicit operator {typeName}<{genericArg}>(T{parmIndex} value) => new {typeName}<{genericArg}>(value);"); 
		}

		// =============== Switch

		WriteLine("");
		for(var parmIndex = 0; parmIndex < countOfgenericParams; parmIndex ++)
		{
			var lesserArityOneOf = Enumerable.Range(0, countOfgenericParams).Where(n => n != parmIndex).ToList();
			var lesserArityGenericArg = GenerateGenericArgs(lesserArityOneOf);

			WriteLine($"public OneOfSwitcher<{lesserArityGenericArg}> Switch(Action<T{parmIndex}> action) => new OneOfSwitcher<{genericArg}>(value, false).Switch(action);");
		}

		// =============== Match

		WriteLine("");
		for(var parmIndex = 0; parmIndex < countOfgenericParams; parmIndex ++)
		{
			var lesserArityOneOf = Enumerable.Range(0, countOfgenericParams).Where(n => n != parmIndex).ToList();
			var lesserArityGenericArg = GenerateGenericArgs(lesserArityOneOf);

			WriteLine($"public OneOfMatcher<{lesserArityGenericArg}, TResult> Match<TResult>(Func<T{parmIndex}, TResult> func)  => new OneOfMatcher<{genericArg}, TResult>(value, null).Match(func);");
		}

		// =============== object overrides

		WriteLine("");
		WriteLine($"public override bool Equals(object obj) => obj is {typeName}<{genericArg}> && Equals(value, (({typeName}<{genericArg}>)obj).value);");
		WriteLine("public override int GetHashCode() => (value?.GetHashCode() ?? 0);");
		WriteLine("public override string ToString() => (value?.ToString() ?? \"\");");
	}
}

void WriteSwitcher(int countOfgenericParams) 
{
	var genericArg = GenerateGenericArgs(Enumerable.Range(0, countOfgenericParams));

	WriteLine("");
	WriteLine($"public struct OneOfSwitcher<{genericArg}>");
	using(new WriteIndent(this))
	{
		WriteLine("readonly object value;");
		WriteLine("bool hasSwitched;");

		// =============== Constructors
	    
		WriteLine("");
		WriteLine("internal OneOfSwitcher(object value, bool hasSwitched)");
		using(new WriteIndent(this))
		{
			WriteLine($"this.value = value;");
			WriteLine($"this.hasSwitched = hasSwitched;");
		}

		// =============== Switch

		for(var parmIndex = 0; parmIndex < countOfgenericParams; parmIndex++)
		{
			var lesserArityOneOf = Enumerable.Range(0, countOfgenericParams).ToList();
			if(lesserArityOneOf.Count > 1)
			{
				lesserArityOneOf.Remove(parmIndex);
				var lesserArityGenericArg = GenerateGenericArgs(lesserArityOneOf);

				WriteLine("");
				WriteLine($"public OneOfSwitcher<{lesserArityGenericArg}> Switch(Action<T{parmIndex}> action)");
				using(new WriteIndent(this))
				{
					WriteLine($"if (this.value is T{parmIndex})");
					using(new WriteIndent(this))
					{
						WriteLine($"action.Invoke((T{parmIndex})value);");
						WriteLine("hasSwitched = true;");
					}
					WriteLine($"return new OneOfSwitcher<{lesserArityGenericArg}>(this.value, this.hasSwitched);");
				}
			}
			else
			{
				WriteLine("");
				WriteLine($"public void Switch(Action<T{parmIndex}> action)");
				using(new WriteIndent(this))
				{
					WriteLine($"if (this.value is T{parmIndex}) action.Invoke((T{parmIndex})value);");
				}
			}
		}

		// =============== Otherwise

		WriteLine("");
		WriteLine($"public void Otherwise(Action<object> action)");
		using(new WriteIndent(this))
		{
			WriteLine($"if (!hasSwitched) action.Invoke(value);");
		}

		// =============== OtherwiseThrow

		WriteLine("");
		WriteLine($"public void OtherwiseThrow(Func<object, Exception> func)");
		using(new WriteIndent(this))
		{
			WriteLine($"if (!hasSwitched) throw func.Invoke(value);");
		}
	}
}

void WriteMatcher(int countOfgenericParams) 
{
	var genericArg = GenerateGenericArgs(Enumerable.Range(0, countOfgenericParams), withResult: "TResult");

	WriteLine("");
	WriteLine($"public struct OneOfMatcher<{genericArg}>" );
	using(new WriteIndent(this))
	{
		WriteLine("readonly object value;");
		WriteLine("object result;");

		// =============== Constructors
	    
		WriteLine("");
		WriteLine("internal OneOfMatcher(object value, object result)");
		using(new WriteIndent(this))
		{
			WriteLine($"this.value = value;");
			WriteLine($"this.result = result;");
		}

		// =============== Match

		for(var parmIndex = 0; parmIndex < countOfgenericParams; parmIndex++)
		{
			var lesserArityOneOf = Enumerable.Range(0, countOfgenericParams).ToList();
			if(lesserArityOneOf.Count > 1)
			{
				lesserArityOneOf.Remove(parmIndex);
			
				var lesserArityGenericArg = GenerateGenericArgs(lesserArityOneOf,withResult: "TResult");
				WriteLine("");
				WriteLine($"public OneOfMatcher<{lesserArityGenericArg}> Match(Func<T{parmIndex}, TResult> func)");
				using(new WriteIndent(this))
				{
					WriteLine($"if (value is T{parmIndex}) result = func.Invoke((T{parmIndex})value);");
					WriteLine($"return new OneOfMatcher<{lesserArityGenericArg}>(this.value, this.result);");
				}
			}
			else
            {
				WriteLine($"public TResult Match(Func<T{parmIndex}, TResult> func)");
				using(new WriteIndent(this))
				{
					WriteLine($"if (value is T{parmIndex}) result = func.Invoke((T{parmIndex})value);");
					WriteLine($"return (TResult)result;");
				}
            }
		}

		// =============== Otherwise

		WriteLine("");
		WriteLine($"public TResult Otherwise(Func<object, TResult> func)");
		using(new WriteIndent(this))
		{
			WriteLine($"if (result == null) result = func.Invoke(value);");
			WriteLine("return (TResult)result;");
		}

		// =============== OtherwiseThrow

		WriteLine("");
		WriteLine($"public TResult OtherwiseThrow(Func<object, Exception> func)");
		using(new WriteIndent(this))
		{
			WriteLine($"if (result == null) throw func.Invoke(value);");
			WriteLine("return (TResult)result;");
		}
	}
}

class WriteIndent: IDisposable
{
	GeneratedTextTransformation textTransformation;

	public WriteIndent(GeneratedTextTransformation textTransformation)
	{
		this.textTransformation = textTransformation;

		textTransformation.WriteLine("{");
		textTransformation.PushIndent("    ");
	}

	public void Dispose()
	{
		textTransformation.PopIndent();
		textTransformation.WriteLine("}");
	}
}

#>
