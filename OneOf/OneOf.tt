<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="Microsoft.CSharp" #>
<#@ assembly name="System.Runtime" #>
<#@ assembly name="$(SolutionDir)OneOf.TemplatingModels\bin\Release\OneOf.TemplatingModels.dll" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="Microsoft.VisualStudio.TextTemplating" #>
<#@ import namespace="OneOf.TemplatingModels" #>
<#@ output extension=".cs" #>
<#
GenerateClasses();
#>
<#+
void GenerateClasses()
{
	WriteLine("// ===========================================================================");
	WriteLine("// Generated by {0}", System.IO.Path.GetFileName(Host.TemplateFile));
	WriteLine("// ===========================================================================");
	WriteLine("");
	WriteLine("using System;");
	
	WriteLine("");
	WriteLine("namespace OneOf");
	using(new WriteBraces(this))
	{
		for (var i = 2; i <= Constants.MaxAritySupported; i++)
        {
            var template = new OneOfModel(i);
            WriteOneOf(template);
        }
	}
}

void WriteOneOf(OneOfModel model) 
{       
	WriteLine($"public class OneOf<{model.GenericArgs}> : OneOfBase<OneOf<{model.GenericArgs}>>");
	using(new WriteBraces(this))
	{
		// =============== Constructors
	    WriteLine($"public OneOf(object value) : base(value, null) {{ }}");
        WriteLine($"internal OneOf(object value, Type matchedType) : base(value, matchedType) {{ }}");

		foreach(var param in model.GenericParameters)
		{
            WriteLine($"public OneOf({param} value) : this(value, typeof({param})) {{ }}");
		}

	    // =============== implicit conversion to T
		WriteLine("");
		foreach(var param in model.GenericParameters)
		{
            WriteLine($"public static implicit operator {model.FullTypeName}({param} value) => new {model.FullTypeName}(value, typeof({param}));"); 
		}

		// =============== equality operators

		WriteLine("");
        WriteLine($"public static bool operator ==({model.FullTypeName} v1, {model.FullTypeName} v2) => Equals(v1, v2);"); 
		WriteLine($"public static bool operator !=({model.FullTypeName} v1, {model.FullTypeName}  v2) => !Equals(v1, v2);");

		// =============== Switch / SwitchWhen

		WriteLine("");
		foreach(var sm in model.SwitchMethods)
		{
		    WriteLine($"public {sm.LesserAritySwitcherResultTypeName} Switch(Action<{sm.GenericArg}> action)");
			WriteLine($" => new {sm.SwitcherTypeName}(value, valueTn).Switch(action);");
		}

		WriteLine("");
		foreach(var sm in model.SwitchMethods)
		{
		    WriteLine($"public {sm.SwitcherTypeName} SwitchWhen(Predicate<{sm.GenericArg}> condition, Action<{sm.GenericArg}> action)");
			WriteLine($" => new {sm.SwitcherTypeName}(value, valueTn).SwitchWhen(condition, action);");
		}

		// =============== Match / MatchWhen

        WriteLine($"public {model.IOneOfMatcherTypeName} MakeMatcher<TResult>() => new OneOfMatcher<{model.GenericArgs}, TResult>(value, valueTn);");
		WriteLine("");
		foreach(var mm in model.MatchMethods)
		{
		    WriteLine($"public {mm.LesserArityMatcherResultTypeName} Match<TResult>(Func<T{mm.ParameterNumber}, TResult> calcResult)");
			WriteLine($" => MakeMatcher<TResult>().Match(calcResult);");
		}

		WriteLine($"public {model.OneOfMatcherTypeName} MakeMatchWhener<TResult>() => new OneOfMatcher<{model.GenericArgs}, TResult>(value, valueTn);");
		WriteLine("");
		foreach(var mm in model.MatchMethods)
		{
		    WriteLine($"public {model.OneOfMatcherTypeName} MatchWhen<TResult>(Predicate<T{mm.ParameterNumber}> condition, Func<T{mm.ParameterNumber}, TResult> calcResult)");
			WriteLine($" => MakeMatchWhener<TResult>().MatchWhen(condition,calcResult);");
		}

		// =============== object overrides

		WriteLine("");
		WriteLine($"public override bool Equals(object obj) => (obj is OneOf<{model.GenericArgs}>) && Equals(value, ((OneOf<{model.GenericArgs}>)obj).value);");
		WriteLine("public override int GetHashCode() => (value?.GetHashCode() ?? 0);");
		WriteLine("public override string ToString() => (value?.ToString() ?? \"\");");
	}
}
             
class WriteBraces : IDisposable
{
	TextTransformation textTransformation;

	public WriteBraces(TextTransformation textTransformation)
	{
		this.textTransformation = textTransformation;

		textTransformation.WriteLine("{");
		textTransformation.PushIndent("    ");
	}

	public void Dispose()
	{
		textTransformation.PopIndent();
		textTransformation.WriteLine("}");
	}
}
#>