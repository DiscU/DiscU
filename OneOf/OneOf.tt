<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="Microsoft.CSharp" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="Microsoft.VisualStudio.TextTemplating" #>
<#@ output extension=".cs" #>
<# 
GenerateClasses(); 
#>
<#+
void GenerateClasses()
{
	WriteLine("// ===========================================================================");
	WriteLine("// Generated by {0}", System.IO.Path.GetFileName(Host.TemplateFile));
	WriteLine("// ===========================================================================");
	WriteLine("");
	WriteLine("using System;");
	
	WriteLine("");
	WriteLine("namespace OneOf");
	using(new WriteBraces(this))
	{
		for (var i = 2; i <= 9; i++)
			WriteOneOf(i);

		for (var i = 1; i <= 9; i++)
			WriteSwitcher(i);

		for (var i = 1; i <= 9; i++)
			WriteMatcher(i);
	}
}

void WriteOneOf(int countOfgenericParams) 
{
	var genericArgs = GenerateGenericArgs(Enumerable.Range(1, countOfgenericParams));

	WriteLine($"public class OneOf<{genericArgs}> : IOneOf");
	using(new WriteBraces(this))
	{
		WriteLine("private readonly object value;");
        WriteLine("private readonly Type origType;");
		
		// =============== Constructors
		// must only be called after value has been validated to be Tn
	    
		WriteLine("");
        WriteLine($"OneOf(object value, Type origType)");

		using(new WriteBraces(this))
		{
			WriteLine("this.value = value;");
            WriteLine("this.origType = origType;");

		}
		
	    // =============== IOneOf implementation

		WriteLine("");
		WriteLine("object IOneOf.Value => value;");
		WriteLine("Type IOneOf.OrigType => origType;");

		// =============== ToOneOf

		WriteLine("");
		for (var numberOfGenericsInNew = countOfgenericParams; numberOfGenericsInNew <= 9; numberOfGenericsInNew ++)
	    {
	        var nargs = Enumerable.Range(1, numberOfGenericsInNew).Select(e => "N" + e).ToArray();
	        var otherGenericArgs = string.Join(", ", nargs);
	        WriteLine($"public OneOf<{otherGenericArgs}> ToOneOf<{otherGenericArgs}>() => OneOfFactory<OneOf<{otherGenericArgs}>>.Create(value);");
	    }

	    // =============== implicit conversion to T
		// While it looks like we could use OneOf ctor directly as we know the value is a Tn, it might be a subclass of tn.
		// So to determine the best Tn to match the value with we need to use the OneOfFactory.

		WriteLine("");
		for(var parmIndex = 1; parmIndex <= countOfgenericParams; parmIndex ++)
		{
			WriteLine($"public static implicit operator OneOf<{genericArgs}>(T{parmIndex} value) => OneOfFactory<OneOf<{genericArgs}>>.Create(value);"); 
		}

		// Error CS0552	- user-defined conversions to or from an interface are not allowed
		// WriteLine($"public static implicit operator OneOf<{genericArgs}>(IOneOf oo) => OneOfFactory<OneOf<{genericArgs}>>.Create(oo.Value);"); 

		// =============== Switch / SwitchWhen

		WriteLine("");
		for(var parmIndex = 1; parmIndex <= countOfgenericParams; parmIndex ++)
		{
			var lesserArityOneOf = Enumerable.Range(1, countOfgenericParams).Where(n => n != parmIndex).ToList();
			var lesserArityGenericArgs = GenerateGenericArgs(lesserArityOneOf);

			WriteLine($"public OneOfSwitcher<{lesserArityGenericArgs}> Switch(Action<T{parmIndex}> action) => new OneOfSwitcher<{genericArgs}>(this).Switch(action);");
		}

		WriteLine("");
		for(var parmIndex = 1; parmIndex <= countOfgenericParams; parmIndex ++)
		{
			WriteLine($"public OneOfSwitcher<{genericArgs}> SwitchWhen(Predicate<T{parmIndex}> condition, Action<T{parmIndex}> action) => new OneOfSwitcher<{genericArgs}>(this).SwitchWhen(condition, action);");
		}

		// =============== Match / MatchWhen

		WriteLine("");
		for(var parmIndex = 1; parmIndex <= countOfgenericParams; parmIndex ++)
		{
			var lesserArityOneOf = Enumerable.Range(1, countOfgenericParams).Where(n => n != parmIndex).ToList();
			var lesserArityGenericArgs = GenerateGenericArgs(lesserArityOneOf);

			WriteLine($"public OneOfMatcher<{lesserArityGenericArgs}, TResult> Match<TResult>(Func<T{parmIndex}, TResult> calcResult) => new OneOfMatcher<{genericArgs}, TResult>(this).Match(calcResult);");
		}

		WriteLine("");
		for(var parmIndex = 1; parmIndex <= countOfgenericParams; parmIndex ++)
		{
			WriteLine($"public OneOfMatcher<{genericArgs}, TResult> MatchWhen<TResult>(Predicate<T{parmIndex}> condition, Func<T{parmIndex}, TResult> calcResult) => new OneOfMatcher<{genericArgs}, TResult>(this).MatchWhen(condition, calcResult);");
		}

		// =============== object overrides

		WriteLine("");
		WriteLine($"public override bool Equals(object obj) => (obj is OneOf<{genericArgs}>) && Equals(this.value, ((OneOf<{genericArgs}>)obj).value);");
		WriteLine("public override int GetHashCode() => (value?.GetHashCode() ?? 0);");
		WriteLine("public override string ToString() => (value?.ToString() ?? \"\");");
	}
}

void WriteSwitcher(int countOfgenericParams) 
{
	var genericArgs = GenerateGenericArgs(Enumerable.Range(1, countOfgenericParams));

	WriteLine("");
	WriteLine($"public struct OneOfSwitcher<{genericArgs}>");
	using(new WriteBraces(this))
	{
		WriteLine("readonly IOneOf oneOf;");
		WriteLine("bool hasSwitched;");

		// =============== Constructors
	    
		WriteLine("");
		WriteLine("internal OneOfSwitcher(IOneOf oneOf) : this(oneOf, false) { }");
	    
		WriteLine("");
		WriteLine("internal OneOfSwitcher(IOneOf oneOf, bool hasSwitched)");
		using(new WriteBraces(this))
		{
			WriteLine($"this.oneOf = oneOf;");
			WriteLine($"this.hasSwitched = hasSwitched;");
		}

		// =============== Switch
		for(var parmIndex = 1; parmIndex <= countOfgenericParams; parmIndex++)
		{
			var lesserArityGenericArgNumbers = Enumerable.Range(1, countOfgenericParams).ToList();
			if(lesserArityGenericArgNumbers.Count > 1)
			{
				lesserArityGenericArgNumbers.Remove(parmIndex);
				var lesserArityGenericArgs = GenerateGenericArgs(lesserArityGenericArgNumbers);

				WriteLine("");
				WriteLine($"public OneOfSwitcher<{lesserArityGenericArgs}> Switch(Action<T{parmIndex}> action)");
				using(new WriteBraces(this))
				{
					WriteLine($"SwitchImpl<T{parmIndex}>(null, action);");
					WriteLine($"return new OneOfSwitcher<{lesserArityGenericArgs}>(oneOf, hasSwitched);");
				}
			}
			else
			{
				WriteLine("");
				WriteLine($"public void Switch(Action<T{parmIndex}> action)");
				using(new WriteBraces(this))
				{
					WriteLine($"SwitchImpl<T{parmIndex}>(null, action);");
				}
			}
		}

		// =============== SwitchWhen

		for(var parmIndex = 1; parmIndex <= countOfgenericParams; parmIndex++)
		{
			WriteLine("");
			WriteLine($"public OneOfSwitcher<{genericArgs}> SwitchWhen(Predicate<T{parmIndex}> condition, Action<T{parmIndex}> action)");
			using(new WriteBraces(this))
			{
				WriteLine($"SwitchImpl<T{parmIndex}>(condition, action);");
				WriteLine($"return this;");
			}
		}

		// =============== Else

		WriteLine("");
		WriteLine($"public void Else(Action<object> action)");
		using(new WriteBraces(this))
		{
			WriteLine($"if (!hasSwitched) action(oneOf.Value);");
		}

		// =============== ElseThrow

		WriteLine("");
		WriteLine($"public void ElseThrow(Func<object, Exception> func)");
		using(new WriteBraces(this))
		{
			WriteLine($"if (!hasSwitched) throw func(oneOf.Value);");
		}

		// =============== SwitchImpl
		
		WriteLine("");
		WriteLine($"void SwitchImpl<T>(Predicate<T> condition, Action<T> action)");
		using(new WriteBraces(this))
		{
			WriteLine($"if (hasSwitched) return;                 // already switched");
			WriteLine("");

			WriteLine($"if (oneOf.OrigType != typeof(T)) return; // not correct type");
			WriteLine($"if (condition != null && !condition((T)oneOf.Value)) return;  // failed condition");

			WriteLine("");
			WriteLine($"action((T)oneOf.Value);                  // yes!");
			WriteLine("hasSwitched = true;");
		}
	}
}

void WriteMatcher(int countOfgenericParams) 
{
	var genericArgs = GenerateGenericArgs(Enumerable.Range(1, countOfgenericParams), withResult: "TResult");

	WriteLine("");
	WriteLine($"public struct OneOfMatcher<{genericArgs}>" );
	using(new WriteBraces(this))
	{
		WriteLine("readonly IOneOf oneOf;");
		WriteLine("object result;");

		// =============== Constructors
	    
		WriteLine("");
		WriteLine("internal OneOfMatcher(IOneOf oneOf) : this(oneOf, null) { }");
	    
		WriteLine("");
		WriteLine("internal OneOfMatcher(IOneOf oneOf, object result)");
		using(new WriteBraces(this))
		{
			WriteLine($"this.oneOf = oneOf;");
			WriteLine($"this.result = result;");
		}

		// =============== Match

		for(var parmIndex = 1; parmIndex <= countOfgenericParams; parmIndex++)
		{
			var lesserArityGenericArgNumbers = Enumerable.Range(1, countOfgenericParams).ToList();
			if(lesserArityGenericArgNumbers.Count > 1)
			{
				lesserArityGenericArgNumbers.Remove(parmIndex);
				var lesserArityGenericArgs = GenerateGenericArgs(lesserArityGenericArgNumbers, withResult: "TResult");

				WriteLine("");
				WriteLine($"public OneOfMatcher<{lesserArityGenericArgs}> Match(Func<T{parmIndex}, TResult> createResult)");
				using(new WriteBraces(this))
				{
					WriteLine($"MatchImpl<T{parmIndex}>(null, createResult);");
					WriteLine($"return new OneOfMatcher<{lesserArityGenericArgs}>(oneOf, result);");
				}
			}
			else
            {
				WriteLine("");
				WriteLine($"public TResult Match(Func<T{parmIndex}, TResult> createResult)");
				using(new WriteBraces(this))
				{
					WriteLine($"MatchImpl<T{parmIndex}>(null, createResult);");
					WriteLine($"return (TResult)result;");
				}
            }
		}

		// =============== MatchWhen

		for(var parmIndex = 1; parmIndex <= countOfgenericParams; parmIndex++)
		{
			WriteLine("");
			WriteLine($"public OneOfMatcher<{genericArgs}> MatchWhen(Predicate<T{parmIndex}> condition, Func<T{parmIndex}, TResult> createResult)");
			using(new WriteBraces(this))
			{
				WriteLine($"MatchImpl<T{parmIndex}>(condition, createResult);");
				WriteLine($"return this;");
			}
		}

		// =============== Else(default)

		WriteLine("");
		WriteLine($"public TResult Else(TResult defaultValue)");
		using(new WriteBraces(this))
		{
			WriteLine($"if (result == null) result = defaultValue;");
			WriteLine("return (TResult)result;");
		}

		// =============== Else(func)

		WriteLine("");
		WriteLine($"public TResult Else(Func<object, TResult> createResult)");
		using(new WriteBraces(this))
		{
			WriteLine($"if (result == null) result = createResult(oneOf.Value);");
			WriteLine("return (TResult)result;");
		}

		// =============== ElseThrow

		WriteLine("");
		WriteLine($"public TResult ElseThrow(Func<object, Exception> createException)");
		using(new WriteBraces(this))
		{
			WriteLine($"if (result == null) throw createException(oneOf.Value);");
			WriteLine("return (TResult)result;");
		}

		// =============== MatchImpl
		
		WriteLine("");
		WriteLine($"void MatchImpl<T>(Predicate<T> condition, Func<T, TResult> createResult)");
		using(new WriteBraces(this))
		{
			WriteLine($"if (result != null) return;              // already matched");
			WriteLine("");

			WriteLine($"if (oneOf.OrigType != typeof(T)) return; // not correct type");
			WriteLine($"if (condition != null && !condition((T)oneOf.Value)) return;  // failed condition");
			WriteLine("");
			WriteLine($"result = createResult((T)oneOf.Value);   // yes!");
		}
	}

}

string GenerateGenericArgs(IEnumerable<int> argNumbers, string typePrefix = "T", string withResult = null)
{
	return string.Join(", ", argNumbers.Select(n => typePrefix + n))
		+ (withResult != null ? ", " + withResult : "");
}

class WriteBraces: IDisposable
{
	TextTransformation textTransformation;

	public WriteBraces(TextTransformation textTransformation)
	{
		this.textTransformation = textTransformation;

		textTransformation.WriteLine("{");
		textTransformation.PushIndent("    ");
	}

	public void Dispose()
	{
		textTransformation.PopIndent();
		textTransformation.WriteLine("}");
	}
}

#>
