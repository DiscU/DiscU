<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="Microsoft.CSharp" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<# 
GenerateClasses(); 
#>
<#+
void GenerateClasses()
{
	WriteLine("// ===========================================================================");
	WriteLine("// Generated by {0}", System.IO.Path.GetFileName(Host.TemplateFile));
	WriteLine("// ===========================================================================");
	WriteLine("");
	WriteLine("using System;");
	WriteLine("using Newtonsoft.Json;");
	WriteLine("");
	WriteLine("namespace OneOf");
	using(var indent1 = new Indent(this))
	{
		for (var i = 1; i < 10; i++)
			WriteType("OneOf", true, i);

		for (var i = 1; i < 10; i++)
			WriteType("OneOfBase", false, i);
	}
}

void WriteType(string typeName, bool isStruct, int countOfgenericParams) 
{
	var genericArg = string.Join(", ", Enumerable.Range(0, countOfgenericParams).Select(e => "T" + e));
	var structOrClass = isStruct ? "struct" : "class";

    WriteLine("[JsonConverter(typeof(OneOfJsonConverter))]");
	WriteLine($"public {structOrClass} {typeName}<{genericArg}> : IOneOf");
	using(var indent1 = new Indent(this))
	{
		WriteLine("readonly object value;");

		for (var parmIndex = 0; parmIndex < countOfgenericParams; parmIndex++)
		{
			WriteLine($"static readonly Type typeT{parmIndex} = typeof(T{parmIndex});");
		}

		// =============== Constructors
	    
		WriteLine("");
		WriteLine($"{typeName}(object value)");
		using(var indent2 = new Indent(this))
		{
			WriteLine("// assumes will only be called after being validated in some way");
			WriteLine($"this.value = value;");
		}

		if (!isStruct)
		{
			WriteLine("");
			WriteLine($"protected {typeName}()");
			using(var indent2 = new Indent(this))
			{
				WriteLine("// assumes will only be called after being validated in some way");
				WriteLine("this.value = this;");
			}
		}

		// =============== Create
	    
		WriteLine("");
		WriteLine($"internal static {typeName}<{genericArg}> Create(object value)");
		using(var indent2 = new Indent(this))
		{
			WriteLine($"if (value == null) throw new ArgumentNullException(\"value\");");
			WriteLine("");

			WriteLine("var valueType = value.GetType();");
			for(var parmIndex = 0; parmIndex < countOfgenericParams; parmIndex ++)
			{
				WriteLine($"if (valueType == typeT{parmIndex}) return new {typeName}<{genericArg}>((T{parmIndex})value);");
			}

			WriteLine("");
	    	WriteLine($"throw new ArgumentException(\"value\");");
		}

		// =============== EnsureValueNotNull

		WriteLine("");
		WriteLine($"void EnsureValueNotNull()");
		using(var indent2 = new Indent(this))
		{
			WriteLine($"if (value == null) throw new InvalidOperationException(\"Value has not been set\");");
		}

		// =============== IOneOf implementation

		WriteLine("");
		WriteLine("object IOneOf.Value => value;");

		// =============== Is

		WriteLine("");
		WriteLine($"public bool Is<T>()");
		using(var indent2 = new Indent(this))
		{
			WriteLine("EnsureValueNotNull();");
			WriteLine($"if (this.value.GetType() == typeof(T)) return true;");
			WriteLine("");
			WriteLine("return false;");
		}

		// =============== As

		WriteLine("");
		WriteLine($"public T As<T>()");
		using(var indent2 = new Indent(this))
		{
			WriteLine("EnsureValueNotNull();");
			WriteLine($"if (this.value.GetType() == typeof(T)) return (T)this.value;");
			WriteLine("");
			WriteLine("throw new InvalidOperationException();");
		}

		// =============== ToOneOf

		WriteLine("");
		WriteLine("// Use slower Create method which does full type checks at runtime as compiler couldn't do them for us.");
		for(var newIndex = 0; newIndex < 9; newIndex ++)
		{
			var otherGenericArgs = string.Join(", ", Enumerable.Range(0, newIndex+1).Select(e => "N" + e));

			WriteLine($"public {typeName}<{otherGenericArgs}> ToOneOf<{otherGenericArgs}>() => {typeName}<{otherGenericArgs}>.Create(value);");
		}

		// =============== implicit conversion to T

		WriteLine("");
		WriteLine("// Can use fast Ctor as compiler can check types for us.");
		for(var parmIndex = 0; parmIndex < countOfgenericParams; parmIndex ++)
		{
			WriteLine($"public static implicit operator {typeName}<{genericArg}>(T{parmIndex} value) => new {typeName}<{genericArg}>(value);"); 
		}

		// =============== Switch

		var switchArgList = string.Join(", ", Enumerable.Range(0, countOfgenericParams).Select(e => "Action<T" + e + "> f" + e + " = null"));

		WriteLine("");
	    WriteLine($"public void Switch({switchArgList}, Action otherwise = null)");
		using(var indent2 = new Indent(this))
		{
			WriteLine("EnsureValueNotNull();");
			WriteLine("var valueType = value.GetType();");
			for (var parmIndex = 0; parmIndex < countOfgenericParams; parmIndex++)
			{
				WriteLine($"if (f{parmIndex} != null && valueType == typeT{parmIndex}) {{ f{parmIndex}((T{parmIndex})this.value); return; }}");
			}

			WriteLine("");
		    WriteLine("if (otherwise != null) { otherwise(); return; }");

			WriteLine("");
			WriteLine("throw new InvalidOperationException();");
		}

		// =============== Match

		var matchArgList = string.Join(", ", Enumerable.Range(0, countOfgenericParams).Select(e => "Func<T" + e + ", TResult> f" + e + " = null"));

		WriteLine("");
	    WriteLine($"public TResult Match<TResult>({matchArgList}, Func<TResult> otherwise = null)");
		using(var indent2 = new Indent(this))
		{
			WriteLine("EnsureValueNotNull();");
			WriteLine("var valueType = value.GetType();");
			for (var parmIndex = 0; parmIndex < countOfgenericParams; parmIndex++)
			{
				WriteLine($"if (f{parmIndex} != null && valueType == typeT{parmIndex}) return f{parmIndex}((T{parmIndex})this.value);");
			}

			WriteLine("");
		    WriteLine("if (otherwise != null) return otherwise();");

			WriteLine("");
	    	WriteLine("throw new InvalidOperationException();");
		}

		// =============== object overrides

		WriteLine("");
		WriteLine("public override bool Equals(object obj)");
		using(var indent2 = new Indent(this))
		{
            WriteLine("if (ReferenceEquals(null, obj)) return false;");
            WriteLine($"if (!(obj is {typeName}<{genericArg}>)) return false;");
			WriteLine("");
            WriteLine($"var other = ({typeName}<{genericArg}>)obj;");
            WriteLine("return Equals(value, other.value);");
		}

		WriteLine("");
		WriteLine("public override int GetHashCode() => (value?.GetHashCode() ?? 0);");

		WriteLine("");
		WriteLine("public override string ToString() => (value?.ToString() ?? \"\");");
	}

	WriteLine("");
}

class Indent: IDisposable
{
	GeneratedTextTransformation textTransformation;

	public Indent(GeneratedTextTransformation textTransformation)
	{
		this.textTransformation = textTransformation;

		textTransformation.WriteLine("{");
		textTransformation.PushIndent("    ");
	}

	public void Dispose()
	{
		textTransformation.PopIndent();
		textTransformation.WriteLine("}");
	}
}

#>
