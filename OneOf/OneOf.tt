<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="Microsoft.CSharp" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="Microsoft.VisualStudio.TextTemplating" #>
<#@ output extension=".cs" #>
<# 
GenerateClasses(); 
#>
<#+
void GenerateClasses()
{
	WriteLine("// ===========================================================================");
	WriteLine("// Generated by {0}", System.IO.Path.GetFileName(Host.TemplateFile));
	WriteLine("// ===========================================================================");
	WriteLine("");
	WriteLine("using System;");
	WriteLine("using Microsoft.CSharp.RuntimeBinder;");
	
	WriteLine("");
	WriteLine("namespace OneOf");
	using(new WriteIndent(this))
	{
		for (var i = 2; i < 10; i++)
			WriteOneOf(true, i);

		for (var i = 2; i < 10; i++)
			WriteOneOf(false, i);

		for (var i = 1; i < 10; i++)
			WriteSwitcher(i);

		for (var i = 1; i < 10; i++)
			WriteMatcher(i);
	}
}
string GenerateGenericArgs(IEnumerable<int> ints, string typePrefix = "T", string withResult = null)
{
    return string.Join(", ", ints.Select(e => typePrefix + e)) + (withResult != null ? ", " + withResult : "");
}
void WriteOneOf(bool isStruct, int countOfgenericParams) 
{
	var genericArg = GenerateGenericArgs(Enumerable.Range(0, countOfgenericParams));
	var structOrClass = isStruct ? "struct" : "class";
	var typeName = isStruct ? "OneOf" : "OneOfBase";

	WriteLine($"public {structOrClass} {typeName}<{genericArg}> : IOneOf");
	using(new WriteIndent(this))
	{
		WriteLine("readonly object value;");
        WriteLine("readonly Type origType;");
		
		// =============== Constructors
		// must only be called after value has been validated to be Tn
	    
		WriteLine("");
        WriteLine($"{typeName}(object value, Type origType)");

		using(new WriteIndent(this))
		{
			WriteLine("this.value = value;");
            WriteLine("this.origType = origType;");

		}

		if (!isStruct)
		{
			WriteLine("");
			WriteLine($"protected {typeName}()");
			using(new WriteIndent(this))
			{
				WriteLine("this.value = this;");
				WriteLine("this.origType = GetType();");
			}
		}
		
	    // =============== IOneOf implementation

		WriteLine("");
		WriteLine("object IOneOf.Value => value;");

        // =============== Create/CreateRaw
        
        WriteLine("");
        WriteLine($"internal static {typeName}<{genericArg}> CreateRaw(object value)");
        using(new WriteIndent(this))
        {
			WriteLine("if (value == null) throw new ArgumentNullException(nameof(value));");
            for(var parmIndex = 0; parmIndex < countOfgenericParams; parmIndex ++)
            {
				//cover our fast exact Type matches
                WriteLine($"if (value.GetType() == typeof(T{parmIndex})) return Create((T{parmIndex})value);");
            }
			//prepare to catch any dynamic binding exceptions...
			WriteLine("try");
            using(new WriteIndent(this))            
			{
				//fall back to best match for non-exact type matches (subclasses, interface implementations, etc.)
				//by performing double dispatch via dynamic casting. This will attempt to bind to the most specific create method available.
				// This can be improved via reflection trickery if we decide there is a performance justification for it
				WriteLine($"return Create((dynamic)value);");
            }
            WriteLine("catch (RuntimeBinderException ex)");
            using (new WriteIndent(this))
            {
				//this SHOULDN'T happen thanks to already being in the context of a validly casted object, but you never know...
                WriteLine("throw new ArgumentException(nameof(value), ex);");
            }
        }

		WriteLine("");
		for(var parmIndex = 0; parmIndex < countOfgenericParams; parmIndex ++)
        {
			WriteLine($"static {typeName}<{genericArg}> Create(T{parmIndex} value) => new {typeName}<{genericArg}>(value, typeof(T{parmIndex}));");
		}

		// =============== ToOneOf
		// now just uses CreateRaw to get best of both worlds for conversion.  Can blow up if user has incompatible types, but the C# Type system is
		// just not powerful enough for us to save them from that with any reasonable approaches.
		WriteLine("");
		for (var numberOfGenericsInNew = countOfgenericParams - 1; numberOfGenericsInNew < 9; numberOfGenericsInNew ++)
	    {
	            var nargs = Enumerable.Range(0, numberOfGenericsInNew + 1).Select(e => "N" + e).ToArray();
	            var otherGenericArgs = string.Join(", ", nargs);
	            WriteLine($"public {typeName}<{otherGenericArgs}> ToOneOf<{otherGenericArgs}>() => {typeName}<{otherGenericArgs}>.CreateRaw(value);");
	    }

	    // =============== implicit conversion to T
		// Now uses CreateRaw.  Not much slower than just calling the raw constructor, and ensures we get proper handling for polymorphic situations.
		WriteLine("");
		for(var parmIndex = 0; parmIndex < countOfgenericParams; parmIndex ++)
		{
			WriteLine($"public static implicit operator {typeName}<{genericArg}>(T{parmIndex} value) => CreateRaw(value);"); 
		}

		// =============== equality operators
		WriteLine("");
		WriteLine($"public static bool operator ==({typeName}<{genericArg}> v1, IOneOf v2) => v1.Equals(v2);"); 
		WriteLine($"public static bool operator !=({typeName}<{genericArg}> v1, IOneOf v2) => !v1.Equals(v2);");
		//also adding equality operators to compare to the various Generic types by value
	    for (var i = 0; i < countOfgenericParams; i++)
	    {
			WriteLine($"public static bool operator ==({typeName}<{genericArg}> v1, T{i} v2) => v1.Equals(v2);"); 
			WriteLine($"public static bool operator !=({typeName}<{genericArg}> v1, T{i} v2) => !v1.Equals(v2);");
			WriteLine($"public static bool operator ==(T{i} v1, {typeName}<{genericArg}> v2) => v2.Equals(v1);"); 
			WriteLine($"public static bool operator !=(T{i} v1, {typeName}<{genericArg}> v2) => !v2.Equals(v1);");
	    }


		// =============== Switch
		WriteLine("");
		for(var parmIndex = 0; parmIndex < countOfgenericParams; parmIndex ++)
		{
			var lesserArityOneOf = Enumerable.Range(0, countOfgenericParams).Where(n => n != parmIndex).ToList();
			var lesserArityGenericArg = GenerateGenericArgs(lesserArityOneOf);

			WriteLine($"public OneOfSwitcher<{lesserArityGenericArg}> Switch(Action<T{parmIndex}> action) => new OneOfSwitcher<{genericArg}>(value, origType, false).Switch(action);");
		}

		// =============== Match

		WriteLine("");
		for(var parmIndex = 0; parmIndex < countOfgenericParams; parmIndex ++)
		{
			var lesserArityOneOf = Enumerable.Range(0, countOfgenericParams).Where(n => n != parmIndex).ToList();
			var lesserArityGenericArg = GenerateGenericArgs(lesserArityOneOf);

			WriteLine($"public OneOfMatcher<{lesserArityGenericArg}, TResult> Match<TResult>(Func<T{parmIndex}, TResult> func) => new OneOfMatcher<{genericArg}, TResult>(value, origType, null).Match(func);");
		}

		// =============== object overrides

		WriteLine("");
		// Returns true if the object is either an IOneOf, or if the value equals the OneOf, rather than only if it is the same kind of OneOf.
		WriteLine($"public override bool Equals(object obj) => (obj is IOneOf) && Equals(value, ((IOneOf)obj).Value) || value.Equals(obj);");
		WriteLine("public override int GetHashCode() => (value?.GetHashCode() ?? origType?.GetHashCode() ?? 0);");
		WriteLine("public override string ToString() => (value?.ToString() ?? \"\");");
	}
}

void WriteSwitcher(int countOfgenericParams) 
{
	var genericArg = GenerateGenericArgs(Enumerable.Range(0, countOfgenericParams));

	WriteLine("");
	WriteLine($"public struct OneOfSwitcher<{genericArg}>");
	using(new WriteIndent(this))
	{
		WriteLine("readonly object value;");
		WriteLine("readonly Type origType;");
		WriteLine("bool hasSwitched;");

		// =============== Constructors
	    
		WriteLine("");
		WriteLine("internal OneOfSwitcher(object value, Type origType, bool hasSwitched)");
		using(new WriteIndent(this))
		{
			WriteLine($"this.value = value;");
			WriteLine($"this.origType = origType;");
			WriteLine($"this.hasSwitched = hasSwitched;");
		}

		// =============== Switch
		for(var parmIndex = 0; parmIndex < countOfgenericParams; parmIndex++)
		{
			var lesserArityOneOf = Enumerable.Range(0, countOfgenericParams).ToList();
			if(lesserArityOneOf.Count > 1)
			{
				lesserArityOneOf.Remove(parmIndex);
				var lesserArityGenericArg = GenerateGenericArgs(lesserArityOneOf);

				WriteLine("");
				WriteLine($"public OneOfSwitcher<{lesserArityGenericArg}> Switch(Action<T{parmIndex}> action)");
				using(new WriteIndent(this))
				{
					WriteLine($"if (this.origType == typeof(T{parmIndex}))");
					using(new WriteIndent(this))
					{
						WriteLine($"action((T{parmIndex})value);");
						WriteLine("hasSwitched = true;");
					}
					WriteLine($"return new OneOfSwitcher<{lesserArityGenericArg}>(this.value, this.origType, this.hasSwitched);");
				}
			}
			else
			{
				WriteLine("");
				WriteLine($"public void Switch(Action<T{parmIndex}> action)");
				using(new WriteIndent(this))
				{
					WriteLine($"if (this.origType == typeof(T{parmIndex})) action((T{parmIndex})value);");
				}
			}
		}

		// =============== Else

		WriteLine("");
		WriteLine($"public void Else(Action<object> action)");
		using(new WriteIndent(this))
		{
			WriteLine($"if (!hasSwitched) action(value);");
		}

		// =============== ElseThrow

		WriteLine("");
		WriteLine($"public void ElseThrow(Func<object, Exception> func)");
		using(new WriteIndent(this))
		{
			WriteLine($"if (!hasSwitched) throw func(value);");
		}
	}
}

void WriteMatcher(int countOfgenericParams) 
{
	var genericArg = GenerateGenericArgs(Enumerable.Range(0, countOfgenericParams), withResult: "TResult");

	WriteLine("");
	WriteLine($"public struct OneOfMatcher<{genericArg}>" );
	using(new WriteIndent(this))
	{
		WriteLine("readonly object value;");
		WriteLine("readonly Type origType;");
		WriteLine("object result;");

		// =============== Constructors
	    
		WriteLine("");
		WriteLine("internal OneOfMatcher(object value, Type origType, object result)");
		using(new WriteIndent(this))
		{
			WriteLine($"this.value = value;");
			WriteLine($"this.origType = origType;");
			WriteLine($"this.result = result;");
		}

		// =============== Match

		for(var parmIndex = 0; parmIndex < countOfgenericParams; parmIndex++)
		{
			var lesserArityOneOf = Enumerable.Range(0, countOfgenericParams).ToList();
			if(lesserArityOneOf.Count > 1)
			{
				lesserArityOneOf.Remove(parmIndex);
			
				var lesserArityGenericArg = GenerateGenericArgs(lesserArityOneOf,withResult: "TResult");
				WriteLine("");
				WriteLine($"public OneOfMatcher<{lesserArityGenericArg}> Match(Func<T{parmIndex}, TResult> createResult)");
				using(new WriteIndent(this))
				{
					WriteLine($"if (result == null && typeof(T{parmIndex}) == origType) result = createResult((T{parmIndex})value);");
					WriteLine($"return new OneOfMatcher<{lesserArityGenericArg}>(this.value, this.origType, this.result);");
				}
			}
			else
            {
				WriteLine($"public TResult Match(Func<T{parmIndex}, TResult> createResult)");
				using(new WriteIndent(this))
				{
					WriteLine($"if (result == null && typeof(T{parmIndex}) == origType) result = createResult((T{parmIndex})value);");
					WriteLine($"return (TResult)result;");
				}
            }
		}

		// =============== Else(default)

		WriteLine("");
		WriteLine($"public TResult Else(TResult defaultValue)");
		using(new WriteIndent(this))
		{
			WriteLine($"if (result == null) result = defaultValue;");
			WriteLine("return (TResult)result;");
		}

		// =============== Else(func)

		WriteLine("");
		WriteLine($"public TResult Else(Func<object, TResult> createResult)");
		using(new WriteIndent(this))
		{
			WriteLine($"if (result == null) result = createResult(value);");
			WriteLine("return (TResult)result;");
		}

		// =============== ElseThrow

		WriteLine("");
		WriteLine($"public TResult ElseThrow(Func<object, Exception> createException)");
		using(new WriteIndent(this))
		{
			WriteLine($"if (result == null) throw createException(value);");
			WriteLine("return (TResult)result;");
		}
	}
}

class WriteIndent: IDisposable
{
	TextTransformation textTransformation;

	public WriteIndent(TextTransformation textTransformation)
	{
		this.textTransformation = textTransformation;

		textTransformation.WriteLine("{");
		textTransformation.PushIndent("    ");
	}

	public void Dispose()
	{
		textTransformation.PopIndent();
		textTransformation.WriteLine("}");
	}
}

#>
