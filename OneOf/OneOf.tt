<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="Microsoft.CSharp" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<# 
GenerateClasses(); 
#>
<#+
void GenerateClasses()
{
	WriteLine("// ===========================================================================");
	WriteLine("// Generated by {0}", System.IO.Path.GetFileName(Host.TemplateFile));
	WriteLine("// ===========================================================================");
	WriteLine("");
	WriteLine("using System;");
	WriteLine("using Newtonsoft.Json;");
	WriteLine("");
	WriteLine("namespace OneOf");
	using(var indent1 = new Indent(this))
	{
		for (var i = 1; i < 10; i++)
			WriteOneOf(true, i);

		for (var i = 1; i < 10; i++)
			WriteOneOf(false, i);

		for (var i = 1; i < 10; i++)
			WriteSwitcher(i);

		for (var i = 1; i < 10; i++)
			WriteMatcher(i);

		for (var i = 1; i < 10; i++)
			WriteMatcherInterface(i);
	}
}
string GenerateGenericArgs(IEnumerable<int> ints, string typePrefix = "T", string withResult = null)
{
    return string.Join(", ", ints.Select(e => typePrefix + e)) + (withResult != null ? ", " + withResult : "");
}
void WriteOneOf(bool isStruct, int countOfgenericParams) 
{
	var genericArg = GenerateGenericArgs(Enumerable.Range(0, countOfgenericParams));
	var structOrClass = isStruct ? "struct" : "class";
	var typeName = isStruct ? "OneOf" : "OneOfBase";

    WriteLine("[JsonConverter(typeof(OneOfJsonConverter))]");
	WriteLine($"public {structOrClass} {typeName}<{genericArg}> : IOneOf");
	using(var indent1 = new Indent(this))
	{
		WriteLine("readonly object value;");

		// =============== Constructors
	    
		WriteLine("");
		WriteLine($"{typeName}(object value)");
		using(var indent2 = new Indent(this))
		{
			WriteLine("// assumes will only be called after being validated in some way");
			WriteLine($"this.value = value;");
		}

		if (!isStruct)
		{
			WriteLine("");
			WriteLine($"protected {typeName}()");
			using(var indent2 = new Indent(this))
			{
				WriteLine("// assumes will only be called after being validated in some way");
				WriteLine("this.value = this;");
			}
		}

		// =============== Create
	    
		WriteLine("");
		WriteLine($"internal static {typeName}<{genericArg}> Create(object value)");
		using(var indent2 = new Indent(this))
		{
			WriteLine($"if (value == null) throw new ArgumentNullException(\"value\");");
			WriteLine("");

			for(var parmIndex = 0; parmIndex < countOfgenericParams; parmIndex ++)
			{
				WriteLine($"if (value is T{parmIndex}) return new {typeName}<{genericArg}>((T{parmIndex})value);");
			}

			WriteLine("");
	    	WriteLine($"throw new ArgumentException(\"value\");");
		}

		// =============== EnsureValueNotNull

		WriteLine("");
		WriteLine($"void EnsureValueNotNull()");
		using(var indent2 = new Indent(this))
		{
			WriteLine($"if (value == null) throw new InvalidOperationException(\"Value has not been set\");");
		}

		// =============== IOneOf implementation

		WriteLine("");
		WriteLine("object IOneOf.Value => value;");

		// =============== Is

		WriteLine("");
		WriteLine($"public bool Is<T>()");
		using(var indent2 = new Indent(this))
		{
			WriteLine("EnsureValueNotNull();");
			WriteLine($"if (this.value is T) return true;");
			WriteLine("");
			WriteLine("return false;");
		}

		// =============== As

		WriteLine("");
		WriteLine($"public T As<T>()");
		using(var indent2 = new Indent(this))
		{
			WriteLine("EnsureValueNotNull();");
			WriteLine($"if (this.value is T) return (T)this.value;");
			WriteLine("");
			WriteLine("throw new InvalidOperationException();");
		}

		// =============== ToOneOf

		WriteLine("");
		WriteLine("// Use slower Create method which does full type checks at runtime as compiler couldn't do them for us.");
		for(var newIndex = 0; newIndex < 9; newIndex ++)
		{
			var otherGenericArgs = string.Join(", ", Enumerable.Range(0, newIndex+1).Select(e => "N" + e));

			WriteLine($"public {typeName}<{otherGenericArgs}> ToOneOf<{otherGenericArgs}>() => {typeName}<{otherGenericArgs}>.Create(value);");
		}

		// =============== implicit conversion to T

		WriteLine("");
		WriteLine("// Can use fast Ctor as compiler can check types for us.");
		for(var parmIndex = 0; parmIndex < countOfgenericParams; parmIndex ++)
		{
			WriteLine($"public static implicit operator {typeName}<{genericArg}>(T{parmIndex} value) => new {typeName}<{genericArg}>(value);"); 
		}

		// =============== Switch

		WriteLine("");
		WriteLine($"public OneOfSwitcher<{genericArg}> Switch()");
		using(var indent2 = new Indent(this))
        {
			WriteLine("EnsureValueNotNull();");
            WriteLine($"return new OneOfSwitcher<{genericArg}>(value);");
        }

		// =============== Match

		WriteLine("");
		WriteLine($"public OneOfMatcher<{genericArg}, TResult> Match<TResult>()");
		using(var indent2 = new Indent(this))
        {
			WriteLine("EnsureValueNotNull();");
            WriteLine($"return new OneOfMatcher<{genericArg}, TResult>(value, null);");
        }

		// =============== object overrides

		WriteLine("");
		WriteLine("public override bool Equals(object obj)");
		using(var indent2 = new Indent(this))
		{
            WriteLine($"if (!(obj is {typeName}<{genericArg}>)) return false;");
			WriteLine("");
            WriteLine($"var other = ({typeName}<{genericArg}>)obj;");
            WriteLine("return Equals(value, other.value);");
		}

		WriteLine("");
		WriteLine("public override int GetHashCode() => (value?.GetHashCode() ?? 0);");

		WriteLine("");
		WriteLine("public override string ToString() => (value?.ToString() ?? \"\");");
	}

	WriteLine("");
}

void WriteSwitcher(int countOfgenericParams) 
{
	var genericArg = GenerateGenericArgs(Enumerable.Range(0, countOfgenericParams));

	WriteLine("");
	WriteLine($"public struct OneOfSwitcher<{genericArg}>");
	using(var indent1 = new Indent(this))
	{
		WriteLine("readonly object value;");
		WriteLine("bool hasSwitched;");

		// =============== Constructors
	    
		WriteLine("");
		WriteLine("internal OneOfSwitcher(object value)");
		using(var indent2 = new Indent(this))
		{
			WriteLine($"this.value = value;");
			WriteLine($"this.hasSwitched = false;");
		}

		// =============== When

		for(var parmIndex = 0; parmIndex < countOfgenericParams; parmIndex++)
		{
			WriteLine("");
			WriteLine($"public OneOfSwitcher<{genericArg}> When(Action<T{parmIndex}> action)");
			using(var indent2 = new Indent(this))
			{
				WriteLine($"if (this.value is T{parmIndex})");
				using(var indent3 = new Indent(this))
				{
					WriteLine($"action.Invoke((T{parmIndex})value);");
					WriteLine("hasSwitched = true;");
				}
				WriteLine("return this;");
			}
		}

		// =============== Otherwise

		WriteLine("");
		WriteLine($"public void Otherwise(Action<object> action)");
		using(var indent2 = new Indent(this))
		{
			WriteLine($"if (!hasSwitched) action.Invoke(value);");
		}

		// =============== OtherwiseThrow

		WriteLine("");
		WriteLine($"public void OtherwiseThrow(Func<object, Exception> func)");
		using(var indent2 = new Indent(this))
		{
			WriteLine($"if (!hasSwitched) throw func.Invoke(value);");
		}
	}
}


void WriteMatcherInterface(int countOfGenericParams)
{
	var genericArg = GenerateGenericArgs(Enumerable.Range(0, countOfGenericParams), withResult: "TResult");

	WriteLine($"public interface IOneOfMatcher<{genericArg}> : IOtherwiser<TResult>");
	using(new Indent(this))
	{
		for(var parmIndex = 0; parmIndex < countOfGenericParams; parmIndex++)
		{
			var lesserArityOneOf = Enumerable.Range(0, countOfGenericParams).ToList();
			if(lesserArityOneOf.Count > 1)
			{
				lesserArityOneOf.Remove(parmIndex);
				var lesserArityGenericArg = GenerateGenericArgs(lesserArityOneOf,withResult: "TResult");
				WriteLine("");
				WriteLine($"IOneOfMatcher<{lesserArityGenericArg}> When(Func<T{parmIndex}, TResult> func);");
			}
			else
            {
				WriteLine($"IOtherwiser<TResult> When(Func<T{parmIndex}, TResult> func);");
            }
		}
	}
}

void WriteMatcher(int countOfgenericParams) 
{
	var genericArg = GenerateGenericArgs(Enumerable.Range(0, countOfgenericParams), withResult: "TResult");

	WriteLine("");
	WriteLine($"public struct OneOfMatcher<{genericArg}> : IOneOfMatcher<{genericArg}>" );
	using(var indent1 = new Indent(this))
	{
		WriteLine("readonly object value;");
		WriteLine("object result;");

		// =============== Constructors
	    
		WriteLine("");
		WriteLine("internal OneOfMatcher(object value, object result)");
		using(var indent2 = new Indent(this))
		{
			WriteLine($"this.value = value;");
			WriteLine($"this.result = result;");
		}

		// =============== When

		for(var parmIndex = 0; parmIndex < countOfgenericParams; parmIndex++)
		{
			var lesserArityOneOf = Enumerable.Range(0, countOfgenericParams).ToList();
			if(lesserArityOneOf.Count > 1)
			{
				lesserArityOneOf.Remove(parmIndex);
			
				var lesserArityGenericArg = GenerateGenericArgs(lesserArityOneOf,withResult: "TResult");
				WriteLine("");
				WriteLine($"public IOneOfMatcher<{lesserArityGenericArg}> When(Func<T{parmIndex}, TResult> func)");
				using(var indent2 = new Indent(this))
				{
					WriteLine($"if (value is T{parmIndex}) result = func.Invoke((T{parmIndex})value);");
					WriteLine($"return new OneOfMatcher<{lesserArityGenericArg}>(this.value, this.result);");
				}
			}
			else
            {
				WriteLine($"public IOtherwiser<TResult> When(Func<T{parmIndex}, TResult> func)");
				using(var indent2 = new Indent(this))
				{
					WriteLine($"if (value is T{parmIndex}) result = func.Invoke((T{parmIndex})value);");
					WriteLine($"return this;");
				}
            }
		}

		// =============== Otherwise

		WriteLine("");
		WriteLine($"public IMatchResultGiver<TResult> Otherwise(Func<object, TResult> func)");
		using(var indent2 = new Indent(this))
		{
			WriteLine($"if (result == null) result = func.Invoke(value);");
			WriteLine("return this;");
		}

		// =============== OtherwiseThrow

		WriteLine("");
		WriteLine($"public IMatchResultGiver<TResult> OtherwiseThrow(Func<object, Exception> func)");
		using(var indent2 = new Indent(this))
		{
			WriteLine($"if (result == null) throw func.Invoke(value);");
			WriteLine("return this;");
		}

		// =============== Result

		WriteLine("");
		WriteLine($"public TResult Result");
		using(var indent2 = new Indent(this))
		{
			WriteLine($"get");
			using(var indent3 = new Indent(this))
			{
				WriteLine($"if (result == null) throw new InvalidOperationException();");
				WriteLine($"return (TResult)result;");
			}
		}
	}
}

class Indent: IDisposable
{
	GeneratedTextTransformation textTransformation;

	public Indent(GeneratedTextTransformation textTransformation)
	{
		this.textTransformation = textTransformation;

		textTransformation.WriteLine("{");
		textTransformation.PushIndent("    ");
	}

	public void Dispose()
	{
		textTransformation.PopIndent();
		textTransformation.WriteLine("}");
	}
}

#>
