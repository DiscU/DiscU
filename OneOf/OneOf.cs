// ===========================================================================
// Generated by OneOf.tt
// ===========================================================================

using System;
using Newtonsoft.Json;

namespace OneOf
{
    [JsonConverter(typeof(OneOfJsonConverter))]
    public struct OneOf<T0> : IOneOf
    {
        readonly object value;
        readonly int index;

        OneOf(object value, int index) { this.value = value; this.index = index; }

        object IOneOf.Value => value;

        T Get<T>(int index)
        {
            if (index != this.index)
            {
                throw new InvalidOperationException($"Cannot return as T{index} as result is T{this.index}");
            }
            return (T)value;
        }

        public bool IsT0 => index == 0;

        public bool Is<T>()
        {
            // quick path for when value non-null and correct type
            if (this.value is T) return true;

            // slower path for when value null, or wrong type
            if (IsT0 && typeof(T) == typeof(T0)) return true;

            return false;
        }

        public T0 AsT0 => Get<T0>(0);

        public T As<T>()
        {
            // quick path for when value non-null and correct type
            if (this.value is T) return (T)this.value;

            // slower path for when value null, or wrong type
            if (IsT0 && typeof(T) == typeof(T0)) return (T)value;

            throw new InvalidOperationException();
        }

        public static implicit operator OneOf<T0>(T0 t) => new OneOf<T0>(t, 0);

        public void Switch(Action<T0> f0 = null, Action otherwise = null)
        {
            if (this.IsT0 && f0 != null) { f0(this.AsT0); return; }

            if (otherwise != null) { otherwise(); return; }

            throw new InvalidOperationException();
        }

        public TResult Match<TResult>(Func<T0, TResult> f0 = null, Func<TResult> otherwise = null)
        {
            if (this.IsT0 && f0 != null) return f0(this.AsT0);

            if (otherwise != null) return otherwise();

            throw new InvalidOperationException();
        }

        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            if (!(obj is OneOf<T0>)) return false;

            var other = (OneOf<T0>)obj;
            return index == other.index && Equals(value, other.value);
        }

        public override int GetHashCode() => unchecked((value?.GetHashCode() ?? 0) * 397 ^ index);

        public override string ToString() => (value?.ToString() ?? "");
    }

    [JsonConverter(typeof(OneOfJsonConverter))]
    public struct OneOf<T0, T1> : IOneOf
    {
        readonly object value;
        readonly int index;

        OneOf(object value, int index) { this.value = value; this.index = index; }

        object IOneOf.Value => value;

        T Get<T>(int index)
        {
            if (index != this.index)
            {
                throw new InvalidOperationException($"Cannot return as T{index} as result is T{this.index}");
            }
            return (T)value;
        }

        public bool IsT0 => index == 0;
        public bool IsT1 => index == 1;

        public bool Is<T>()
        {
            // quick path for when value non-null and correct type
            if (this.value is T) return true;

            // slower path for when value null, or wrong type
            if (IsT0 && typeof(T) == typeof(T0)) return true;
            if (IsT1 && typeof(T) == typeof(T1)) return true;

            return false;
        }

        public T0 AsT0 => Get<T0>(0);
        public T1 AsT1 => Get<T1>(1);

        public T As<T>()
        {
            // quick path for when value non-null and correct type
            if (this.value is T) return (T)this.value;

            // slower path for when value null, or wrong type
            if (IsT0 && typeof(T) == typeof(T0)) return (T)value;
            if (IsT1 && typeof(T) == typeof(T1)) return (T)value;

            throw new InvalidOperationException();
        }

        public static implicit operator OneOf<T0, T1>(T0 t) => new OneOf<T0, T1>(t, 0);
        public static implicit operator OneOf<T0, T1>(T1 t) => new OneOf<T0, T1>(t, 1);

        public void Switch(Action<T0> f0 = null, Action<T1> f1 = null, Action otherwise = null)
        {
            if (this.IsT0 && f0 != null) { f0(this.AsT0); return; }
            if (this.IsT1 && f1 != null) { f1(this.AsT1); return; }

            if (otherwise != null) { otherwise(); return; }

            throw new InvalidOperationException();
        }

        public TResult Match<TResult>(Func<T0, TResult> f0 = null, Func<T1, TResult> f1 = null, Func<TResult> otherwise = null)
        {
            if (this.IsT0 && f0 != null) return f0(this.AsT0);
            if (this.IsT1 && f1 != null) return f1(this.AsT1);

            if (otherwise != null) return otherwise();

            throw new InvalidOperationException();
        }

        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            if (!(obj is OneOf<T0, T1>)) return false;

            var other = (OneOf<T0, T1>)obj;
            return index == other.index && Equals(value, other.value);
        }

        public override int GetHashCode() => unchecked((value?.GetHashCode() ?? 0) * 397 ^ index);

        public override string ToString() => (value?.ToString() ?? "");
    }

    [JsonConverter(typeof(OneOfJsonConverter))]
    public struct OneOf<T0, T1, T2> : IOneOf
    {
        readonly object value;
        readonly int index;

        OneOf(object value, int index) { this.value = value; this.index = index; }

        object IOneOf.Value => value;

        T Get<T>(int index)
        {
            if (index != this.index)
            {
                throw new InvalidOperationException($"Cannot return as T{index} as result is T{this.index}");
            }
            return (T)value;
        }

        public bool IsT0 => index == 0;
        public bool IsT1 => index == 1;
        public bool IsT2 => index == 2;

        public bool Is<T>()
        {
            // quick path for when value non-null and correct type
            if (this.value is T) return true;

            // slower path for when value null, or wrong type
            if (IsT0 && typeof(T) == typeof(T0)) return true;
            if (IsT1 && typeof(T) == typeof(T1)) return true;
            if (IsT2 && typeof(T) == typeof(T2)) return true;

            return false;
        }

        public T0 AsT0 => Get<T0>(0);
        public T1 AsT1 => Get<T1>(1);
        public T2 AsT2 => Get<T2>(2);

        public T As<T>()
        {
            // quick path for when value non-null and correct type
            if (this.value is T) return (T)this.value;

            // slower path for when value null, or wrong type
            if (IsT0 && typeof(T) == typeof(T0)) return (T)value;
            if (IsT1 && typeof(T) == typeof(T1)) return (T)value;
            if (IsT2 && typeof(T) == typeof(T2)) return (T)value;

            throw new InvalidOperationException();
        }

        public static implicit operator OneOf<T0, T1, T2>(T0 t) => new OneOf<T0, T1, T2>(t, 0);
        public static implicit operator OneOf<T0, T1, T2>(T1 t) => new OneOf<T0, T1, T2>(t, 1);
        public static implicit operator OneOf<T0, T1, T2>(T2 t) => new OneOf<T0, T1, T2>(t, 2);

        public void Switch(Action<T0> f0 = null, Action<T1> f1 = null, Action<T2> f2 = null, Action otherwise = null)
        {
            if (this.IsT0 && f0 != null) { f0(this.AsT0); return; }
            if (this.IsT1 && f1 != null) { f1(this.AsT1); return; }
            if (this.IsT2 && f2 != null) { f2(this.AsT2); return; }

            if (otherwise != null) { otherwise(); return; }

            throw new InvalidOperationException();
        }

        public TResult Match<TResult>(Func<T0, TResult> f0 = null, Func<T1, TResult> f1 = null, Func<T2, TResult> f2 = null, Func<TResult> otherwise = null)
        {
            if (this.IsT0 && f0 != null) return f0(this.AsT0);
            if (this.IsT1 && f1 != null) return f1(this.AsT1);
            if (this.IsT2 && f2 != null) return f2(this.AsT2);

            if (otherwise != null) return otherwise();

            throw new InvalidOperationException();
        }

        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            if (!(obj is OneOf<T0, T1, T2>)) return false;

            var other = (OneOf<T0, T1, T2>)obj;
            return index == other.index && Equals(value, other.value);
        }

        public override int GetHashCode() => unchecked((value?.GetHashCode() ?? 0) * 397 ^ index);

        public override string ToString() => (value?.ToString() ?? "");
    }

    [JsonConverter(typeof(OneOfJsonConverter))]
    public struct OneOf<T0, T1, T2, T3> : IOneOf
    {
        readonly object value;
        readonly int index;

        OneOf(object value, int index) { this.value = value; this.index = index; }

        object IOneOf.Value => value;

        T Get<T>(int index)
        {
            if (index != this.index)
            {
                throw new InvalidOperationException($"Cannot return as T{index} as result is T{this.index}");
            }
            return (T)value;
        }

        public bool IsT0 => index == 0;
        public bool IsT1 => index == 1;
        public bool IsT2 => index == 2;
        public bool IsT3 => index == 3;

        public bool Is<T>()
        {
            // quick path for when value non-null and correct type
            if (this.value is T) return true;

            // slower path for when value null, or wrong type
            if (IsT0 && typeof(T) == typeof(T0)) return true;
            if (IsT1 && typeof(T) == typeof(T1)) return true;
            if (IsT2 && typeof(T) == typeof(T2)) return true;
            if (IsT3 && typeof(T) == typeof(T3)) return true;

            return false;
        }

        public T0 AsT0 => Get<T0>(0);
        public T1 AsT1 => Get<T1>(1);
        public T2 AsT2 => Get<T2>(2);
        public T3 AsT3 => Get<T3>(3);

        public T As<T>()
        {
            // quick path for when value non-null and correct type
            if (this.value is T) return (T)this.value;

            // slower path for when value null, or wrong type
            if (IsT0 && typeof(T) == typeof(T0)) return (T)value;
            if (IsT1 && typeof(T) == typeof(T1)) return (T)value;
            if (IsT2 && typeof(T) == typeof(T2)) return (T)value;
            if (IsT3 && typeof(T) == typeof(T3)) return (T)value;

            throw new InvalidOperationException();
        }

        public static implicit operator OneOf<T0, T1, T2, T3>(T0 t) => new OneOf<T0, T1, T2, T3>(t, 0);
        public static implicit operator OneOf<T0, T1, T2, T3>(T1 t) => new OneOf<T0, T1, T2, T3>(t, 1);
        public static implicit operator OneOf<T0, T1, T2, T3>(T2 t) => new OneOf<T0, T1, T2, T3>(t, 2);
        public static implicit operator OneOf<T0, T1, T2, T3>(T3 t) => new OneOf<T0, T1, T2, T3>(t, 3);

        public void Switch(Action<T0> f0 = null, Action<T1> f1 = null, Action<T2> f2 = null, Action<T3> f3 = null, Action otherwise = null)
        {
            if (this.IsT0 && f0 != null) { f0(this.AsT0); return; }
            if (this.IsT1 && f1 != null) { f1(this.AsT1); return; }
            if (this.IsT2 && f2 != null) { f2(this.AsT2); return; }
            if (this.IsT3 && f3 != null) { f3(this.AsT3); return; }

            if (otherwise != null) { otherwise(); return; }

            throw new InvalidOperationException();
        }

        public TResult Match<TResult>(Func<T0, TResult> f0 = null, Func<T1, TResult> f1 = null, Func<T2, TResult> f2 = null, Func<T3, TResult> f3 = null, Func<TResult> otherwise = null)
        {
            if (this.IsT0 && f0 != null) return f0(this.AsT0);
            if (this.IsT1 && f1 != null) return f1(this.AsT1);
            if (this.IsT2 && f2 != null) return f2(this.AsT2);
            if (this.IsT3 && f3 != null) return f3(this.AsT3);

            if (otherwise != null) return otherwise();

            throw new InvalidOperationException();
        }

        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            if (!(obj is OneOf<T0, T1, T2, T3>)) return false;

            var other = (OneOf<T0, T1, T2, T3>)obj;
            return index == other.index && Equals(value, other.value);
        }

        public override int GetHashCode() => unchecked((value?.GetHashCode() ?? 0) * 397 ^ index);

        public override string ToString() => (value?.ToString() ?? "");
    }

    [JsonConverter(typeof(OneOfJsonConverter))]
    public struct OneOf<T0, T1, T2, T3, T4> : IOneOf
    {
        readonly object value;
        readonly int index;

        OneOf(object value, int index) { this.value = value; this.index = index; }

        object IOneOf.Value => value;

        T Get<T>(int index)
        {
            if (index != this.index)
            {
                throw new InvalidOperationException($"Cannot return as T{index} as result is T{this.index}");
            }
            return (T)value;
        }

        public bool IsT0 => index == 0;
        public bool IsT1 => index == 1;
        public bool IsT2 => index == 2;
        public bool IsT3 => index == 3;
        public bool IsT4 => index == 4;

        public bool Is<T>()
        {
            // quick path for when value non-null and correct type
            if (this.value is T) return true;

            // slower path for when value null, or wrong type
            if (IsT0 && typeof(T) == typeof(T0)) return true;
            if (IsT1 && typeof(T) == typeof(T1)) return true;
            if (IsT2 && typeof(T) == typeof(T2)) return true;
            if (IsT3 && typeof(T) == typeof(T3)) return true;
            if (IsT4 && typeof(T) == typeof(T4)) return true;

            return false;
        }

        public T0 AsT0 => Get<T0>(0);
        public T1 AsT1 => Get<T1>(1);
        public T2 AsT2 => Get<T2>(2);
        public T3 AsT3 => Get<T3>(3);
        public T4 AsT4 => Get<T4>(4);

        public T As<T>()
        {
            // quick path for when value non-null and correct type
            if (this.value is T) return (T)this.value;

            // slower path for when value null, or wrong type
            if (IsT0 && typeof(T) == typeof(T0)) return (T)value;
            if (IsT1 && typeof(T) == typeof(T1)) return (T)value;
            if (IsT2 && typeof(T) == typeof(T2)) return (T)value;
            if (IsT3 && typeof(T) == typeof(T3)) return (T)value;
            if (IsT4 && typeof(T) == typeof(T4)) return (T)value;

            throw new InvalidOperationException();
        }

        public static implicit operator OneOf<T0, T1, T2, T3, T4>(T0 t) => new OneOf<T0, T1, T2, T3, T4>(t, 0);
        public static implicit operator OneOf<T0, T1, T2, T3, T4>(T1 t) => new OneOf<T0, T1, T2, T3, T4>(t, 1);
        public static implicit operator OneOf<T0, T1, T2, T3, T4>(T2 t) => new OneOf<T0, T1, T2, T3, T4>(t, 2);
        public static implicit operator OneOf<T0, T1, T2, T3, T4>(T3 t) => new OneOf<T0, T1, T2, T3, T4>(t, 3);
        public static implicit operator OneOf<T0, T1, T2, T3, T4>(T4 t) => new OneOf<T0, T1, T2, T3, T4>(t, 4);

        public void Switch(Action<T0> f0 = null, Action<T1> f1 = null, Action<T2> f2 = null, Action<T3> f3 = null, Action<T4> f4 = null, Action otherwise = null)
        {
            if (this.IsT0 && f0 != null) { f0(this.AsT0); return; }
            if (this.IsT1 && f1 != null) { f1(this.AsT1); return; }
            if (this.IsT2 && f2 != null) { f2(this.AsT2); return; }
            if (this.IsT3 && f3 != null) { f3(this.AsT3); return; }
            if (this.IsT4 && f4 != null) { f4(this.AsT4); return; }

            if (otherwise != null) { otherwise(); return; }

            throw new InvalidOperationException();
        }

        public TResult Match<TResult>(Func<T0, TResult> f0 = null, Func<T1, TResult> f1 = null, Func<T2, TResult> f2 = null, Func<T3, TResult> f3 = null, Func<T4, TResult> f4 = null, Func<TResult> otherwise = null)
        {
            if (this.IsT0 && f0 != null) return f0(this.AsT0);
            if (this.IsT1 && f1 != null) return f1(this.AsT1);
            if (this.IsT2 && f2 != null) return f2(this.AsT2);
            if (this.IsT3 && f3 != null) return f3(this.AsT3);
            if (this.IsT4 && f4 != null) return f4(this.AsT4);

            if (otherwise != null) return otherwise();

            throw new InvalidOperationException();
        }

        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            if (!(obj is OneOf<T0, T1, T2, T3, T4>)) return false;

            var other = (OneOf<T0, T1, T2, T3, T4>)obj;
            return index == other.index && Equals(value, other.value);
        }

        public override int GetHashCode() => unchecked((value?.GetHashCode() ?? 0) * 397 ^ index);

        public override string ToString() => (value?.ToString() ?? "");
    }

    [JsonConverter(typeof(OneOfJsonConverter))]
    public struct OneOf<T0, T1, T2, T3, T4, T5> : IOneOf
    {
        readonly object value;
        readonly int index;

        OneOf(object value, int index) { this.value = value; this.index = index; }

        object IOneOf.Value => value;

        T Get<T>(int index)
        {
            if (index != this.index)
            {
                throw new InvalidOperationException($"Cannot return as T{index} as result is T{this.index}");
            }
            return (T)value;
        }

        public bool IsT0 => index == 0;
        public bool IsT1 => index == 1;
        public bool IsT2 => index == 2;
        public bool IsT3 => index == 3;
        public bool IsT4 => index == 4;
        public bool IsT5 => index == 5;

        public bool Is<T>()
        {
            // quick path for when value non-null and correct type
            if (this.value is T) return true;

            // slower path for when value null, or wrong type
            if (IsT0 && typeof(T) == typeof(T0)) return true;
            if (IsT1 && typeof(T) == typeof(T1)) return true;
            if (IsT2 && typeof(T) == typeof(T2)) return true;
            if (IsT3 && typeof(T) == typeof(T3)) return true;
            if (IsT4 && typeof(T) == typeof(T4)) return true;
            if (IsT5 && typeof(T) == typeof(T5)) return true;

            return false;
        }

        public T0 AsT0 => Get<T0>(0);
        public T1 AsT1 => Get<T1>(1);
        public T2 AsT2 => Get<T2>(2);
        public T3 AsT3 => Get<T3>(3);
        public T4 AsT4 => Get<T4>(4);
        public T5 AsT5 => Get<T5>(5);

        public T As<T>()
        {
            // quick path for when value non-null and correct type
            if (this.value is T) return (T)this.value;

            // slower path for when value null, or wrong type
            if (IsT0 && typeof(T) == typeof(T0)) return (T)value;
            if (IsT1 && typeof(T) == typeof(T1)) return (T)value;
            if (IsT2 && typeof(T) == typeof(T2)) return (T)value;
            if (IsT3 && typeof(T) == typeof(T3)) return (T)value;
            if (IsT4 && typeof(T) == typeof(T4)) return (T)value;
            if (IsT5 && typeof(T) == typeof(T5)) return (T)value;

            throw new InvalidOperationException();
        }

        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5>(T0 t) => new OneOf<T0, T1, T2, T3, T4, T5>(t, 0);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5>(T1 t) => new OneOf<T0, T1, T2, T3, T4, T5>(t, 1);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5>(T2 t) => new OneOf<T0, T1, T2, T3, T4, T5>(t, 2);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5>(T3 t) => new OneOf<T0, T1, T2, T3, T4, T5>(t, 3);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5>(T4 t) => new OneOf<T0, T1, T2, T3, T4, T5>(t, 4);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5>(T5 t) => new OneOf<T0, T1, T2, T3, T4, T5>(t, 5);

        public void Switch(Action<T0> f0 = null, Action<T1> f1 = null, Action<T2> f2 = null, Action<T3> f3 = null, Action<T4> f4 = null, Action<T5> f5 = null, Action otherwise = null)
        {
            if (this.IsT0 && f0 != null) { f0(this.AsT0); return; }
            if (this.IsT1 && f1 != null) { f1(this.AsT1); return; }
            if (this.IsT2 && f2 != null) { f2(this.AsT2); return; }
            if (this.IsT3 && f3 != null) { f3(this.AsT3); return; }
            if (this.IsT4 && f4 != null) { f4(this.AsT4); return; }
            if (this.IsT5 && f5 != null) { f5(this.AsT5); return; }

            if (otherwise != null) { otherwise(); return; }

            throw new InvalidOperationException();
        }

        public TResult Match<TResult>(Func<T0, TResult> f0 = null, Func<T1, TResult> f1 = null, Func<T2, TResult> f2 = null, Func<T3, TResult> f3 = null, Func<T4, TResult> f4 = null, Func<T5, TResult> f5 = null, Func<TResult> otherwise = null)
        {
            if (this.IsT0 && f0 != null) return f0(this.AsT0);
            if (this.IsT1 && f1 != null) return f1(this.AsT1);
            if (this.IsT2 && f2 != null) return f2(this.AsT2);
            if (this.IsT3 && f3 != null) return f3(this.AsT3);
            if (this.IsT4 && f4 != null) return f4(this.AsT4);
            if (this.IsT5 && f5 != null) return f5(this.AsT5);

            if (otherwise != null) return otherwise();

            throw new InvalidOperationException();
        }

        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            if (!(obj is OneOf<T0, T1, T2, T3, T4, T5>)) return false;

            var other = (OneOf<T0, T1, T2, T3, T4, T5>)obj;
            return index == other.index && Equals(value, other.value);
        }

        public override int GetHashCode() => unchecked((value?.GetHashCode() ?? 0) * 397 ^ index);

        public override string ToString() => (value?.ToString() ?? "");
    }

    [JsonConverter(typeof(OneOfJsonConverter))]
    public struct OneOf<T0, T1, T2, T3, T4, T5, T6> : IOneOf
    {
        readonly object value;
        readonly int index;

        OneOf(object value, int index) { this.value = value; this.index = index; }

        object IOneOf.Value => value;

        T Get<T>(int index)
        {
            if (index != this.index)
            {
                throw new InvalidOperationException($"Cannot return as T{index} as result is T{this.index}");
            }
            return (T)value;
        }

        public bool IsT0 => index == 0;
        public bool IsT1 => index == 1;
        public bool IsT2 => index == 2;
        public bool IsT3 => index == 3;
        public bool IsT4 => index == 4;
        public bool IsT5 => index == 5;
        public bool IsT6 => index == 6;

        public bool Is<T>()
        {
            // quick path for when value non-null and correct type
            if (this.value is T) return true;

            // slower path for when value null, or wrong type
            if (IsT0 && typeof(T) == typeof(T0)) return true;
            if (IsT1 && typeof(T) == typeof(T1)) return true;
            if (IsT2 && typeof(T) == typeof(T2)) return true;
            if (IsT3 && typeof(T) == typeof(T3)) return true;
            if (IsT4 && typeof(T) == typeof(T4)) return true;
            if (IsT5 && typeof(T) == typeof(T5)) return true;
            if (IsT6 && typeof(T) == typeof(T6)) return true;

            return false;
        }

        public T0 AsT0 => Get<T0>(0);
        public T1 AsT1 => Get<T1>(1);
        public T2 AsT2 => Get<T2>(2);
        public T3 AsT3 => Get<T3>(3);
        public T4 AsT4 => Get<T4>(4);
        public T5 AsT5 => Get<T5>(5);
        public T6 AsT6 => Get<T6>(6);

        public T As<T>()
        {
            // quick path for when value non-null and correct type
            if (this.value is T) return (T)this.value;

            // slower path for when value null, or wrong type
            if (IsT0 && typeof(T) == typeof(T0)) return (T)value;
            if (IsT1 && typeof(T) == typeof(T1)) return (T)value;
            if (IsT2 && typeof(T) == typeof(T2)) return (T)value;
            if (IsT3 && typeof(T) == typeof(T3)) return (T)value;
            if (IsT4 && typeof(T) == typeof(T4)) return (T)value;
            if (IsT5 && typeof(T) == typeof(T5)) return (T)value;
            if (IsT6 && typeof(T) == typeof(T6)) return (T)value;

            throw new InvalidOperationException();
        }

        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5, T6>(T0 t) => new OneOf<T0, T1, T2, T3, T4, T5, T6>(t, 0);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5, T6>(T1 t) => new OneOf<T0, T1, T2, T3, T4, T5, T6>(t, 1);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5, T6>(T2 t) => new OneOf<T0, T1, T2, T3, T4, T5, T6>(t, 2);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5, T6>(T3 t) => new OneOf<T0, T1, T2, T3, T4, T5, T6>(t, 3);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5, T6>(T4 t) => new OneOf<T0, T1, T2, T3, T4, T5, T6>(t, 4);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5, T6>(T5 t) => new OneOf<T0, T1, T2, T3, T4, T5, T6>(t, 5);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5, T6>(T6 t) => new OneOf<T0, T1, T2, T3, T4, T5, T6>(t, 6);

        public void Switch(Action<T0> f0 = null, Action<T1> f1 = null, Action<T2> f2 = null, Action<T3> f3 = null, Action<T4> f4 = null, Action<T5> f5 = null, Action<T6> f6 = null, Action otherwise = null)
        {
            if (this.IsT0 && f0 != null) { f0(this.AsT0); return; }
            if (this.IsT1 && f1 != null) { f1(this.AsT1); return; }
            if (this.IsT2 && f2 != null) { f2(this.AsT2); return; }
            if (this.IsT3 && f3 != null) { f3(this.AsT3); return; }
            if (this.IsT4 && f4 != null) { f4(this.AsT4); return; }
            if (this.IsT5 && f5 != null) { f5(this.AsT5); return; }
            if (this.IsT6 && f6 != null) { f6(this.AsT6); return; }

            if (otherwise != null) { otherwise(); return; }

            throw new InvalidOperationException();
        }

        public TResult Match<TResult>(Func<T0, TResult> f0 = null, Func<T1, TResult> f1 = null, Func<T2, TResult> f2 = null, Func<T3, TResult> f3 = null, Func<T4, TResult> f4 = null, Func<T5, TResult> f5 = null, Func<T6, TResult> f6 = null, Func<TResult> otherwise = null)
        {
            if (this.IsT0 && f0 != null) return f0(this.AsT0);
            if (this.IsT1 && f1 != null) return f1(this.AsT1);
            if (this.IsT2 && f2 != null) return f2(this.AsT2);
            if (this.IsT3 && f3 != null) return f3(this.AsT3);
            if (this.IsT4 && f4 != null) return f4(this.AsT4);
            if (this.IsT5 && f5 != null) return f5(this.AsT5);
            if (this.IsT6 && f6 != null) return f6(this.AsT6);

            if (otherwise != null) return otherwise();

            throw new InvalidOperationException();
        }

        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            if (!(obj is OneOf<T0, T1, T2, T3, T4, T5, T6>)) return false;

            var other = (OneOf<T0, T1, T2, T3, T4, T5, T6>)obj;
            return index == other.index && Equals(value, other.value);
        }

        public override int GetHashCode() => unchecked((value?.GetHashCode() ?? 0) * 397 ^ index);

        public override string ToString() => (value?.ToString() ?? "");
    }

    [JsonConverter(typeof(OneOfJsonConverter))]
    public struct OneOf<T0, T1, T2, T3, T4, T5, T6, T7> : IOneOf
    {
        readonly object value;
        readonly int index;

        OneOf(object value, int index) { this.value = value; this.index = index; }

        object IOneOf.Value => value;

        T Get<T>(int index)
        {
            if (index != this.index)
            {
                throw new InvalidOperationException($"Cannot return as T{index} as result is T{this.index}");
            }
            return (T)value;
        }

        public bool IsT0 => index == 0;
        public bool IsT1 => index == 1;
        public bool IsT2 => index == 2;
        public bool IsT3 => index == 3;
        public bool IsT4 => index == 4;
        public bool IsT5 => index == 5;
        public bool IsT6 => index == 6;
        public bool IsT7 => index == 7;

        public bool Is<T>()
        {
            // quick path for when value non-null and correct type
            if (this.value is T) return true;

            // slower path for when value null, or wrong type
            if (IsT0 && typeof(T) == typeof(T0)) return true;
            if (IsT1 && typeof(T) == typeof(T1)) return true;
            if (IsT2 && typeof(T) == typeof(T2)) return true;
            if (IsT3 && typeof(T) == typeof(T3)) return true;
            if (IsT4 && typeof(T) == typeof(T4)) return true;
            if (IsT5 && typeof(T) == typeof(T5)) return true;
            if (IsT6 && typeof(T) == typeof(T6)) return true;
            if (IsT7 && typeof(T) == typeof(T7)) return true;

            return false;
        }

        public T0 AsT0 => Get<T0>(0);
        public T1 AsT1 => Get<T1>(1);
        public T2 AsT2 => Get<T2>(2);
        public T3 AsT3 => Get<T3>(3);
        public T4 AsT4 => Get<T4>(4);
        public T5 AsT5 => Get<T5>(5);
        public T6 AsT6 => Get<T6>(6);
        public T7 AsT7 => Get<T7>(7);

        public T As<T>()
        {
            // quick path for when value non-null and correct type
            if (this.value is T) return (T)this.value;

            // slower path for when value null, or wrong type
            if (IsT0 && typeof(T) == typeof(T0)) return (T)value;
            if (IsT1 && typeof(T) == typeof(T1)) return (T)value;
            if (IsT2 && typeof(T) == typeof(T2)) return (T)value;
            if (IsT3 && typeof(T) == typeof(T3)) return (T)value;
            if (IsT4 && typeof(T) == typeof(T4)) return (T)value;
            if (IsT5 && typeof(T) == typeof(T5)) return (T)value;
            if (IsT6 && typeof(T) == typeof(T6)) return (T)value;
            if (IsT7 && typeof(T) == typeof(T7)) return (T)value;

            throw new InvalidOperationException();
        }

        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5, T6, T7>(T0 t) => new OneOf<T0, T1, T2, T3, T4, T5, T6, T7>(t, 0);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5, T6, T7>(T1 t) => new OneOf<T0, T1, T2, T3, T4, T5, T6, T7>(t, 1);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5, T6, T7>(T2 t) => new OneOf<T0, T1, T2, T3, T4, T5, T6, T7>(t, 2);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5, T6, T7>(T3 t) => new OneOf<T0, T1, T2, T3, T4, T5, T6, T7>(t, 3);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5, T6, T7>(T4 t) => new OneOf<T0, T1, T2, T3, T4, T5, T6, T7>(t, 4);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5, T6, T7>(T5 t) => new OneOf<T0, T1, T2, T3, T4, T5, T6, T7>(t, 5);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5, T6, T7>(T6 t) => new OneOf<T0, T1, T2, T3, T4, T5, T6, T7>(t, 6);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5, T6, T7>(T7 t) => new OneOf<T0, T1, T2, T3, T4, T5, T6, T7>(t, 7);

        public void Switch(Action<T0> f0 = null, Action<T1> f1 = null, Action<T2> f2 = null, Action<T3> f3 = null, Action<T4> f4 = null, Action<T5> f5 = null, Action<T6> f6 = null, Action<T7> f7 = null, Action otherwise = null)
        {
            if (this.IsT0 && f0 != null) { f0(this.AsT0); return; }
            if (this.IsT1 && f1 != null) { f1(this.AsT1); return; }
            if (this.IsT2 && f2 != null) { f2(this.AsT2); return; }
            if (this.IsT3 && f3 != null) { f3(this.AsT3); return; }
            if (this.IsT4 && f4 != null) { f4(this.AsT4); return; }
            if (this.IsT5 && f5 != null) { f5(this.AsT5); return; }
            if (this.IsT6 && f6 != null) { f6(this.AsT6); return; }
            if (this.IsT7 && f7 != null) { f7(this.AsT7); return; }

            if (otherwise != null) { otherwise(); return; }

            throw new InvalidOperationException();
        }

        public TResult Match<TResult>(Func<T0, TResult> f0 = null, Func<T1, TResult> f1 = null, Func<T2, TResult> f2 = null, Func<T3, TResult> f3 = null, Func<T4, TResult> f4 = null, Func<T5, TResult> f5 = null, Func<T6, TResult> f6 = null, Func<T7, TResult> f7 = null, Func<TResult> otherwise = null)
        {
            if (this.IsT0 && f0 != null) return f0(this.AsT0);
            if (this.IsT1 && f1 != null) return f1(this.AsT1);
            if (this.IsT2 && f2 != null) return f2(this.AsT2);
            if (this.IsT3 && f3 != null) return f3(this.AsT3);
            if (this.IsT4 && f4 != null) return f4(this.AsT4);
            if (this.IsT5 && f5 != null) return f5(this.AsT5);
            if (this.IsT6 && f6 != null) return f6(this.AsT6);
            if (this.IsT7 && f7 != null) return f7(this.AsT7);

            if (otherwise != null) return otherwise();

            throw new InvalidOperationException();
        }

        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            if (!(obj is OneOf<T0, T1, T2, T3, T4, T5, T6, T7>)) return false;

            var other = (OneOf<T0, T1, T2, T3, T4, T5, T6, T7>)obj;
            return index == other.index && Equals(value, other.value);
        }

        public override int GetHashCode() => unchecked((value?.GetHashCode() ?? 0) * 397 ^ index);

        public override string ToString() => (value?.ToString() ?? "");
    }

    [JsonConverter(typeof(OneOfJsonConverter))]
    public struct OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8> : IOneOf
    {
        readonly object value;
        readonly int index;

        OneOf(object value, int index) { this.value = value; this.index = index; }

        object IOneOf.Value => value;

        T Get<T>(int index)
        {
            if (index != this.index)
            {
                throw new InvalidOperationException($"Cannot return as T{index} as result is T{this.index}");
            }
            return (T)value;
        }

        public bool IsT0 => index == 0;
        public bool IsT1 => index == 1;
        public bool IsT2 => index == 2;
        public bool IsT3 => index == 3;
        public bool IsT4 => index == 4;
        public bool IsT5 => index == 5;
        public bool IsT6 => index == 6;
        public bool IsT7 => index == 7;
        public bool IsT8 => index == 8;

        public bool Is<T>()
        {
            // quick path for when value non-null and correct type
            if (this.value is T) return true;

            // slower path for when value null, or wrong type
            if (IsT0 && typeof(T) == typeof(T0)) return true;
            if (IsT1 && typeof(T) == typeof(T1)) return true;
            if (IsT2 && typeof(T) == typeof(T2)) return true;
            if (IsT3 && typeof(T) == typeof(T3)) return true;
            if (IsT4 && typeof(T) == typeof(T4)) return true;
            if (IsT5 && typeof(T) == typeof(T5)) return true;
            if (IsT6 && typeof(T) == typeof(T6)) return true;
            if (IsT7 && typeof(T) == typeof(T7)) return true;
            if (IsT8 && typeof(T) == typeof(T8)) return true;

            return false;
        }

        public T0 AsT0 => Get<T0>(0);
        public T1 AsT1 => Get<T1>(1);
        public T2 AsT2 => Get<T2>(2);
        public T3 AsT3 => Get<T3>(3);
        public T4 AsT4 => Get<T4>(4);
        public T5 AsT5 => Get<T5>(5);
        public T6 AsT6 => Get<T6>(6);
        public T7 AsT7 => Get<T7>(7);
        public T8 AsT8 => Get<T8>(8);

        public T As<T>()
        {
            // quick path for when value non-null and correct type
            if (this.value is T) return (T)this.value;

            // slower path for when value null, or wrong type
            if (IsT0 && typeof(T) == typeof(T0)) return (T)value;
            if (IsT1 && typeof(T) == typeof(T1)) return (T)value;
            if (IsT2 && typeof(T) == typeof(T2)) return (T)value;
            if (IsT3 && typeof(T) == typeof(T3)) return (T)value;
            if (IsT4 && typeof(T) == typeof(T4)) return (T)value;
            if (IsT5 && typeof(T) == typeof(T5)) return (T)value;
            if (IsT6 && typeof(T) == typeof(T6)) return (T)value;
            if (IsT7 && typeof(T) == typeof(T7)) return (T)value;
            if (IsT8 && typeof(T) == typeof(T8)) return (T)value;

            throw new InvalidOperationException();
        }

        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8>(T0 t) => new OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8>(t, 0);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8>(T1 t) => new OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8>(t, 1);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8>(T2 t) => new OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8>(t, 2);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8>(T3 t) => new OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8>(t, 3);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8>(T4 t) => new OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8>(t, 4);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8>(T5 t) => new OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8>(t, 5);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8>(T6 t) => new OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8>(t, 6);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8>(T7 t) => new OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8>(t, 7);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8>(T8 t) => new OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8>(t, 8);

        public void Switch(Action<T0> f0 = null, Action<T1> f1 = null, Action<T2> f2 = null, Action<T3> f3 = null, Action<T4> f4 = null, Action<T5> f5 = null, Action<T6> f6 = null, Action<T7> f7 = null, Action<T8> f8 = null, Action otherwise = null)
        {
            if (this.IsT0 && f0 != null) { f0(this.AsT0); return; }
            if (this.IsT1 && f1 != null) { f1(this.AsT1); return; }
            if (this.IsT2 && f2 != null) { f2(this.AsT2); return; }
            if (this.IsT3 && f3 != null) { f3(this.AsT3); return; }
            if (this.IsT4 && f4 != null) { f4(this.AsT4); return; }
            if (this.IsT5 && f5 != null) { f5(this.AsT5); return; }
            if (this.IsT6 && f6 != null) { f6(this.AsT6); return; }
            if (this.IsT7 && f7 != null) { f7(this.AsT7); return; }
            if (this.IsT8 && f8 != null) { f8(this.AsT8); return; }

            if (otherwise != null) { otherwise(); return; }

            throw new InvalidOperationException();
        }

        public TResult Match<TResult>(Func<T0, TResult> f0 = null, Func<T1, TResult> f1 = null, Func<T2, TResult> f2 = null, Func<T3, TResult> f3 = null, Func<T4, TResult> f4 = null, Func<T5, TResult> f5 = null, Func<T6, TResult> f6 = null, Func<T7, TResult> f7 = null, Func<T8, TResult> f8 = null, Func<TResult> otherwise = null)
        {
            if (this.IsT0 && f0 != null) return f0(this.AsT0);
            if (this.IsT1 && f1 != null) return f1(this.AsT1);
            if (this.IsT2 && f2 != null) return f2(this.AsT2);
            if (this.IsT3 && f3 != null) return f3(this.AsT3);
            if (this.IsT4 && f4 != null) return f4(this.AsT4);
            if (this.IsT5 && f5 != null) return f5(this.AsT5);
            if (this.IsT6 && f6 != null) return f6(this.AsT6);
            if (this.IsT7 && f7 != null) return f7(this.AsT7);
            if (this.IsT8 && f8 != null) return f8(this.AsT8);

            if (otherwise != null) return otherwise();

            throw new InvalidOperationException();
        }

        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            if (!(obj is OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8>)) return false;

            var other = (OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8>)obj;
            return index == other.index && Equals(value, other.value);
        }

        public override int GetHashCode() => unchecked((value?.GetHashCode() ?? 0) * 397 ^ index);

        public override string ToString() => (value?.ToString() ?? "");
    }

    [JsonConverter(typeof(OneOfJsonConverter))]
    public class OneOfBase<T0> : IOneOf
    {
        readonly object value;
        readonly int index;

        OneOfBase(object value, int index) { this.value = value; this.index = index; }

        protected OneOfBase()
        {
            this.value = this;

            if (this is T0) this.index = 0;
        }

        object IOneOf.Value => value;

        T Get<T>(int index)
        {
            if (index != this.index)
            {
                throw new InvalidOperationException($"Cannot return as T{index} as result is T{this.index}");
            }
            return (T)value;
        }

        public bool IsT0 => index == 0;

        public bool Is<T>()
        {
            // quick path for when value non-null and correct type
            if (this.value is T) return true;

            // slower path for when value null, or wrong type
            if (IsT0 && typeof(T) == typeof(T0)) return true;

            return false;
        }

        public T0 AsT0 => Get<T0>(0);

        public T As<T>()
        {
            // quick path for when value non-null and correct type
            if (this.value is T) return (T)this.value;

            // slower path for when value null, or wrong type
            if (IsT0 && typeof(T) == typeof(T0)) return (T)value;

            throw new InvalidOperationException();
        }

        public static implicit operator OneOfBase<T0>(T0 t) => new OneOfBase<T0>(t, 0);

        public void Switch(Action<T0> f0 = null, Action otherwise = null)
        {
            if (this.IsT0 && f0 != null) { f0(this.AsT0); return; }

            if (otherwise != null) { otherwise(); return; }

            throw new InvalidOperationException();
        }

        public TResult Match<TResult>(Func<T0, TResult> f0 = null, Func<TResult> otherwise = null)
        {
            if (this.IsT0 && f0 != null) return f0(this.AsT0);

            if (otherwise != null) return otherwise();

            throw new InvalidOperationException();
        }

        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            if (!(obj is OneOfBase<T0>)) return false;

            var other = (OneOfBase<T0>)obj;
            return index == other.index && Equals(value, other.value);
        }

        public override int GetHashCode() => unchecked((value?.GetHashCode() ?? 0) * 397 ^ index);

        public override string ToString() => (value?.ToString() ?? "");
    }

    [JsonConverter(typeof(OneOfJsonConverter))]
    public class OneOfBase<T0, T1> : IOneOf
    {
        readonly object value;
        readonly int index;

        OneOfBase(object value, int index) { this.value = value; this.index = index; }

        protected OneOfBase()
        {
            this.value = this;

            if (this is T0) this.index = 0;
            if (this is T1) this.index = 1;
        }

        object IOneOf.Value => value;

        T Get<T>(int index)
        {
            if (index != this.index)
            {
                throw new InvalidOperationException($"Cannot return as T{index} as result is T{this.index}");
            }
            return (T)value;
        }

        public bool IsT0 => index == 0;
        public bool IsT1 => index == 1;

        public bool Is<T>()
        {
            // quick path for when value non-null and correct type
            if (this.value is T) return true;

            // slower path for when value null, or wrong type
            if (IsT0 && typeof(T) == typeof(T0)) return true;
            if (IsT1 && typeof(T) == typeof(T1)) return true;

            return false;
        }

        public T0 AsT0 => Get<T0>(0);
        public T1 AsT1 => Get<T1>(1);

        public T As<T>()
        {
            // quick path for when value non-null and correct type
            if (this.value is T) return (T)this.value;

            // slower path for when value null, or wrong type
            if (IsT0 && typeof(T) == typeof(T0)) return (T)value;
            if (IsT1 && typeof(T) == typeof(T1)) return (T)value;

            throw new InvalidOperationException();
        }

        public static implicit operator OneOfBase<T0, T1>(T0 t) => new OneOfBase<T0, T1>(t, 0);
        public static implicit operator OneOfBase<T0, T1>(T1 t) => new OneOfBase<T0, T1>(t, 1);

        public void Switch(Action<T0> f0 = null, Action<T1> f1 = null, Action otherwise = null)
        {
            if (this.IsT0 && f0 != null) { f0(this.AsT0); return; }
            if (this.IsT1 && f1 != null) { f1(this.AsT1); return; }

            if (otherwise != null) { otherwise(); return; }

            throw new InvalidOperationException();
        }

        public TResult Match<TResult>(Func<T0, TResult> f0 = null, Func<T1, TResult> f1 = null, Func<TResult> otherwise = null)
        {
            if (this.IsT0 && f0 != null) return f0(this.AsT0);
            if (this.IsT1 && f1 != null) return f1(this.AsT1);

            if (otherwise != null) return otherwise();

            throw new InvalidOperationException();
        }

        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            if (!(obj is OneOfBase<T0, T1>)) return false;

            var other = (OneOfBase<T0, T1>)obj;
            return index == other.index && Equals(value, other.value);
        }

        public override int GetHashCode() => unchecked((value?.GetHashCode() ?? 0) * 397 ^ index);

        public override string ToString() => (value?.ToString() ?? "");
    }

    [JsonConverter(typeof(OneOfJsonConverter))]
    public class OneOfBase<T0, T1, T2> : IOneOf
    {
        readonly object value;
        readonly int index;

        OneOfBase(object value, int index) { this.value = value; this.index = index; }

        protected OneOfBase()
        {
            this.value = this;

            if (this is T0) this.index = 0;
            if (this is T1) this.index = 1;
            if (this is T2) this.index = 2;
        }

        object IOneOf.Value => value;

        T Get<T>(int index)
        {
            if (index != this.index)
            {
                throw new InvalidOperationException($"Cannot return as T{index} as result is T{this.index}");
            }
            return (T)value;
        }

        public bool IsT0 => index == 0;
        public bool IsT1 => index == 1;
        public bool IsT2 => index == 2;

        public bool Is<T>()
        {
            // quick path for when value non-null and correct type
            if (this.value is T) return true;

            // slower path for when value null, or wrong type
            if (IsT0 && typeof(T) == typeof(T0)) return true;
            if (IsT1 && typeof(T) == typeof(T1)) return true;
            if (IsT2 && typeof(T) == typeof(T2)) return true;

            return false;
        }

        public T0 AsT0 => Get<T0>(0);
        public T1 AsT1 => Get<T1>(1);
        public T2 AsT2 => Get<T2>(2);

        public T As<T>()
        {
            // quick path for when value non-null and correct type
            if (this.value is T) return (T)this.value;

            // slower path for when value null, or wrong type
            if (IsT0 && typeof(T) == typeof(T0)) return (T)value;
            if (IsT1 && typeof(T) == typeof(T1)) return (T)value;
            if (IsT2 && typeof(T) == typeof(T2)) return (T)value;

            throw new InvalidOperationException();
        }

        public static implicit operator OneOfBase<T0, T1, T2>(T0 t) => new OneOfBase<T0, T1, T2>(t, 0);
        public static implicit operator OneOfBase<T0, T1, T2>(T1 t) => new OneOfBase<T0, T1, T2>(t, 1);
        public static implicit operator OneOfBase<T0, T1, T2>(T2 t) => new OneOfBase<T0, T1, T2>(t, 2);

        public void Switch(Action<T0> f0 = null, Action<T1> f1 = null, Action<T2> f2 = null, Action otherwise = null)
        {
            if (this.IsT0 && f0 != null) { f0(this.AsT0); return; }
            if (this.IsT1 && f1 != null) { f1(this.AsT1); return; }
            if (this.IsT2 && f2 != null) { f2(this.AsT2); return; }

            if (otherwise != null) { otherwise(); return; }

            throw new InvalidOperationException();
        }

        public TResult Match<TResult>(Func<T0, TResult> f0 = null, Func<T1, TResult> f1 = null, Func<T2, TResult> f2 = null, Func<TResult> otherwise = null)
        {
            if (this.IsT0 && f0 != null) return f0(this.AsT0);
            if (this.IsT1 && f1 != null) return f1(this.AsT1);
            if (this.IsT2 && f2 != null) return f2(this.AsT2);

            if (otherwise != null) return otherwise();

            throw new InvalidOperationException();
        }

        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            if (!(obj is OneOfBase<T0, T1, T2>)) return false;

            var other = (OneOfBase<T0, T1, T2>)obj;
            return index == other.index && Equals(value, other.value);
        }

        public override int GetHashCode() => unchecked((value?.GetHashCode() ?? 0) * 397 ^ index);

        public override string ToString() => (value?.ToString() ?? "");
    }

    [JsonConverter(typeof(OneOfJsonConverter))]
    public class OneOfBase<T0, T1, T2, T3> : IOneOf
    {
        readonly object value;
        readonly int index;

        OneOfBase(object value, int index) { this.value = value; this.index = index; }

        protected OneOfBase()
        {
            this.value = this;

            if (this is T0) this.index = 0;
            if (this is T1) this.index = 1;
            if (this is T2) this.index = 2;
            if (this is T3) this.index = 3;
        }

        object IOneOf.Value => value;

        T Get<T>(int index)
        {
            if (index != this.index)
            {
                throw new InvalidOperationException($"Cannot return as T{index} as result is T{this.index}");
            }
            return (T)value;
        }

        public bool IsT0 => index == 0;
        public bool IsT1 => index == 1;
        public bool IsT2 => index == 2;
        public bool IsT3 => index == 3;

        public bool Is<T>()
        {
            // quick path for when value non-null and correct type
            if (this.value is T) return true;

            // slower path for when value null, or wrong type
            if (IsT0 && typeof(T) == typeof(T0)) return true;
            if (IsT1 && typeof(T) == typeof(T1)) return true;
            if (IsT2 && typeof(T) == typeof(T2)) return true;
            if (IsT3 && typeof(T) == typeof(T3)) return true;

            return false;
        }

        public T0 AsT0 => Get<T0>(0);
        public T1 AsT1 => Get<T1>(1);
        public T2 AsT2 => Get<T2>(2);
        public T3 AsT3 => Get<T3>(3);

        public T As<T>()
        {
            // quick path for when value non-null and correct type
            if (this.value is T) return (T)this.value;

            // slower path for when value null, or wrong type
            if (IsT0 && typeof(T) == typeof(T0)) return (T)value;
            if (IsT1 && typeof(T) == typeof(T1)) return (T)value;
            if (IsT2 && typeof(T) == typeof(T2)) return (T)value;
            if (IsT3 && typeof(T) == typeof(T3)) return (T)value;

            throw new InvalidOperationException();
        }

        public static implicit operator OneOfBase<T0, T1, T2, T3>(T0 t) => new OneOfBase<T0, T1, T2, T3>(t, 0);
        public static implicit operator OneOfBase<T0, T1, T2, T3>(T1 t) => new OneOfBase<T0, T1, T2, T3>(t, 1);
        public static implicit operator OneOfBase<T0, T1, T2, T3>(T2 t) => new OneOfBase<T0, T1, T2, T3>(t, 2);
        public static implicit operator OneOfBase<T0, T1, T2, T3>(T3 t) => new OneOfBase<T0, T1, T2, T3>(t, 3);

        public void Switch(Action<T0> f0 = null, Action<T1> f1 = null, Action<T2> f2 = null, Action<T3> f3 = null, Action otherwise = null)
        {
            if (this.IsT0 && f0 != null) { f0(this.AsT0); return; }
            if (this.IsT1 && f1 != null) { f1(this.AsT1); return; }
            if (this.IsT2 && f2 != null) { f2(this.AsT2); return; }
            if (this.IsT3 && f3 != null) { f3(this.AsT3); return; }

            if (otherwise != null) { otherwise(); return; }

            throw new InvalidOperationException();
        }

        public TResult Match<TResult>(Func<T0, TResult> f0 = null, Func<T1, TResult> f1 = null, Func<T2, TResult> f2 = null, Func<T3, TResult> f3 = null, Func<TResult> otherwise = null)
        {
            if (this.IsT0 && f0 != null) return f0(this.AsT0);
            if (this.IsT1 && f1 != null) return f1(this.AsT1);
            if (this.IsT2 && f2 != null) return f2(this.AsT2);
            if (this.IsT3 && f3 != null) return f3(this.AsT3);

            if (otherwise != null) return otherwise();

            throw new InvalidOperationException();
        }

        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            if (!(obj is OneOfBase<T0, T1, T2, T3>)) return false;

            var other = (OneOfBase<T0, T1, T2, T3>)obj;
            return index == other.index && Equals(value, other.value);
        }

        public override int GetHashCode() => unchecked((value?.GetHashCode() ?? 0) * 397 ^ index);

        public override string ToString() => (value?.ToString() ?? "");
    }

    [JsonConverter(typeof(OneOfJsonConverter))]
    public class OneOfBase<T0, T1, T2, T3, T4> : IOneOf
    {
        readonly object value;
        readonly int index;

        OneOfBase(object value, int index) { this.value = value; this.index = index; }

        protected OneOfBase()
        {
            this.value = this;

            if (this is T0) this.index = 0;
            if (this is T1) this.index = 1;
            if (this is T2) this.index = 2;
            if (this is T3) this.index = 3;
            if (this is T4) this.index = 4;
        }

        object IOneOf.Value => value;

        T Get<T>(int index)
        {
            if (index != this.index)
            {
                throw new InvalidOperationException($"Cannot return as T{index} as result is T{this.index}");
            }
            return (T)value;
        }

        public bool IsT0 => index == 0;
        public bool IsT1 => index == 1;
        public bool IsT2 => index == 2;
        public bool IsT3 => index == 3;
        public bool IsT4 => index == 4;

        public bool Is<T>()
        {
            // quick path for when value non-null and correct type
            if (this.value is T) return true;

            // slower path for when value null, or wrong type
            if (IsT0 && typeof(T) == typeof(T0)) return true;
            if (IsT1 && typeof(T) == typeof(T1)) return true;
            if (IsT2 && typeof(T) == typeof(T2)) return true;
            if (IsT3 && typeof(T) == typeof(T3)) return true;
            if (IsT4 && typeof(T) == typeof(T4)) return true;

            return false;
        }

        public T0 AsT0 => Get<T0>(0);
        public T1 AsT1 => Get<T1>(1);
        public T2 AsT2 => Get<T2>(2);
        public T3 AsT3 => Get<T3>(3);
        public T4 AsT4 => Get<T4>(4);

        public T As<T>()
        {
            // quick path for when value non-null and correct type
            if (this.value is T) return (T)this.value;

            // slower path for when value null, or wrong type
            if (IsT0 && typeof(T) == typeof(T0)) return (T)value;
            if (IsT1 && typeof(T) == typeof(T1)) return (T)value;
            if (IsT2 && typeof(T) == typeof(T2)) return (T)value;
            if (IsT3 && typeof(T) == typeof(T3)) return (T)value;
            if (IsT4 && typeof(T) == typeof(T4)) return (T)value;

            throw new InvalidOperationException();
        }

        public static implicit operator OneOfBase<T0, T1, T2, T3, T4>(T0 t) => new OneOfBase<T0, T1, T2, T3, T4>(t, 0);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4>(T1 t) => new OneOfBase<T0, T1, T2, T3, T4>(t, 1);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4>(T2 t) => new OneOfBase<T0, T1, T2, T3, T4>(t, 2);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4>(T3 t) => new OneOfBase<T0, T1, T2, T3, T4>(t, 3);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4>(T4 t) => new OneOfBase<T0, T1, T2, T3, T4>(t, 4);

        public void Switch(Action<T0> f0 = null, Action<T1> f1 = null, Action<T2> f2 = null, Action<T3> f3 = null, Action<T4> f4 = null, Action otherwise = null)
        {
            if (this.IsT0 && f0 != null) { f0(this.AsT0); return; }
            if (this.IsT1 && f1 != null) { f1(this.AsT1); return; }
            if (this.IsT2 && f2 != null) { f2(this.AsT2); return; }
            if (this.IsT3 && f3 != null) { f3(this.AsT3); return; }
            if (this.IsT4 && f4 != null) { f4(this.AsT4); return; }

            if (otherwise != null) { otherwise(); return; }

            throw new InvalidOperationException();
        }

        public TResult Match<TResult>(Func<T0, TResult> f0 = null, Func<T1, TResult> f1 = null, Func<T2, TResult> f2 = null, Func<T3, TResult> f3 = null, Func<T4, TResult> f4 = null, Func<TResult> otherwise = null)
        {
            if (this.IsT0 && f0 != null) return f0(this.AsT0);
            if (this.IsT1 && f1 != null) return f1(this.AsT1);
            if (this.IsT2 && f2 != null) return f2(this.AsT2);
            if (this.IsT3 && f3 != null) return f3(this.AsT3);
            if (this.IsT4 && f4 != null) return f4(this.AsT4);

            if (otherwise != null) return otherwise();

            throw new InvalidOperationException();
        }

        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            if (!(obj is OneOfBase<T0, T1, T2, T3, T4>)) return false;

            var other = (OneOfBase<T0, T1, T2, T3, T4>)obj;
            return index == other.index && Equals(value, other.value);
        }

        public override int GetHashCode() => unchecked((value?.GetHashCode() ?? 0) * 397 ^ index);

        public override string ToString() => (value?.ToString() ?? "");
    }

    [JsonConverter(typeof(OneOfJsonConverter))]
    public class OneOfBase<T0, T1, T2, T3, T4, T5> : IOneOf
    {
        readonly object value;
        readonly int index;

        OneOfBase(object value, int index) { this.value = value; this.index = index; }

        protected OneOfBase()
        {
            this.value = this;

            if (this is T0) this.index = 0;
            if (this is T1) this.index = 1;
            if (this is T2) this.index = 2;
            if (this is T3) this.index = 3;
            if (this is T4) this.index = 4;
            if (this is T5) this.index = 5;
        }

        object IOneOf.Value => value;

        T Get<T>(int index)
        {
            if (index != this.index)
            {
                throw new InvalidOperationException($"Cannot return as T{index} as result is T{this.index}");
            }
            return (T)value;
        }

        public bool IsT0 => index == 0;
        public bool IsT1 => index == 1;
        public bool IsT2 => index == 2;
        public bool IsT3 => index == 3;
        public bool IsT4 => index == 4;
        public bool IsT5 => index == 5;

        public bool Is<T>()
        {
            // quick path for when value non-null and correct type
            if (this.value is T) return true;

            // slower path for when value null, or wrong type
            if (IsT0 && typeof(T) == typeof(T0)) return true;
            if (IsT1 && typeof(T) == typeof(T1)) return true;
            if (IsT2 && typeof(T) == typeof(T2)) return true;
            if (IsT3 && typeof(T) == typeof(T3)) return true;
            if (IsT4 && typeof(T) == typeof(T4)) return true;
            if (IsT5 && typeof(T) == typeof(T5)) return true;

            return false;
        }

        public T0 AsT0 => Get<T0>(0);
        public T1 AsT1 => Get<T1>(1);
        public T2 AsT2 => Get<T2>(2);
        public T3 AsT3 => Get<T3>(3);
        public T4 AsT4 => Get<T4>(4);
        public T5 AsT5 => Get<T5>(5);

        public T As<T>()
        {
            // quick path for when value non-null and correct type
            if (this.value is T) return (T)this.value;

            // slower path for when value null, or wrong type
            if (IsT0 && typeof(T) == typeof(T0)) return (T)value;
            if (IsT1 && typeof(T) == typeof(T1)) return (T)value;
            if (IsT2 && typeof(T) == typeof(T2)) return (T)value;
            if (IsT3 && typeof(T) == typeof(T3)) return (T)value;
            if (IsT4 && typeof(T) == typeof(T4)) return (T)value;
            if (IsT5 && typeof(T) == typeof(T5)) return (T)value;

            throw new InvalidOperationException();
        }

        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5>(T0 t) => new OneOfBase<T0, T1, T2, T3, T4, T5>(t, 0);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5>(T1 t) => new OneOfBase<T0, T1, T2, T3, T4, T5>(t, 1);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5>(T2 t) => new OneOfBase<T0, T1, T2, T3, T4, T5>(t, 2);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5>(T3 t) => new OneOfBase<T0, T1, T2, T3, T4, T5>(t, 3);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5>(T4 t) => new OneOfBase<T0, T1, T2, T3, T4, T5>(t, 4);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5>(T5 t) => new OneOfBase<T0, T1, T2, T3, T4, T5>(t, 5);

        public void Switch(Action<T0> f0 = null, Action<T1> f1 = null, Action<T2> f2 = null, Action<T3> f3 = null, Action<T4> f4 = null, Action<T5> f5 = null, Action otherwise = null)
        {
            if (this.IsT0 && f0 != null) { f0(this.AsT0); return; }
            if (this.IsT1 && f1 != null) { f1(this.AsT1); return; }
            if (this.IsT2 && f2 != null) { f2(this.AsT2); return; }
            if (this.IsT3 && f3 != null) { f3(this.AsT3); return; }
            if (this.IsT4 && f4 != null) { f4(this.AsT4); return; }
            if (this.IsT5 && f5 != null) { f5(this.AsT5); return; }

            if (otherwise != null) { otherwise(); return; }

            throw new InvalidOperationException();
        }

        public TResult Match<TResult>(Func<T0, TResult> f0 = null, Func<T1, TResult> f1 = null, Func<T2, TResult> f2 = null, Func<T3, TResult> f3 = null, Func<T4, TResult> f4 = null, Func<T5, TResult> f5 = null, Func<TResult> otherwise = null)
        {
            if (this.IsT0 && f0 != null) return f0(this.AsT0);
            if (this.IsT1 && f1 != null) return f1(this.AsT1);
            if (this.IsT2 && f2 != null) return f2(this.AsT2);
            if (this.IsT3 && f3 != null) return f3(this.AsT3);
            if (this.IsT4 && f4 != null) return f4(this.AsT4);
            if (this.IsT5 && f5 != null) return f5(this.AsT5);

            if (otherwise != null) return otherwise();

            throw new InvalidOperationException();
        }

        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            if (!(obj is OneOfBase<T0, T1, T2, T3, T4, T5>)) return false;

            var other = (OneOfBase<T0, T1, T2, T3, T4, T5>)obj;
            return index == other.index && Equals(value, other.value);
        }

        public override int GetHashCode() => unchecked((value?.GetHashCode() ?? 0) * 397 ^ index);

        public override string ToString() => (value?.ToString() ?? "");
    }

    [JsonConverter(typeof(OneOfJsonConverter))]
    public class OneOfBase<T0, T1, T2, T3, T4, T5, T6> : IOneOf
    {
        readonly object value;
        readonly int index;

        OneOfBase(object value, int index) { this.value = value; this.index = index; }

        protected OneOfBase()
        {
            this.value = this;

            if (this is T0) this.index = 0;
            if (this is T1) this.index = 1;
            if (this is T2) this.index = 2;
            if (this is T3) this.index = 3;
            if (this is T4) this.index = 4;
            if (this is T5) this.index = 5;
            if (this is T6) this.index = 6;
        }

        object IOneOf.Value => value;

        T Get<T>(int index)
        {
            if (index != this.index)
            {
                throw new InvalidOperationException($"Cannot return as T{index} as result is T{this.index}");
            }
            return (T)value;
        }

        public bool IsT0 => index == 0;
        public bool IsT1 => index == 1;
        public bool IsT2 => index == 2;
        public bool IsT3 => index == 3;
        public bool IsT4 => index == 4;
        public bool IsT5 => index == 5;
        public bool IsT6 => index == 6;

        public bool Is<T>()
        {
            // quick path for when value non-null and correct type
            if (this.value is T) return true;

            // slower path for when value null, or wrong type
            if (IsT0 && typeof(T) == typeof(T0)) return true;
            if (IsT1 && typeof(T) == typeof(T1)) return true;
            if (IsT2 && typeof(T) == typeof(T2)) return true;
            if (IsT3 && typeof(T) == typeof(T3)) return true;
            if (IsT4 && typeof(T) == typeof(T4)) return true;
            if (IsT5 && typeof(T) == typeof(T5)) return true;
            if (IsT6 && typeof(T) == typeof(T6)) return true;

            return false;
        }

        public T0 AsT0 => Get<T0>(0);
        public T1 AsT1 => Get<T1>(1);
        public T2 AsT2 => Get<T2>(2);
        public T3 AsT3 => Get<T3>(3);
        public T4 AsT4 => Get<T4>(4);
        public T5 AsT5 => Get<T5>(5);
        public T6 AsT6 => Get<T6>(6);

        public T As<T>()
        {
            // quick path for when value non-null and correct type
            if (this.value is T) return (T)this.value;

            // slower path for when value null, or wrong type
            if (IsT0 && typeof(T) == typeof(T0)) return (T)value;
            if (IsT1 && typeof(T) == typeof(T1)) return (T)value;
            if (IsT2 && typeof(T) == typeof(T2)) return (T)value;
            if (IsT3 && typeof(T) == typeof(T3)) return (T)value;
            if (IsT4 && typeof(T) == typeof(T4)) return (T)value;
            if (IsT5 && typeof(T) == typeof(T5)) return (T)value;
            if (IsT6 && typeof(T) == typeof(T6)) return (T)value;

            throw new InvalidOperationException();
        }

        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5, T6>(T0 t) => new OneOfBase<T0, T1, T2, T3, T4, T5, T6>(t, 0);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5, T6>(T1 t) => new OneOfBase<T0, T1, T2, T3, T4, T5, T6>(t, 1);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5, T6>(T2 t) => new OneOfBase<T0, T1, T2, T3, T4, T5, T6>(t, 2);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5, T6>(T3 t) => new OneOfBase<T0, T1, T2, T3, T4, T5, T6>(t, 3);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5, T6>(T4 t) => new OneOfBase<T0, T1, T2, T3, T4, T5, T6>(t, 4);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5, T6>(T5 t) => new OneOfBase<T0, T1, T2, T3, T4, T5, T6>(t, 5);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5, T6>(T6 t) => new OneOfBase<T0, T1, T2, T3, T4, T5, T6>(t, 6);

        public void Switch(Action<T0> f0 = null, Action<T1> f1 = null, Action<T2> f2 = null, Action<T3> f3 = null, Action<T4> f4 = null, Action<T5> f5 = null, Action<T6> f6 = null, Action otherwise = null)
        {
            if (this.IsT0 && f0 != null) { f0(this.AsT0); return; }
            if (this.IsT1 && f1 != null) { f1(this.AsT1); return; }
            if (this.IsT2 && f2 != null) { f2(this.AsT2); return; }
            if (this.IsT3 && f3 != null) { f3(this.AsT3); return; }
            if (this.IsT4 && f4 != null) { f4(this.AsT4); return; }
            if (this.IsT5 && f5 != null) { f5(this.AsT5); return; }
            if (this.IsT6 && f6 != null) { f6(this.AsT6); return; }

            if (otherwise != null) { otherwise(); return; }

            throw new InvalidOperationException();
        }

        public TResult Match<TResult>(Func<T0, TResult> f0 = null, Func<T1, TResult> f1 = null, Func<T2, TResult> f2 = null, Func<T3, TResult> f3 = null, Func<T4, TResult> f4 = null, Func<T5, TResult> f5 = null, Func<T6, TResult> f6 = null, Func<TResult> otherwise = null)
        {
            if (this.IsT0 && f0 != null) return f0(this.AsT0);
            if (this.IsT1 && f1 != null) return f1(this.AsT1);
            if (this.IsT2 && f2 != null) return f2(this.AsT2);
            if (this.IsT3 && f3 != null) return f3(this.AsT3);
            if (this.IsT4 && f4 != null) return f4(this.AsT4);
            if (this.IsT5 && f5 != null) return f5(this.AsT5);
            if (this.IsT6 && f6 != null) return f6(this.AsT6);

            if (otherwise != null) return otherwise();

            throw new InvalidOperationException();
        }

        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            if (!(obj is OneOfBase<T0, T1, T2, T3, T4, T5, T6>)) return false;

            var other = (OneOfBase<T0, T1, T2, T3, T4, T5, T6>)obj;
            return index == other.index && Equals(value, other.value);
        }

        public override int GetHashCode() => unchecked((value?.GetHashCode() ?? 0) * 397 ^ index);

        public override string ToString() => (value?.ToString() ?? "");
    }

    [JsonConverter(typeof(OneOfJsonConverter))]
    public class OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> : IOneOf
    {
        readonly object value;
        readonly int index;

        OneOfBase(object value, int index) { this.value = value; this.index = index; }

        protected OneOfBase()
        {
            this.value = this;

            if (this is T0) this.index = 0;
            if (this is T1) this.index = 1;
            if (this is T2) this.index = 2;
            if (this is T3) this.index = 3;
            if (this is T4) this.index = 4;
            if (this is T5) this.index = 5;
            if (this is T6) this.index = 6;
            if (this is T7) this.index = 7;
        }

        object IOneOf.Value => value;

        T Get<T>(int index)
        {
            if (index != this.index)
            {
                throw new InvalidOperationException($"Cannot return as T{index} as result is T{this.index}");
            }
            return (T)value;
        }

        public bool IsT0 => index == 0;
        public bool IsT1 => index == 1;
        public bool IsT2 => index == 2;
        public bool IsT3 => index == 3;
        public bool IsT4 => index == 4;
        public bool IsT5 => index == 5;
        public bool IsT6 => index == 6;
        public bool IsT7 => index == 7;

        public bool Is<T>()
        {
            // quick path for when value non-null and correct type
            if (this.value is T) return true;

            // slower path for when value null, or wrong type
            if (IsT0 && typeof(T) == typeof(T0)) return true;
            if (IsT1 && typeof(T) == typeof(T1)) return true;
            if (IsT2 && typeof(T) == typeof(T2)) return true;
            if (IsT3 && typeof(T) == typeof(T3)) return true;
            if (IsT4 && typeof(T) == typeof(T4)) return true;
            if (IsT5 && typeof(T) == typeof(T5)) return true;
            if (IsT6 && typeof(T) == typeof(T6)) return true;
            if (IsT7 && typeof(T) == typeof(T7)) return true;

            return false;
        }

        public T0 AsT0 => Get<T0>(0);
        public T1 AsT1 => Get<T1>(1);
        public T2 AsT2 => Get<T2>(2);
        public T3 AsT3 => Get<T3>(3);
        public T4 AsT4 => Get<T4>(4);
        public T5 AsT5 => Get<T5>(5);
        public T6 AsT6 => Get<T6>(6);
        public T7 AsT7 => Get<T7>(7);

        public T As<T>()
        {
            // quick path for when value non-null and correct type
            if (this.value is T) return (T)this.value;

            // slower path for when value null, or wrong type
            if (IsT0 && typeof(T) == typeof(T0)) return (T)value;
            if (IsT1 && typeof(T) == typeof(T1)) return (T)value;
            if (IsT2 && typeof(T) == typeof(T2)) return (T)value;
            if (IsT3 && typeof(T) == typeof(T3)) return (T)value;
            if (IsT4 && typeof(T) == typeof(T4)) return (T)value;
            if (IsT5 && typeof(T) == typeof(T5)) return (T)value;
            if (IsT6 && typeof(T) == typeof(T6)) return (T)value;
            if (IsT7 && typeof(T) == typeof(T7)) return (T)value;

            throw new InvalidOperationException();
        }

        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7>(T0 t) => new OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7>(t, 0);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7>(T1 t) => new OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7>(t, 1);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7>(T2 t) => new OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7>(t, 2);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7>(T3 t) => new OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7>(t, 3);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7>(T4 t) => new OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7>(t, 4);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7>(T5 t) => new OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7>(t, 5);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7>(T6 t) => new OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7>(t, 6);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7>(T7 t) => new OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7>(t, 7);

        public void Switch(Action<T0> f0 = null, Action<T1> f1 = null, Action<T2> f2 = null, Action<T3> f3 = null, Action<T4> f4 = null, Action<T5> f5 = null, Action<T6> f6 = null, Action<T7> f7 = null, Action otherwise = null)
        {
            if (this.IsT0 && f0 != null) { f0(this.AsT0); return; }
            if (this.IsT1 && f1 != null) { f1(this.AsT1); return; }
            if (this.IsT2 && f2 != null) { f2(this.AsT2); return; }
            if (this.IsT3 && f3 != null) { f3(this.AsT3); return; }
            if (this.IsT4 && f4 != null) { f4(this.AsT4); return; }
            if (this.IsT5 && f5 != null) { f5(this.AsT5); return; }
            if (this.IsT6 && f6 != null) { f6(this.AsT6); return; }
            if (this.IsT7 && f7 != null) { f7(this.AsT7); return; }

            if (otherwise != null) { otherwise(); return; }

            throw new InvalidOperationException();
        }

        public TResult Match<TResult>(Func<T0, TResult> f0 = null, Func<T1, TResult> f1 = null, Func<T2, TResult> f2 = null, Func<T3, TResult> f3 = null, Func<T4, TResult> f4 = null, Func<T5, TResult> f5 = null, Func<T6, TResult> f6 = null, Func<T7, TResult> f7 = null, Func<TResult> otherwise = null)
        {
            if (this.IsT0 && f0 != null) return f0(this.AsT0);
            if (this.IsT1 && f1 != null) return f1(this.AsT1);
            if (this.IsT2 && f2 != null) return f2(this.AsT2);
            if (this.IsT3 && f3 != null) return f3(this.AsT3);
            if (this.IsT4 && f4 != null) return f4(this.AsT4);
            if (this.IsT5 && f5 != null) return f5(this.AsT5);
            if (this.IsT6 && f6 != null) return f6(this.AsT6);
            if (this.IsT7 && f7 != null) return f7(this.AsT7);

            if (otherwise != null) return otherwise();

            throw new InvalidOperationException();
        }

        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            if (!(obj is OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7>)) return false;

            var other = (OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7>)obj;
            return index == other.index && Equals(value, other.value);
        }

        public override int GetHashCode() => unchecked((value?.GetHashCode() ?? 0) * 397 ^ index);

        public override string ToString() => (value?.ToString() ?? "");
    }

    [JsonConverter(typeof(OneOfJsonConverter))]
    public class OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> : IOneOf
    {
        readonly object value;
        readonly int index;

        OneOfBase(object value, int index) { this.value = value; this.index = index; }

        protected OneOfBase()
        {
            this.value = this;

            if (this is T0) this.index = 0;
            if (this is T1) this.index = 1;
            if (this is T2) this.index = 2;
            if (this is T3) this.index = 3;
            if (this is T4) this.index = 4;
            if (this is T5) this.index = 5;
            if (this is T6) this.index = 6;
            if (this is T7) this.index = 7;
            if (this is T8) this.index = 8;
        }

        object IOneOf.Value => value;

        T Get<T>(int index)
        {
            if (index != this.index)
            {
                throw new InvalidOperationException($"Cannot return as T{index} as result is T{this.index}");
            }
            return (T)value;
        }

        public bool IsT0 => index == 0;
        public bool IsT1 => index == 1;
        public bool IsT2 => index == 2;
        public bool IsT3 => index == 3;
        public bool IsT4 => index == 4;
        public bool IsT5 => index == 5;
        public bool IsT6 => index == 6;
        public bool IsT7 => index == 7;
        public bool IsT8 => index == 8;

        public bool Is<T>()
        {
            // quick path for when value non-null and correct type
            if (this.value is T) return true;

            // slower path for when value null, or wrong type
            if (IsT0 && typeof(T) == typeof(T0)) return true;
            if (IsT1 && typeof(T) == typeof(T1)) return true;
            if (IsT2 && typeof(T) == typeof(T2)) return true;
            if (IsT3 && typeof(T) == typeof(T3)) return true;
            if (IsT4 && typeof(T) == typeof(T4)) return true;
            if (IsT5 && typeof(T) == typeof(T5)) return true;
            if (IsT6 && typeof(T) == typeof(T6)) return true;
            if (IsT7 && typeof(T) == typeof(T7)) return true;
            if (IsT8 && typeof(T) == typeof(T8)) return true;

            return false;
        }

        public T0 AsT0 => Get<T0>(0);
        public T1 AsT1 => Get<T1>(1);
        public T2 AsT2 => Get<T2>(2);
        public T3 AsT3 => Get<T3>(3);
        public T4 AsT4 => Get<T4>(4);
        public T5 AsT5 => Get<T5>(5);
        public T6 AsT6 => Get<T6>(6);
        public T7 AsT7 => Get<T7>(7);
        public T8 AsT8 => Get<T8>(8);

        public T As<T>()
        {
            // quick path for when value non-null and correct type
            if (this.value is T) return (T)this.value;

            // slower path for when value null, or wrong type
            if (IsT0 && typeof(T) == typeof(T0)) return (T)value;
            if (IsT1 && typeof(T) == typeof(T1)) return (T)value;
            if (IsT2 && typeof(T) == typeof(T2)) return (T)value;
            if (IsT3 && typeof(T) == typeof(T3)) return (T)value;
            if (IsT4 && typeof(T) == typeof(T4)) return (T)value;
            if (IsT5 && typeof(T) == typeof(T5)) return (T)value;
            if (IsT6 && typeof(T) == typeof(T6)) return (T)value;
            if (IsT7 && typeof(T) == typeof(T7)) return (T)value;
            if (IsT8 && typeof(T) == typeof(T8)) return (T)value;

            throw new InvalidOperationException();
        }

        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8>(T0 t) => new OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8>(t, 0);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8>(T1 t) => new OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8>(t, 1);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8>(T2 t) => new OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8>(t, 2);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8>(T3 t) => new OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8>(t, 3);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8>(T4 t) => new OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8>(t, 4);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8>(T5 t) => new OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8>(t, 5);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8>(T6 t) => new OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8>(t, 6);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8>(T7 t) => new OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8>(t, 7);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8>(T8 t) => new OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8>(t, 8);

        public void Switch(Action<T0> f0 = null, Action<T1> f1 = null, Action<T2> f2 = null, Action<T3> f3 = null, Action<T4> f4 = null, Action<T5> f5 = null, Action<T6> f6 = null, Action<T7> f7 = null, Action<T8> f8 = null, Action otherwise = null)
        {
            if (this.IsT0 && f0 != null) { f0(this.AsT0); return; }
            if (this.IsT1 && f1 != null) { f1(this.AsT1); return; }
            if (this.IsT2 && f2 != null) { f2(this.AsT2); return; }
            if (this.IsT3 && f3 != null) { f3(this.AsT3); return; }
            if (this.IsT4 && f4 != null) { f4(this.AsT4); return; }
            if (this.IsT5 && f5 != null) { f5(this.AsT5); return; }
            if (this.IsT6 && f6 != null) { f6(this.AsT6); return; }
            if (this.IsT7 && f7 != null) { f7(this.AsT7); return; }
            if (this.IsT8 && f8 != null) { f8(this.AsT8); return; }

            if (otherwise != null) { otherwise(); return; }

            throw new InvalidOperationException();
        }

        public TResult Match<TResult>(Func<T0, TResult> f0 = null, Func<T1, TResult> f1 = null, Func<T2, TResult> f2 = null, Func<T3, TResult> f3 = null, Func<T4, TResult> f4 = null, Func<T5, TResult> f5 = null, Func<T6, TResult> f6 = null, Func<T7, TResult> f7 = null, Func<T8, TResult> f8 = null, Func<TResult> otherwise = null)
        {
            if (this.IsT0 && f0 != null) return f0(this.AsT0);
            if (this.IsT1 && f1 != null) return f1(this.AsT1);
            if (this.IsT2 && f2 != null) return f2(this.AsT2);
            if (this.IsT3 && f3 != null) return f3(this.AsT3);
            if (this.IsT4 && f4 != null) return f4(this.AsT4);
            if (this.IsT5 && f5 != null) return f5(this.AsT5);
            if (this.IsT6 && f6 != null) return f6(this.AsT6);
            if (this.IsT7 && f7 != null) return f7(this.AsT7);
            if (this.IsT8 && f8 != null) return f8(this.AsT8);

            if (otherwise != null) return otherwise();

            throw new InvalidOperationException();
        }

        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            if (!(obj is OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8>)) return false;

            var other = (OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8>)obj;
            return index == other.index && Equals(value, other.value);
        }

        public override int GetHashCode() => unchecked((value?.GetHashCode() ?? 0) * 397 ^ index);

        public override string ToString() => (value?.ToString() ?? "");
    }

}
