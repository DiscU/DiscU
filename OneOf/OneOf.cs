// ===========================================================================
// Generated by OneOf.tt
// ===========================================================================

using System;
using Microsoft.CSharp.RuntimeBinder;

namespace OneOf
{
    public struct OneOf<T0, T1> : IOneOf
    {
        private readonly object value;
        private readonly Type origType;

        OneOf(object value, Type origType)
        {
            this.value = value;
            this.origType = origType;
        }

        object IOneOf.Value => value;

        internal static OneOf<T0, T1> CreateRaw(object value)
        {
            if (value == null) throw new ArgumentNullException(nameof(value));
            if (value.GetType() == typeof(T0)) return Create((T0)value);
            if (value.GetType() == typeof(T1)) return Create((T1)value);
            try
            {
                return Create((dynamic)value);
            }
            catch (RuntimeBinderException ex)
            {
                throw new ArgumentException(nameof(value), ex);
            }
        }

        static OneOf<T0, T1> Create(T0 value) => new OneOf<T0, T1>(value, typeof(T0));
        static OneOf<T0, T1> Create(T1 value) => new OneOf<T0, T1>(value, typeof(T1));

        public OneOf<N0, N1> ToOneOf<N0, N1>() => OneOf<N0, N1>.CreateRaw(value);
        public OneOf<N0, N1, N2> ToOneOf<N0, N1, N2>() => OneOf<N0, N1, N2>.CreateRaw(value);
        public OneOf<N0, N1, N2, N3> ToOneOf<N0, N1, N2, N3>() => OneOf<N0, N1, N2, N3>.CreateRaw(value);
        public OneOf<N0, N1, N2, N3, N4> ToOneOf<N0, N1, N2, N3, N4>() => OneOf<N0, N1, N2, N3, N4>.CreateRaw(value);
        public OneOf<N0, N1, N2, N3, N4, N5> ToOneOf<N0, N1, N2, N3, N4, N5>() => OneOf<N0, N1, N2, N3, N4, N5>.CreateRaw(value);
        public OneOf<N0, N1, N2, N3, N4, N5, N6> ToOneOf<N0, N1, N2, N3, N4, N5, N6>() => OneOf<N0, N1, N2, N3, N4, N5, N6>.CreateRaw(value);
        public OneOf<N0, N1, N2, N3, N4, N5, N6, N7> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7>() => OneOf<N0, N1, N2, N3, N4, N5, N6, N7>.CreateRaw(value);
        public OneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8>() => OneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8>.CreateRaw(value);

        public static implicit operator OneOf<T0, T1>(T0 value) => CreateRaw(value);
        public static implicit operator OneOf<T0, T1>(T1 value) => CreateRaw(value);

        public static bool operator ==(OneOf<T0, T1> v1, IOneOf v2) => Equals(v1,v2);
        public static bool operator !=(OneOf<T0, T1> v1, IOneOf v2) => !Equals(v1,v2);
        public static bool operator ==(OneOf<T0, T1> v1, T0 v2) => Equals(v1,v2);
        public static bool operator !=(OneOf<T0, T1> v1, T0 v2) => !Equals(v1,v2);
        public static bool operator ==(T0 v1, OneOf<T0, T1> v2) => Equals(v2,v1);
        public static bool operator !=(T0 v1, OneOf<T0, T1> v2) => !Equals(v2,v1);
        public static bool operator ==(OneOf<T0, T1> v1, T1 v2) => Equals(v1,v2);
        public static bool operator !=(OneOf<T0, T1> v1, T1 v2) => !Equals(v1,v2);
        public static bool operator ==(T1 v1, OneOf<T0, T1> v2) => Equals(v2,v1);
        public static bool operator !=(T1 v1, OneOf<T0, T1> v2) => !Equals(v2,v1);

        public OneOfSwitcher<T1> Switch(Action<T0> action) => new OneOfSwitcher<T0, T1>(value, origType).Switch(action);
        public OneOfSwitcher<T0> Switch(Action<T1> action) => new OneOfSwitcher<T0, T1>(value, origType).Switch(action);

        public OneOfMatcher<T1, TResult> Match<TResult>(Func<T0, TResult> func) => new OneOfMatcher<T0, T1, TResult>(value, origType).Match(func);
        public OneOfMatcher<T0, TResult> Match<TResult>(Func<T1, TResult> func) => new OneOfMatcher<T0, T1, TResult>(value, origType).Match(func);

        public override bool Equals(object obj) => (obj is IOneOf) && Equals(value, ((IOneOf)obj).Value) || value.Equals(obj);
        public override int GetHashCode() => (value?.GetHashCode() ?? origType?.GetHashCode() ?? 0);
        public override string ToString() => (value?.ToString() ?? "");
    }
    public struct OneOf<T0, T1, T2> : IOneOf
    {
        private readonly object value;
        private readonly Type origType;

        OneOf(object value, Type origType)
        {
            this.value = value;
            this.origType = origType;
        }

        object IOneOf.Value => value;

        internal static OneOf<T0, T1, T2> CreateRaw(object value)
        {
            if (value == null) throw new ArgumentNullException(nameof(value));
            if (value.GetType() == typeof(T0)) return Create((T0)value);
            if (value.GetType() == typeof(T1)) return Create((T1)value);
            if (value.GetType() == typeof(T2)) return Create((T2)value);
            try
            {
                return Create((dynamic)value);
            }
            catch (RuntimeBinderException ex)
            {
                throw new ArgumentException(nameof(value), ex);
            }
        }

        static OneOf<T0, T1, T2> Create(T0 value) => new OneOf<T0, T1, T2>(value, typeof(T0));
        static OneOf<T0, T1, T2> Create(T1 value) => new OneOf<T0, T1, T2>(value, typeof(T1));
        static OneOf<T0, T1, T2> Create(T2 value) => new OneOf<T0, T1, T2>(value, typeof(T2));

        public OneOf<N0, N1, N2> ToOneOf<N0, N1, N2>() => OneOf<N0, N1, N2>.CreateRaw(value);
        public OneOf<N0, N1, N2, N3> ToOneOf<N0, N1, N2, N3>() => OneOf<N0, N1, N2, N3>.CreateRaw(value);
        public OneOf<N0, N1, N2, N3, N4> ToOneOf<N0, N1, N2, N3, N4>() => OneOf<N0, N1, N2, N3, N4>.CreateRaw(value);
        public OneOf<N0, N1, N2, N3, N4, N5> ToOneOf<N0, N1, N2, N3, N4, N5>() => OneOf<N0, N1, N2, N3, N4, N5>.CreateRaw(value);
        public OneOf<N0, N1, N2, N3, N4, N5, N6> ToOneOf<N0, N1, N2, N3, N4, N5, N6>() => OneOf<N0, N1, N2, N3, N4, N5, N6>.CreateRaw(value);
        public OneOf<N0, N1, N2, N3, N4, N5, N6, N7> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7>() => OneOf<N0, N1, N2, N3, N4, N5, N6, N7>.CreateRaw(value);
        public OneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8>() => OneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8>.CreateRaw(value);

        public static implicit operator OneOf<T0, T1, T2>(T0 value) => CreateRaw(value);
        public static implicit operator OneOf<T0, T1, T2>(T1 value) => CreateRaw(value);
        public static implicit operator OneOf<T0, T1, T2>(T2 value) => CreateRaw(value);

        public static bool operator ==(OneOf<T0, T1, T2> v1, IOneOf v2) => Equals(v1,v2);
        public static bool operator !=(OneOf<T0, T1, T2> v1, IOneOf v2) => !Equals(v1,v2);
        public static bool operator ==(OneOf<T0, T1, T2> v1, T0 v2) => Equals(v1,v2);
        public static bool operator !=(OneOf<T0, T1, T2> v1, T0 v2) => !Equals(v1,v2);
        public static bool operator ==(T0 v1, OneOf<T0, T1, T2> v2) => Equals(v2,v1);
        public static bool operator !=(T0 v1, OneOf<T0, T1, T2> v2) => !Equals(v2,v1);
        public static bool operator ==(OneOf<T0, T1, T2> v1, T1 v2) => Equals(v1,v2);
        public static bool operator !=(OneOf<T0, T1, T2> v1, T1 v2) => !Equals(v1,v2);
        public static bool operator ==(T1 v1, OneOf<T0, T1, T2> v2) => Equals(v2,v1);
        public static bool operator !=(T1 v1, OneOf<T0, T1, T2> v2) => !Equals(v2,v1);
        public static bool operator ==(OneOf<T0, T1, T2> v1, T2 v2) => Equals(v1,v2);
        public static bool operator !=(OneOf<T0, T1, T2> v1, T2 v2) => !Equals(v1,v2);
        public static bool operator ==(T2 v1, OneOf<T0, T1, T2> v2) => Equals(v2,v1);
        public static bool operator !=(T2 v1, OneOf<T0, T1, T2> v2) => !Equals(v2,v1);

        public OneOfSwitcher<T1, T2> Switch(Action<T0> action) => new OneOfSwitcher<T0, T1, T2>(value, origType).Switch(action);
        public OneOfSwitcher<T0, T2> Switch(Action<T1> action) => new OneOfSwitcher<T0, T1, T2>(value, origType).Switch(action);
        public OneOfSwitcher<T0, T1> Switch(Action<T2> action) => new OneOfSwitcher<T0, T1, T2>(value, origType).Switch(action);

        public OneOfMatcher<T1, T2, TResult> Match<TResult>(Func<T0, TResult> func) => new OneOfMatcher<T0, T1, T2, TResult>(value, origType).Match(func);
        public OneOfMatcher<T0, T2, TResult> Match<TResult>(Func<T1, TResult> func) => new OneOfMatcher<T0, T1, T2, TResult>(value, origType).Match(func);
        public OneOfMatcher<T0, T1, TResult> Match<TResult>(Func<T2, TResult> func) => new OneOfMatcher<T0, T1, T2, TResult>(value, origType).Match(func);

        public override bool Equals(object obj) => (obj is IOneOf) && Equals(value, ((IOneOf)obj).Value) || value.Equals(obj);
        public override int GetHashCode() => (value?.GetHashCode() ?? origType?.GetHashCode() ?? 0);
        public override string ToString() => (value?.ToString() ?? "");
    }
    public struct OneOf<T0, T1, T2, T3> : IOneOf
    {
        private readonly object value;
        private readonly Type origType;

        OneOf(object value, Type origType)
        {
            this.value = value;
            this.origType = origType;
        }

        object IOneOf.Value => value;

        internal static OneOf<T0, T1, T2, T3> CreateRaw(object value)
        {
            if (value == null) throw new ArgumentNullException(nameof(value));
            if (value.GetType() == typeof(T0)) return Create((T0)value);
            if (value.GetType() == typeof(T1)) return Create((T1)value);
            if (value.GetType() == typeof(T2)) return Create((T2)value);
            if (value.GetType() == typeof(T3)) return Create((T3)value);
            try
            {
                return Create((dynamic)value);
            }
            catch (RuntimeBinderException ex)
            {
                throw new ArgumentException(nameof(value), ex);
            }
        }

        static OneOf<T0, T1, T2, T3> Create(T0 value) => new OneOf<T0, T1, T2, T3>(value, typeof(T0));
        static OneOf<T0, T1, T2, T3> Create(T1 value) => new OneOf<T0, T1, T2, T3>(value, typeof(T1));
        static OneOf<T0, T1, T2, T3> Create(T2 value) => new OneOf<T0, T1, T2, T3>(value, typeof(T2));
        static OneOf<T0, T1, T2, T3> Create(T3 value) => new OneOf<T0, T1, T2, T3>(value, typeof(T3));

        public OneOf<N0, N1, N2, N3> ToOneOf<N0, N1, N2, N3>() => OneOf<N0, N1, N2, N3>.CreateRaw(value);
        public OneOf<N0, N1, N2, N3, N4> ToOneOf<N0, N1, N2, N3, N4>() => OneOf<N0, N1, N2, N3, N4>.CreateRaw(value);
        public OneOf<N0, N1, N2, N3, N4, N5> ToOneOf<N0, N1, N2, N3, N4, N5>() => OneOf<N0, N1, N2, N3, N4, N5>.CreateRaw(value);
        public OneOf<N0, N1, N2, N3, N4, N5, N6> ToOneOf<N0, N1, N2, N3, N4, N5, N6>() => OneOf<N0, N1, N2, N3, N4, N5, N6>.CreateRaw(value);
        public OneOf<N0, N1, N2, N3, N4, N5, N6, N7> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7>() => OneOf<N0, N1, N2, N3, N4, N5, N6, N7>.CreateRaw(value);
        public OneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8>() => OneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8>.CreateRaw(value);

        public static implicit operator OneOf<T0, T1, T2, T3>(T0 value) => CreateRaw(value);
        public static implicit operator OneOf<T0, T1, T2, T3>(T1 value) => CreateRaw(value);
        public static implicit operator OneOf<T0, T1, T2, T3>(T2 value) => CreateRaw(value);
        public static implicit operator OneOf<T0, T1, T2, T3>(T3 value) => CreateRaw(value);

        public static bool operator ==(OneOf<T0, T1, T2, T3> v1, IOneOf v2) => Equals(v1,v2);
        public static bool operator !=(OneOf<T0, T1, T2, T3> v1, IOneOf v2) => !Equals(v1,v2);
        public static bool operator ==(OneOf<T0, T1, T2, T3> v1, T0 v2) => Equals(v1,v2);
        public static bool operator !=(OneOf<T0, T1, T2, T3> v1, T0 v2) => !Equals(v1,v2);
        public static bool operator ==(T0 v1, OneOf<T0, T1, T2, T3> v2) => Equals(v2,v1);
        public static bool operator !=(T0 v1, OneOf<T0, T1, T2, T3> v2) => !Equals(v2,v1);
        public static bool operator ==(OneOf<T0, T1, T2, T3> v1, T1 v2) => Equals(v1,v2);
        public static bool operator !=(OneOf<T0, T1, T2, T3> v1, T1 v2) => !Equals(v1,v2);
        public static bool operator ==(T1 v1, OneOf<T0, T1, T2, T3> v2) => Equals(v2,v1);
        public static bool operator !=(T1 v1, OneOf<T0, T1, T2, T3> v2) => !Equals(v2,v1);
        public static bool operator ==(OneOf<T0, T1, T2, T3> v1, T2 v2) => Equals(v1,v2);
        public static bool operator !=(OneOf<T0, T1, T2, T3> v1, T2 v2) => !Equals(v1,v2);
        public static bool operator ==(T2 v1, OneOf<T0, T1, T2, T3> v2) => Equals(v2,v1);
        public static bool operator !=(T2 v1, OneOf<T0, T1, T2, T3> v2) => !Equals(v2,v1);
        public static bool operator ==(OneOf<T0, T1, T2, T3> v1, T3 v2) => Equals(v1,v2);
        public static bool operator !=(OneOf<T0, T1, T2, T3> v1, T3 v2) => !Equals(v1,v2);
        public static bool operator ==(T3 v1, OneOf<T0, T1, T2, T3> v2) => Equals(v2,v1);
        public static bool operator !=(T3 v1, OneOf<T0, T1, T2, T3> v2) => !Equals(v2,v1);

        public OneOfSwitcher<T1, T2, T3> Switch(Action<T0> action) => new OneOfSwitcher<T0, T1, T2, T3>(value, origType).Switch(action);
        public OneOfSwitcher<T0, T2, T3> Switch(Action<T1> action) => new OneOfSwitcher<T0, T1, T2, T3>(value, origType).Switch(action);
        public OneOfSwitcher<T0, T1, T3> Switch(Action<T2> action) => new OneOfSwitcher<T0, T1, T2, T3>(value, origType).Switch(action);
        public OneOfSwitcher<T0, T1, T2> Switch(Action<T3> action) => new OneOfSwitcher<T0, T1, T2, T3>(value, origType).Switch(action);

        public OneOfMatcher<T1, T2, T3, TResult> Match<TResult>(Func<T0, TResult> func) => new OneOfMatcher<T0, T1, T2, T3, TResult>(value, origType).Match(func);
        public OneOfMatcher<T0, T2, T3, TResult> Match<TResult>(Func<T1, TResult> func) => new OneOfMatcher<T0, T1, T2, T3, TResult>(value, origType).Match(func);
        public OneOfMatcher<T0, T1, T3, TResult> Match<TResult>(Func<T2, TResult> func) => new OneOfMatcher<T0, T1, T2, T3, TResult>(value, origType).Match(func);
        public OneOfMatcher<T0, T1, T2, TResult> Match<TResult>(Func<T3, TResult> func) => new OneOfMatcher<T0, T1, T2, T3, TResult>(value, origType).Match(func);

        public override bool Equals(object obj) => (obj is IOneOf) && Equals(value, ((IOneOf)obj).Value) || value.Equals(obj);
        public override int GetHashCode() => (value?.GetHashCode() ?? origType?.GetHashCode() ?? 0);
        public override string ToString() => (value?.ToString() ?? "");
    }
    public struct OneOf<T0, T1, T2, T3, T4> : IOneOf
    {
        private readonly object value;
        private readonly Type origType;

        OneOf(object value, Type origType)
        {
            this.value = value;
            this.origType = origType;
        }

        object IOneOf.Value => value;

        internal static OneOf<T0, T1, T2, T3, T4> CreateRaw(object value)
        {
            if (value == null) throw new ArgumentNullException(nameof(value));
            if (value.GetType() == typeof(T0)) return Create((T0)value);
            if (value.GetType() == typeof(T1)) return Create((T1)value);
            if (value.GetType() == typeof(T2)) return Create((T2)value);
            if (value.GetType() == typeof(T3)) return Create((T3)value);
            if (value.GetType() == typeof(T4)) return Create((T4)value);
            try
            {
                return Create((dynamic)value);
            }
            catch (RuntimeBinderException ex)
            {
                throw new ArgumentException(nameof(value), ex);
            }
        }

        static OneOf<T0, T1, T2, T3, T4> Create(T0 value) => new OneOf<T0, T1, T2, T3, T4>(value, typeof(T0));
        static OneOf<T0, T1, T2, T3, T4> Create(T1 value) => new OneOf<T0, T1, T2, T3, T4>(value, typeof(T1));
        static OneOf<T0, T1, T2, T3, T4> Create(T2 value) => new OneOf<T0, T1, T2, T3, T4>(value, typeof(T2));
        static OneOf<T0, T1, T2, T3, T4> Create(T3 value) => new OneOf<T0, T1, T2, T3, T4>(value, typeof(T3));
        static OneOf<T0, T1, T2, T3, T4> Create(T4 value) => new OneOf<T0, T1, T2, T3, T4>(value, typeof(T4));

        public OneOf<N0, N1, N2, N3, N4> ToOneOf<N0, N1, N2, N3, N4>() => OneOf<N0, N1, N2, N3, N4>.CreateRaw(value);
        public OneOf<N0, N1, N2, N3, N4, N5> ToOneOf<N0, N1, N2, N3, N4, N5>() => OneOf<N0, N1, N2, N3, N4, N5>.CreateRaw(value);
        public OneOf<N0, N1, N2, N3, N4, N5, N6> ToOneOf<N0, N1, N2, N3, N4, N5, N6>() => OneOf<N0, N1, N2, N3, N4, N5, N6>.CreateRaw(value);
        public OneOf<N0, N1, N2, N3, N4, N5, N6, N7> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7>() => OneOf<N0, N1, N2, N3, N4, N5, N6, N7>.CreateRaw(value);
        public OneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8>() => OneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8>.CreateRaw(value);

        public static implicit operator OneOf<T0, T1, T2, T3, T4>(T0 value) => CreateRaw(value);
        public static implicit operator OneOf<T0, T1, T2, T3, T4>(T1 value) => CreateRaw(value);
        public static implicit operator OneOf<T0, T1, T2, T3, T4>(T2 value) => CreateRaw(value);
        public static implicit operator OneOf<T0, T1, T2, T3, T4>(T3 value) => CreateRaw(value);
        public static implicit operator OneOf<T0, T1, T2, T3, T4>(T4 value) => CreateRaw(value);

        public static bool operator ==(OneOf<T0, T1, T2, T3, T4> v1, IOneOf v2) => Equals(v1,v2);
        public static bool operator !=(OneOf<T0, T1, T2, T3, T4> v1, IOneOf v2) => !Equals(v1,v2);
        public static bool operator ==(OneOf<T0, T1, T2, T3, T4> v1, T0 v2) => Equals(v1,v2);
        public static bool operator !=(OneOf<T0, T1, T2, T3, T4> v1, T0 v2) => !Equals(v1,v2);
        public static bool operator ==(T0 v1, OneOf<T0, T1, T2, T3, T4> v2) => Equals(v2,v1);
        public static bool operator !=(T0 v1, OneOf<T0, T1, T2, T3, T4> v2) => !Equals(v2,v1);
        public static bool operator ==(OneOf<T0, T1, T2, T3, T4> v1, T1 v2) => Equals(v1,v2);
        public static bool operator !=(OneOf<T0, T1, T2, T3, T4> v1, T1 v2) => !Equals(v1,v2);
        public static bool operator ==(T1 v1, OneOf<T0, T1, T2, T3, T4> v2) => Equals(v2,v1);
        public static bool operator !=(T1 v1, OneOf<T0, T1, T2, T3, T4> v2) => !Equals(v2,v1);
        public static bool operator ==(OneOf<T0, T1, T2, T3, T4> v1, T2 v2) => Equals(v1,v2);
        public static bool operator !=(OneOf<T0, T1, T2, T3, T4> v1, T2 v2) => !Equals(v1,v2);
        public static bool operator ==(T2 v1, OneOf<T0, T1, T2, T3, T4> v2) => Equals(v2,v1);
        public static bool operator !=(T2 v1, OneOf<T0, T1, T2, T3, T4> v2) => !Equals(v2,v1);
        public static bool operator ==(OneOf<T0, T1, T2, T3, T4> v1, T3 v2) => Equals(v1,v2);
        public static bool operator !=(OneOf<T0, T1, T2, T3, T4> v1, T3 v2) => !Equals(v1,v2);
        public static bool operator ==(T3 v1, OneOf<T0, T1, T2, T3, T4> v2) => Equals(v2,v1);
        public static bool operator !=(T3 v1, OneOf<T0, T1, T2, T3, T4> v2) => !Equals(v2,v1);
        public static bool operator ==(OneOf<T0, T1, T2, T3, T4> v1, T4 v2) => Equals(v1,v2);
        public static bool operator !=(OneOf<T0, T1, T2, T3, T4> v1, T4 v2) => !Equals(v1,v2);
        public static bool operator ==(T4 v1, OneOf<T0, T1, T2, T3, T4> v2) => Equals(v2,v1);
        public static bool operator !=(T4 v1, OneOf<T0, T1, T2, T3, T4> v2) => !Equals(v2,v1);

        public OneOfSwitcher<T1, T2, T3, T4> Switch(Action<T0> action) => new OneOfSwitcher<T0, T1, T2, T3, T4>(value, origType).Switch(action);
        public OneOfSwitcher<T0, T2, T3, T4> Switch(Action<T1> action) => new OneOfSwitcher<T0, T1, T2, T3, T4>(value, origType).Switch(action);
        public OneOfSwitcher<T0, T1, T3, T4> Switch(Action<T2> action) => new OneOfSwitcher<T0, T1, T2, T3, T4>(value, origType).Switch(action);
        public OneOfSwitcher<T0, T1, T2, T4> Switch(Action<T3> action) => new OneOfSwitcher<T0, T1, T2, T3, T4>(value, origType).Switch(action);
        public OneOfSwitcher<T0, T1, T2, T3> Switch(Action<T4> action) => new OneOfSwitcher<T0, T1, T2, T3, T4>(value, origType).Switch(action);

        public OneOfMatcher<T1, T2, T3, T4, TResult> Match<TResult>(Func<T0, TResult> func) => new OneOfMatcher<T0, T1, T2, T3, T4, TResult>(value, origType).Match(func);
        public OneOfMatcher<T0, T2, T3, T4, TResult> Match<TResult>(Func<T1, TResult> func) => new OneOfMatcher<T0, T1, T2, T3, T4, TResult>(value, origType).Match(func);
        public OneOfMatcher<T0, T1, T3, T4, TResult> Match<TResult>(Func<T2, TResult> func) => new OneOfMatcher<T0, T1, T2, T3, T4, TResult>(value, origType).Match(func);
        public OneOfMatcher<T0, T1, T2, T4, TResult> Match<TResult>(Func<T3, TResult> func) => new OneOfMatcher<T0, T1, T2, T3, T4, TResult>(value, origType).Match(func);
        public OneOfMatcher<T0, T1, T2, T3, TResult> Match<TResult>(Func<T4, TResult> func) => new OneOfMatcher<T0, T1, T2, T3, T4, TResult>(value, origType).Match(func);

        public override bool Equals(object obj) => (obj is IOneOf) && Equals(value, ((IOneOf)obj).Value) || value.Equals(obj);
        public override int GetHashCode() => (value?.GetHashCode() ?? origType?.GetHashCode() ?? 0);
        public override string ToString() => (value?.ToString() ?? "");
    }
    public struct OneOf<T0, T1, T2, T3, T4, T5> : IOneOf
    {
        private readonly object value;
        private readonly Type origType;

        OneOf(object value, Type origType)
        {
            this.value = value;
            this.origType = origType;
        }

        object IOneOf.Value => value;

        internal static OneOf<T0, T1, T2, T3, T4, T5> CreateRaw(object value)
        {
            if (value == null) throw new ArgumentNullException(nameof(value));
            if (value.GetType() == typeof(T0)) return Create((T0)value);
            if (value.GetType() == typeof(T1)) return Create((T1)value);
            if (value.GetType() == typeof(T2)) return Create((T2)value);
            if (value.GetType() == typeof(T3)) return Create((T3)value);
            if (value.GetType() == typeof(T4)) return Create((T4)value);
            if (value.GetType() == typeof(T5)) return Create((T5)value);
            try
            {
                return Create((dynamic)value);
            }
            catch (RuntimeBinderException ex)
            {
                throw new ArgumentException(nameof(value), ex);
            }
        }

        static OneOf<T0, T1, T2, T3, T4, T5> Create(T0 value) => new OneOf<T0, T1, T2, T3, T4, T5>(value, typeof(T0));
        static OneOf<T0, T1, T2, T3, T4, T5> Create(T1 value) => new OneOf<T0, T1, T2, T3, T4, T5>(value, typeof(T1));
        static OneOf<T0, T1, T2, T3, T4, T5> Create(T2 value) => new OneOf<T0, T1, T2, T3, T4, T5>(value, typeof(T2));
        static OneOf<T0, T1, T2, T3, T4, T5> Create(T3 value) => new OneOf<T0, T1, T2, T3, T4, T5>(value, typeof(T3));
        static OneOf<T0, T1, T2, T3, T4, T5> Create(T4 value) => new OneOf<T0, T1, T2, T3, T4, T5>(value, typeof(T4));
        static OneOf<T0, T1, T2, T3, T4, T5> Create(T5 value) => new OneOf<T0, T1, T2, T3, T4, T5>(value, typeof(T5));

        public OneOf<N0, N1, N2, N3, N4, N5> ToOneOf<N0, N1, N2, N3, N4, N5>() => OneOf<N0, N1, N2, N3, N4, N5>.CreateRaw(value);
        public OneOf<N0, N1, N2, N3, N4, N5, N6> ToOneOf<N0, N1, N2, N3, N4, N5, N6>() => OneOf<N0, N1, N2, N3, N4, N5, N6>.CreateRaw(value);
        public OneOf<N0, N1, N2, N3, N4, N5, N6, N7> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7>() => OneOf<N0, N1, N2, N3, N4, N5, N6, N7>.CreateRaw(value);
        public OneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8>() => OneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8>.CreateRaw(value);

        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5>(T0 value) => CreateRaw(value);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5>(T1 value) => CreateRaw(value);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5>(T2 value) => CreateRaw(value);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5>(T3 value) => CreateRaw(value);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5>(T4 value) => CreateRaw(value);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5>(T5 value) => CreateRaw(value);

        public static bool operator ==(OneOf<T0, T1, T2, T3, T4, T5> v1, IOneOf v2) => Equals(v1,v2);
        public static bool operator !=(OneOf<T0, T1, T2, T3, T4, T5> v1, IOneOf v2) => !Equals(v1,v2);
        public static bool operator ==(OneOf<T0, T1, T2, T3, T4, T5> v1, T0 v2) => Equals(v1,v2);
        public static bool operator !=(OneOf<T0, T1, T2, T3, T4, T5> v1, T0 v2) => !Equals(v1,v2);
        public static bool operator ==(T0 v1, OneOf<T0, T1, T2, T3, T4, T5> v2) => Equals(v2,v1);
        public static bool operator !=(T0 v1, OneOf<T0, T1, T2, T3, T4, T5> v2) => !Equals(v2,v1);
        public static bool operator ==(OneOf<T0, T1, T2, T3, T4, T5> v1, T1 v2) => Equals(v1,v2);
        public static bool operator !=(OneOf<T0, T1, T2, T3, T4, T5> v1, T1 v2) => !Equals(v1,v2);
        public static bool operator ==(T1 v1, OneOf<T0, T1, T2, T3, T4, T5> v2) => Equals(v2,v1);
        public static bool operator !=(T1 v1, OneOf<T0, T1, T2, T3, T4, T5> v2) => !Equals(v2,v1);
        public static bool operator ==(OneOf<T0, T1, T2, T3, T4, T5> v1, T2 v2) => Equals(v1,v2);
        public static bool operator !=(OneOf<T0, T1, T2, T3, T4, T5> v1, T2 v2) => !Equals(v1,v2);
        public static bool operator ==(T2 v1, OneOf<T0, T1, T2, T3, T4, T5> v2) => Equals(v2,v1);
        public static bool operator !=(T2 v1, OneOf<T0, T1, T2, T3, T4, T5> v2) => !Equals(v2,v1);
        public static bool operator ==(OneOf<T0, T1, T2, T3, T4, T5> v1, T3 v2) => Equals(v1,v2);
        public static bool operator !=(OneOf<T0, T1, T2, T3, T4, T5> v1, T3 v2) => !Equals(v1,v2);
        public static bool operator ==(T3 v1, OneOf<T0, T1, T2, T3, T4, T5> v2) => Equals(v2,v1);
        public static bool operator !=(T3 v1, OneOf<T0, T1, T2, T3, T4, T5> v2) => !Equals(v2,v1);
        public static bool operator ==(OneOf<T0, T1, T2, T3, T4, T5> v1, T4 v2) => Equals(v1,v2);
        public static bool operator !=(OneOf<T0, T1, T2, T3, T4, T5> v1, T4 v2) => !Equals(v1,v2);
        public static bool operator ==(T4 v1, OneOf<T0, T1, T2, T3, T4, T5> v2) => Equals(v2,v1);
        public static bool operator !=(T4 v1, OneOf<T0, T1, T2, T3, T4, T5> v2) => !Equals(v2,v1);
        public static bool operator ==(OneOf<T0, T1, T2, T3, T4, T5> v1, T5 v2) => Equals(v1,v2);
        public static bool operator !=(OneOf<T0, T1, T2, T3, T4, T5> v1, T5 v2) => !Equals(v1,v2);
        public static bool operator ==(T5 v1, OneOf<T0, T1, T2, T3, T4, T5> v2) => Equals(v2,v1);
        public static bool operator !=(T5 v1, OneOf<T0, T1, T2, T3, T4, T5> v2) => !Equals(v2,v1);

        public OneOfSwitcher<T1, T2, T3, T4, T5> Switch(Action<T0> action) => new OneOfSwitcher<T0, T1, T2, T3, T4, T5>(value, origType).Switch(action);
        public OneOfSwitcher<T0, T2, T3, T4, T5> Switch(Action<T1> action) => new OneOfSwitcher<T0, T1, T2, T3, T4, T5>(value, origType).Switch(action);
        public OneOfSwitcher<T0, T1, T3, T4, T5> Switch(Action<T2> action) => new OneOfSwitcher<T0, T1, T2, T3, T4, T5>(value, origType).Switch(action);
        public OneOfSwitcher<T0, T1, T2, T4, T5> Switch(Action<T3> action) => new OneOfSwitcher<T0, T1, T2, T3, T4, T5>(value, origType).Switch(action);
        public OneOfSwitcher<T0, T1, T2, T3, T5> Switch(Action<T4> action) => new OneOfSwitcher<T0, T1, T2, T3, T4, T5>(value, origType).Switch(action);
        public OneOfSwitcher<T0, T1, T2, T3, T4> Switch(Action<T5> action) => new OneOfSwitcher<T0, T1, T2, T3, T4, T5>(value, origType).Switch(action);

        public OneOfMatcher<T1, T2, T3, T4, T5, TResult> Match<TResult>(Func<T0, TResult> func) => new OneOfMatcher<T0, T1, T2, T3, T4, T5, TResult>(value, origType).Match(func);
        public OneOfMatcher<T0, T2, T3, T4, T5, TResult> Match<TResult>(Func<T1, TResult> func) => new OneOfMatcher<T0, T1, T2, T3, T4, T5, TResult>(value, origType).Match(func);
        public OneOfMatcher<T0, T1, T3, T4, T5, TResult> Match<TResult>(Func<T2, TResult> func) => new OneOfMatcher<T0, T1, T2, T3, T4, T5, TResult>(value, origType).Match(func);
        public OneOfMatcher<T0, T1, T2, T4, T5, TResult> Match<TResult>(Func<T3, TResult> func) => new OneOfMatcher<T0, T1, T2, T3, T4, T5, TResult>(value, origType).Match(func);
        public OneOfMatcher<T0, T1, T2, T3, T5, TResult> Match<TResult>(Func<T4, TResult> func) => new OneOfMatcher<T0, T1, T2, T3, T4, T5, TResult>(value, origType).Match(func);
        public OneOfMatcher<T0, T1, T2, T3, T4, TResult> Match<TResult>(Func<T5, TResult> func) => new OneOfMatcher<T0, T1, T2, T3, T4, T5, TResult>(value, origType).Match(func);

        public override bool Equals(object obj) => (obj is IOneOf) && Equals(value, ((IOneOf)obj).Value) || value.Equals(obj);
        public override int GetHashCode() => (value?.GetHashCode() ?? origType?.GetHashCode() ?? 0);
        public override string ToString() => (value?.ToString() ?? "");
    }
    public struct OneOf<T0, T1, T2, T3, T4, T5, T6> : IOneOf
    {
        private readonly object value;
        private readonly Type origType;

        OneOf(object value, Type origType)
        {
            this.value = value;
            this.origType = origType;
        }

        object IOneOf.Value => value;

        internal static OneOf<T0, T1, T2, T3, T4, T5, T6> CreateRaw(object value)
        {
            if (value == null) throw new ArgumentNullException(nameof(value));
            if (value.GetType() == typeof(T0)) return Create((T0)value);
            if (value.GetType() == typeof(T1)) return Create((T1)value);
            if (value.GetType() == typeof(T2)) return Create((T2)value);
            if (value.GetType() == typeof(T3)) return Create((T3)value);
            if (value.GetType() == typeof(T4)) return Create((T4)value);
            if (value.GetType() == typeof(T5)) return Create((T5)value);
            if (value.GetType() == typeof(T6)) return Create((T6)value);
            try
            {
                return Create((dynamic)value);
            }
            catch (RuntimeBinderException ex)
            {
                throw new ArgumentException(nameof(value), ex);
            }
        }

        static OneOf<T0, T1, T2, T3, T4, T5, T6> Create(T0 value) => new OneOf<T0, T1, T2, T3, T4, T5, T6>(value, typeof(T0));
        static OneOf<T0, T1, T2, T3, T4, T5, T6> Create(T1 value) => new OneOf<T0, T1, T2, T3, T4, T5, T6>(value, typeof(T1));
        static OneOf<T0, T1, T2, T3, T4, T5, T6> Create(T2 value) => new OneOf<T0, T1, T2, T3, T4, T5, T6>(value, typeof(T2));
        static OneOf<T0, T1, T2, T3, T4, T5, T6> Create(T3 value) => new OneOf<T0, T1, T2, T3, T4, T5, T6>(value, typeof(T3));
        static OneOf<T0, T1, T2, T3, T4, T5, T6> Create(T4 value) => new OneOf<T0, T1, T2, T3, T4, T5, T6>(value, typeof(T4));
        static OneOf<T0, T1, T2, T3, T4, T5, T6> Create(T5 value) => new OneOf<T0, T1, T2, T3, T4, T5, T6>(value, typeof(T5));
        static OneOf<T0, T1, T2, T3, T4, T5, T6> Create(T6 value) => new OneOf<T0, T1, T2, T3, T4, T5, T6>(value, typeof(T6));

        public OneOf<N0, N1, N2, N3, N4, N5, N6> ToOneOf<N0, N1, N2, N3, N4, N5, N6>() => OneOf<N0, N1, N2, N3, N4, N5, N6>.CreateRaw(value);
        public OneOf<N0, N1, N2, N3, N4, N5, N6, N7> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7>() => OneOf<N0, N1, N2, N3, N4, N5, N6, N7>.CreateRaw(value);
        public OneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8>() => OneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8>.CreateRaw(value);

        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5, T6>(T0 value) => CreateRaw(value);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5, T6>(T1 value) => CreateRaw(value);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5, T6>(T2 value) => CreateRaw(value);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5, T6>(T3 value) => CreateRaw(value);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5, T6>(T4 value) => CreateRaw(value);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5, T6>(T5 value) => CreateRaw(value);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5, T6>(T6 value) => CreateRaw(value);

        public static bool operator ==(OneOf<T0, T1, T2, T3, T4, T5, T6> v1, IOneOf v2) => Equals(v1,v2);
        public static bool operator !=(OneOf<T0, T1, T2, T3, T4, T5, T6> v1, IOneOf v2) => !Equals(v1,v2);
        public static bool operator ==(OneOf<T0, T1, T2, T3, T4, T5, T6> v1, T0 v2) => Equals(v1,v2);
        public static bool operator !=(OneOf<T0, T1, T2, T3, T4, T5, T6> v1, T0 v2) => !Equals(v1,v2);
        public static bool operator ==(T0 v1, OneOf<T0, T1, T2, T3, T4, T5, T6> v2) => Equals(v2,v1);
        public static bool operator !=(T0 v1, OneOf<T0, T1, T2, T3, T4, T5, T6> v2) => !Equals(v2,v1);
        public static bool operator ==(OneOf<T0, T1, T2, T3, T4, T5, T6> v1, T1 v2) => Equals(v1,v2);
        public static bool operator !=(OneOf<T0, T1, T2, T3, T4, T5, T6> v1, T1 v2) => !Equals(v1,v2);
        public static bool operator ==(T1 v1, OneOf<T0, T1, T2, T3, T4, T5, T6> v2) => Equals(v2,v1);
        public static bool operator !=(T1 v1, OneOf<T0, T1, T2, T3, T4, T5, T6> v2) => !Equals(v2,v1);
        public static bool operator ==(OneOf<T0, T1, T2, T3, T4, T5, T6> v1, T2 v2) => Equals(v1,v2);
        public static bool operator !=(OneOf<T0, T1, T2, T3, T4, T5, T6> v1, T2 v2) => !Equals(v1,v2);
        public static bool operator ==(T2 v1, OneOf<T0, T1, T2, T3, T4, T5, T6> v2) => Equals(v2,v1);
        public static bool operator !=(T2 v1, OneOf<T0, T1, T2, T3, T4, T5, T6> v2) => !Equals(v2,v1);
        public static bool operator ==(OneOf<T0, T1, T2, T3, T4, T5, T6> v1, T3 v2) => Equals(v1,v2);
        public static bool operator !=(OneOf<T0, T1, T2, T3, T4, T5, T6> v1, T3 v2) => !Equals(v1,v2);
        public static bool operator ==(T3 v1, OneOf<T0, T1, T2, T3, T4, T5, T6> v2) => Equals(v2,v1);
        public static bool operator !=(T3 v1, OneOf<T0, T1, T2, T3, T4, T5, T6> v2) => !Equals(v2,v1);
        public static bool operator ==(OneOf<T0, T1, T2, T3, T4, T5, T6> v1, T4 v2) => Equals(v1,v2);
        public static bool operator !=(OneOf<T0, T1, T2, T3, T4, T5, T6> v1, T4 v2) => !Equals(v1,v2);
        public static bool operator ==(T4 v1, OneOf<T0, T1, T2, T3, T4, T5, T6> v2) => Equals(v2,v1);
        public static bool operator !=(T4 v1, OneOf<T0, T1, T2, T3, T4, T5, T6> v2) => !Equals(v2,v1);
        public static bool operator ==(OneOf<T0, T1, T2, T3, T4, T5, T6> v1, T5 v2) => Equals(v1,v2);
        public static bool operator !=(OneOf<T0, T1, T2, T3, T4, T5, T6> v1, T5 v2) => !Equals(v1,v2);
        public static bool operator ==(T5 v1, OneOf<T0, T1, T2, T3, T4, T5, T6> v2) => Equals(v2,v1);
        public static bool operator !=(T5 v1, OneOf<T0, T1, T2, T3, T4, T5, T6> v2) => !Equals(v2,v1);
        public static bool operator ==(OneOf<T0, T1, T2, T3, T4, T5, T6> v1, T6 v2) => Equals(v1,v2);
        public static bool operator !=(OneOf<T0, T1, T2, T3, T4, T5, T6> v1, T6 v2) => !Equals(v1,v2);
        public static bool operator ==(T6 v1, OneOf<T0, T1, T2, T3, T4, T5, T6> v2) => Equals(v2,v1);
        public static bool operator !=(T6 v1, OneOf<T0, T1, T2, T3, T4, T5, T6> v2) => !Equals(v2,v1);

        public OneOfSwitcher<T1, T2, T3, T4, T5, T6> Switch(Action<T0> action) => new OneOfSwitcher<T0, T1, T2, T3, T4, T5, T6>(value, origType).Switch(action);
        public OneOfSwitcher<T0, T2, T3, T4, T5, T6> Switch(Action<T1> action) => new OneOfSwitcher<T0, T1, T2, T3, T4, T5, T6>(value, origType).Switch(action);
        public OneOfSwitcher<T0, T1, T3, T4, T5, T6> Switch(Action<T2> action) => new OneOfSwitcher<T0, T1, T2, T3, T4, T5, T6>(value, origType).Switch(action);
        public OneOfSwitcher<T0, T1, T2, T4, T5, T6> Switch(Action<T3> action) => new OneOfSwitcher<T0, T1, T2, T3, T4, T5, T6>(value, origType).Switch(action);
        public OneOfSwitcher<T0, T1, T2, T3, T5, T6> Switch(Action<T4> action) => new OneOfSwitcher<T0, T1, T2, T3, T4, T5, T6>(value, origType).Switch(action);
        public OneOfSwitcher<T0, T1, T2, T3, T4, T6> Switch(Action<T5> action) => new OneOfSwitcher<T0, T1, T2, T3, T4, T5, T6>(value, origType).Switch(action);
        public OneOfSwitcher<T0, T1, T2, T3, T4, T5> Switch(Action<T6> action) => new OneOfSwitcher<T0, T1, T2, T3, T4, T5, T6>(value, origType).Switch(action);

        public OneOfMatcher<T1, T2, T3, T4, T5, T6, TResult> Match<TResult>(Func<T0, TResult> func) => new OneOfMatcher<T0, T1, T2, T3, T4, T5, T6, TResult>(value, origType).Match(func);
        public OneOfMatcher<T0, T2, T3, T4, T5, T6, TResult> Match<TResult>(Func<T1, TResult> func) => new OneOfMatcher<T0, T1, T2, T3, T4, T5, T6, TResult>(value, origType).Match(func);
        public OneOfMatcher<T0, T1, T3, T4, T5, T6, TResult> Match<TResult>(Func<T2, TResult> func) => new OneOfMatcher<T0, T1, T2, T3, T4, T5, T6, TResult>(value, origType).Match(func);
        public OneOfMatcher<T0, T1, T2, T4, T5, T6, TResult> Match<TResult>(Func<T3, TResult> func) => new OneOfMatcher<T0, T1, T2, T3, T4, T5, T6, TResult>(value, origType).Match(func);
        public OneOfMatcher<T0, T1, T2, T3, T5, T6, TResult> Match<TResult>(Func<T4, TResult> func) => new OneOfMatcher<T0, T1, T2, T3, T4, T5, T6, TResult>(value, origType).Match(func);
        public OneOfMatcher<T0, T1, T2, T3, T4, T6, TResult> Match<TResult>(Func<T5, TResult> func) => new OneOfMatcher<T0, T1, T2, T3, T4, T5, T6, TResult>(value, origType).Match(func);
        public OneOfMatcher<T0, T1, T2, T3, T4, T5, TResult> Match<TResult>(Func<T6, TResult> func) => new OneOfMatcher<T0, T1, T2, T3, T4, T5, T6, TResult>(value, origType).Match(func);

        public override bool Equals(object obj) => (obj is IOneOf) && Equals(value, ((IOneOf)obj).Value) || value.Equals(obj);
        public override int GetHashCode() => (value?.GetHashCode() ?? origType?.GetHashCode() ?? 0);
        public override string ToString() => (value?.ToString() ?? "");
    }
    public struct OneOf<T0, T1, T2, T3, T4, T5, T6, T7> : IOneOf
    {
        private readonly object value;
        private readonly Type origType;

        OneOf(object value, Type origType)
        {
            this.value = value;
            this.origType = origType;
        }

        object IOneOf.Value => value;

        internal static OneOf<T0, T1, T2, T3, T4, T5, T6, T7> CreateRaw(object value)
        {
            if (value == null) throw new ArgumentNullException(nameof(value));
            if (value.GetType() == typeof(T0)) return Create((T0)value);
            if (value.GetType() == typeof(T1)) return Create((T1)value);
            if (value.GetType() == typeof(T2)) return Create((T2)value);
            if (value.GetType() == typeof(T3)) return Create((T3)value);
            if (value.GetType() == typeof(T4)) return Create((T4)value);
            if (value.GetType() == typeof(T5)) return Create((T5)value);
            if (value.GetType() == typeof(T6)) return Create((T6)value);
            if (value.GetType() == typeof(T7)) return Create((T7)value);
            try
            {
                return Create((dynamic)value);
            }
            catch (RuntimeBinderException ex)
            {
                throw new ArgumentException(nameof(value), ex);
            }
        }

        static OneOf<T0, T1, T2, T3, T4, T5, T6, T7> Create(T0 value) => new OneOf<T0, T1, T2, T3, T4, T5, T6, T7>(value, typeof(T0));
        static OneOf<T0, T1, T2, T3, T4, T5, T6, T7> Create(T1 value) => new OneOf<T0, T1, T2, T3, T4, T5, T6, T7>(value, typeof(T1));
        static OneOf<T0, T1, T2, T3, T4, T5, T6, T7> Create(T2 value) => new OneOf<T0, T1, T2, T3, T4, T5, T6, T7>(value, typeof(T2));
        static OneOf<T0, T1, T2, T3, T4, T5, T6, T7> Create(T3 value) => new OneOf<T0, T1, T2, T3, T4, T5, T6, T7>(value, typeof(T3));
        static OneOf<T0, T1, T2, T3, T4, T5, T6, T7> Create(T4 value) => new OneOf<T0, T1, T2, T3, T4, T5, T6, T7>(value, typeof(T4));
        static OneOf<T0, T1, T2, T3, T4, T5, T6, T7> Create(T5 value) => new OneOf<T0, T1, T2, T3, T4, T5, T6, T7>(value, typeof(T5));
        static OneOf<T0, T1, T2, T3, T4, T5, T6, T7> Create(T6 value) => new OneOf<T0, T1, T2, T3, T4, T5, T6, T7>(value, typeof(T6));
        static OneOf<T0, T1, T2, T3, T4, T5, T6, T7> Create(T7 value) => new OneOf<T0, T1, T2, T3, T4, T5, T6, T7>(value, typeof(T7));

        public OneOf<N0, N1, N2, N3, N4, N5, N6, N7> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7>() => OneOf<N0, N1, N2, N3, N4, N5, N6, N7>.CreateRaw(value);
        public OneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8>() => OneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8>.CreateRaw(value);

        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5, T6, T7>(T0 value) => CreateRaw(value);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5, T6, T7>(T1 value) => CreateRaw(value);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5, T6, T7>(T2 value) => CreateRaw(value);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5, T6, T7>(T3 value) => CreateRaw(value);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5, T6, T7>(T4 value) => CreateRaw(value);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5, T6, T7>(T5 value) => CreateRaw(value);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5, T6, T7>(T6 value) => CreateRaw(value);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5, T6, T7>(T7 value) => CreateRaw(value);

        public static bool operator ==(OneOf<T0, T1, T2, T3, T4, T5, T6, T7> v1, IOneOf v2) => Equals(v1,v2);
        public static bool operator !=(OneOf<T0, T1, T2, T3, T4, T5, T6, T7> v1, IOneOf v2) => !Equals(v1,v2);
        public static bool operator ==(OneOf<T0, T1, T2, T3, T4, T5, T6, T7> v1, T0 v2) => Equals(v1,v2);
        public static bool operator !=(OneOf<T0, T1, T2, T3, T4, T5, T6, T7> v1, T0 v2) => !Equals(v1,v2);
        public static bool operator ==(T0 v1, OneOf<T0, T1, T2, T3, T4, T5, T6, T7> v2) => Equals(v2,v1);
        public static bool operator !=(T0 v1, OneOf<T0, T1, T2, T3, T4, T5, T6, T7> v2) => !Equals(v2,v1);
        public static bool operator ==(OneOf<T0, T1, T2, T3, T4, T5, T6, T7> v1, T1 v2) => Equals(v1,v2);
        public static bool operator !=(OneOf<T0, T1, T2, T3, T4, T5, T6, T7> v1, T1 v2) => !Equals(v1,v2);
        public static bool operator ==(T1 v1, OneOf<T0, T1, T2, T3, T4, T5, T6, T7> v2) => Equals(v2,v1);
        public static bool operator !=(T1 v1, OneOf<T0, T1, T2, T3, T4, T5, T6, T7> v2) => !Equals(v2,v1);
        public static bool operator ==(OneOf<T0, T1, T2, T3, T4, T5, T6, T7> v1, T2 v2) => Equals(v1,v2);
        public static bool operator !=(OneOf<T0, T1, T2, T3, T4, T5, T6, T7> v1, T2 v2) => !Equals(v1,v2);
        public static bool operator ==(T2 v1, OneOf<T0, T1, T2, T3, T4, T5, T6, T7> v2) => Equals(v2,v1);
        public static bool operator !=(T2 v1, OneOf<T0, T1, T2, T3, T4, T5, T6, T7> v2) => !Equals(v2,v1);
        public static bool operator ==(OneOf<T0, T1, T2, T3, T4, T5, T6, T7> v1, T3 v2) => Equals(v1,v2);
        public static bool operator !=(OneOf<T0, T1, T2, T3, T4, T5, T6, T7> v1, T3 v2) => !Equals(v1,v2);
        public static bool operator ==(T3 v1, OneOf<T0, T1, T2, T3, T4, T5, T6, T7> v2) => Equals(v2,v1);
        public static bool operator !=(T3 v1, OneOf<T0, T1, T2, T3, T4, T5, T6, T7> v2) => !Equals(v2,v1);
        public static bool operator ==(OneOf<T0, T1, T2, T3, T4, T5, T6, T7> v1, T4 v2) => Equals(v1,v2);
        public static bool operator !=(OneOf<T0, T1, T2, T3, T4, T5, T6, T7> v1, T4 v2) => !Equals(v1,v2);
        public static bool operator ==(T4 v1, OneOf<T0, T1, T2, T3, T4, T5, T6, T7> v2) => Equals(v2,v1);
        public static bool operator !=(T4 v1, OneOf<T0, T1, T2, T3, T4, T5, T6, T7> v2) => !Equals(v2,v1);
        public static bool operator ==(OneOf<T0, T1, T2, T3, T4, T5, T6, T7> v1, T5 v2) => Equals(v1,v2);
        public static bool operator !=(OneOf<T0, T1, T2, T3, T4, T5, T6, T7> v1, T5 v2) => !Equals(v1,v2);
        public static bool operator ==(T5 v1, OneOf<T0, T1, T2, T3, T4, T5, T6, T7> v2) => Equals(v2,v1);
        public static bool operator !=(T5 v1, OneOf<T0, T1, T2, T3, T4, T5, T6, T7> v2) => !Equals(v2,v1);
        public static bool operator ==(OneOf<T0, T1, T2, T3, T4, T5, T6, T7> v1, T6 v2) => Equals(v1,v2);
        public static bool operator !=(OneOf<T0, T1, T2, T3, T4, T5, T6, T7> v1, T6 v2) => !Equals(v1,v2);
        public static bool operator ==(T6 v1, OneOf<T0, T1, T2, T3, T4, T5, T6, T7> v2) => Equals(v2,v1);
        public static bool operator !=(T6 v1, OneOf<T0, T1, T2, T3, T4, T5, T6, T7> v2) => !Equals(v2,v1);
        public static bool operator ==(OneOf<T0, T1, T2, T3, T4, T5, T6, T7> v1, T7 v2) => Equals(v1,v2);
        public static bool operator !=(OneOf<T0, T1, T2, T3, T4, T5, T6, T7> v1, T7 v2) => !Equals(v1,v2);
        public static bool operator ==(T7 v1, OneOf<T0, T1, T2, T3, T4, T5, T6, T7> v2) => Equals(v2,v1);
        public static bool operator !=(T7 v1, OneOf<T0, T1, T2, T3, T4, T5, T6, T7> v2) => !Equals(v2,v1);

        public OneOfSwitcher<T1, T2, T3, T4, T5, T6, T7> Switch(Action<T0> action) => new OneOfSwitcher<T0, T1, T2, T3, T4, T5, T6, T7>(value, origType).Switch(action);
        public OneOfSwitcher<T0, T2, T3, T4, T5, T6, T7> Switch(Action<T1> action) => new OneOfSwitcher<T0, T1, T2, T3, T4, T5, T6, T7>(value, origType).Switch(action);
        public OneOfSwitcher<T0, T1, T3, T4, T5, T6, T7> Switch(Action<T2> action) => new OneOfSwitcher<T0, T1, T2, T3, T4, T5, T6, T7>(value, origType).Switch(action);
        public OneOfSwitcher<T0, T1, T2, T4, T5, T6, T7> Switch(Action<T3> action) => new OneOfSwitcher<T0, T1, T2, T3, T4, T5, T6, T7>(value, origType).Switch(action);
        public OneOfSwitcher<T0, T1, T2, T3, T5, T6, T7> Switch(Action<T4> action) => new OneOfSwitcher<T0, T1, T2, T3, T4, T5, T6, T7>(value, origType).Switch(action);
        public OneOfSwitcher<T0, T1, T2, T3, T4, T6, T7> Switch(Action<T5> action) => new OneOfSwitcher<T0, T1, T2, T3, T4, T5, T6, T7>(value, origType).Switch(action);
        public OneOfSwitcher<T0, T1, T2, T3, T4, T5, T7> Switch(Action<T6> action) => new OneOfSwitcher<T0, T1, T2, T3, T4, T5, T6, T7>(value, origType).Switch(action);
        public OneOfSwitcher<T0, T1, T2, T3, T4, T5, T6> Switch(Action<T7> action) => new OneOfSwitcher<T0, T1, T2, T3, T4, T5, T6, T7>(value, origType).Switch(action);

        public OneOfMatcher<T1, T2, T3, T4, T5, T6, T7, TResult> Match<TResult>(Func<T0, TResult> func) => new OneOfMatcher<T0, T1, T2, T3, T4, T5, T6, T7, TResult>(value, origType).Match(func);
        public OneOfMatcher<T0, T2, T3, T4, T5, T6, T7, TResult> Match<TResult>(Func<T1, TResult> func) => new OneOfMatcher<T0, T1, T2, T3, T4, T5, T6, T7, TResult>(value, origType).Match(func);
        public OneOfMatcher<T0, T1, T3, T4, T5, T6, T7, TResult> Match<TResult>(Func<T2, TResult> func) => new OneOfMatcher<T0, T1, T2, T3, T4, T5, T6, T7, TResult>(value, origType).Match(func);
        public OneOfMatcher<T0, T1, T2, T4, T5, T6, T7, TResult> Match<TResult>(Func<T3, TResult> func) => new OneOfMatcher<T0, T1, T2, T3, T4, T5, T6, T7, TResult>(value, origType).Match(func);
        public OneOfMatcher<T0, T1, T2, T3, T5, T6, T7, TResult> Match<TResult>(Func<T4, TResult> func) => new OneOfMatcher<T0, T1, T2, T3, T4, T5, T6, T7, TResult>(value, origType).Match(func);
        public OneOfMatcher<T0, T1, T2, T3, T4, T6, T7, TResult> Match<TResult>(Func<T5, TResult> func) => new OneOfMatcher<T0, T1, T2, T3, T4, T5, T6, T7, TResult>(value, origType).Match(func);
        public OneOfMatcher<T0, T1, T2, T3, T4, T5, T7, TResult> Match<TResult>(Func<T6, TResult> func) => new OneOfMatcher<T0, T1, T2, T3, T4, T5, T6, T7, TResult>(value, origType).Match(func);
        public OneOfMatcher<T0, T1, T2, T3, T4, T5, T6, TResult> Match<TResult>(Func<T7, TResult> func) => new OneOfMatcher<T0, T1, T2, T3, T4, T5, T6, T7, TResult>(value, origType).Match(func);

        public override bool Equals(object obj) => (obj is IOneOf) && Equals(value, ((IOneOf)obj).Value) || value.Equals(obj);
        public override int GetHashCode() => (value?.GetHashCode() ?? origType?.GetHashCode() ?? 0);
        public override string ToString() => (value?.ToString() ?? "");
    }
    public struct OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8> : IOneOf
    {
        private readonly object value;
        private readonly Type origType;

        OneOf(object value, Type origType)
        {
            this.value = value;
            this.origType = origType;
        }

        object IOneOf.Value => value;

        internal static OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8> CreateRaw(object value)
        {
            if (value == null) throw new ArgumentNullException(nameof(value));
            if (value.GetType() == typeof(T0)) return Create((T0)value);
            if (value.GetType() == typeof(T1)) return Create((T1)value);
            if (value.GetType() == typeof(T2)) return Create((T2)value);
            if (value.GetType() == typeof(T3)) return Create((T3)value);
            if (value.GetType() == typeof(T4)) return Create((T4)value);
            if (value.GetType() == typeof(T5)) return Create((T5)value);
            if (value.GetType() == typeof(T6)) return Create((T6)value);
            if (value.GetType() == typeof(T7)) return Create((T7)value);
            if (value.GetType() == typeof(T8)) return Create((T8)value);
            try
            {
                return Create((dynamic)value);
            }
            catch (RuntimeBinderException ex)
            {
                throw new ArgumentException(nameof(value), ex);
            }
        }

        static OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8> Create(T0 value) => new OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8>(value, typeof(T0));
        static OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8> Create(T1 value) => new OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8>(value, typeof(T1));
        static OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8> Create(T2 value) => new OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8>(value, typeof(T2));
        static OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8> Create(T3 value) => new OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8>(value, typeof(T3));
        static OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8> Create(T4 value) => new OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8>(value, typeof(T4));
        static OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8> Create(T5 value) => new OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8>(value, typeof(T5));
        static OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8> Create(T6 value) => new OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8>(value, typeof(T6));
        static OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8> Create(T7 value) => new OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8>(value, typeof(T7));
        static OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8> Create(T8 value) => new OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8>(value, typeof(T8));

        public OneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8>() => OneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8>.CreateRaw(value);

        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8>(T0 value) => CreateRaw(value);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8>(T1 value) => CreateRaw(value);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8>(T2 value) => CreateRaw(value);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8>(T3 value) => CreateRaw(value);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8>(T4 value) => CreateRaw(value);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8>(T5 value) => CreateRaw(value);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8>(T6 value) => CreateRaw(value);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8>(T7 value) => CreateRaw(value);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8>(T8 value) => CreateRaw(value);

        public static bool operator ==(OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8> v1, IOneOf v2) => Equals(v1,v2);
        public static bool operator !=(OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8> v1, IOneOf v2) => !Equals(v1,v2);
        public static bool operator ==(OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8> v1, T0 v2) => Equals(v1,v2);
        public static bool operator !=(OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8> v1, T0 v2) => !Equals(v1,v2);
        public static bool operator ==(T0 v1, OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8> v2) => Equals(v2,v1);
        public static bool operator !=(T0 v1, OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8> v2) => !Equals(v2,v1);
        public static bool operator ==(OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8> v1, T1 v2) => Equals(v1,v2);
        public static bool operator !=(OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8> v1, T1 v2) => !Equals(v1,v2);
        public static bool operator ==(T1 v1, OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8> v2) => Equals(v2,v1);
        public static bool operator !=(T1 v1, OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8> v2) => !Equals(v2,v1);
        public static bool operator ==(OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8> v1, T2 v2) => Equals(v1,v2);
        public static bool operator !=(OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8> v1, T2 v2) => !Equals(v1,v2);
        public static bool operator ==(T2 v1, OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8> v2) => Equals(v2,v1);
        public static bool operator !=(T2 v1, OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8> v2) => !Equals(v2,v1);
        public static bool operator ==(OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8> v1, T3 v2) => Equals(v1,v2);
        public static bool operator !=(OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8> v1, T3 v2) => !Equals(v1,v2);
        public static bool operator ==(T3 v1, OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8> v2) => Equals(v2,v1);
        public static bool operator !=(T3 v1, OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8> v2) => !Equals(v2,v1);
        public static bool operator ==(OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8> v1, T4 v2) => Equals(v1,v2);
        public static bool operator !=(OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8> v1, T4 v2) => !Equals(v1,v2);
        public static bool operator ==(T4 v1, OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8> v2) => Equals(v2,v1);
        public static bool operator !=(T4 v1, OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8> v2) => !Equals(v2,v1);
        public static bool operator ==(OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8> v1, T5 v2) => Equals(v1,v2);
        public static bool operator !=(OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8> v1, T5 v2) => !Equals(v1,v2);
        public static bool operator ==(T5 v1, OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8> v2) => Equals(v2,v1);
        public static bool operator !=(T5 v1, OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8> v2) => !Equals(v2,v1);
        public static bool operator ==(OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8> v1, T6 v2) => Equals(v1,v2);
        public static bool operator !=(OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8> v1, T6 v2) => !Equals(v1,v2);
        public static bool operator ==(T6 v1, OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8> v2) => Equals(v2,v1);
        public static bool operator !=(T6 v1, OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8> v2) => !Equals(v2,v1);
        public static bool operator ==(OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8> v1, T7 v2) => Equals(v1,v2);
        public static bool operator !=(OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8> v1, T7 v2) => !Equals(v1,v2);
        public static bool operator ==(T7 v1, OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8> v2) => Equals(v2,v1);
        public static bool operator !=(T7 v1, OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8> v2) => !Equals(v2,v1);
        public static bool operator ==(OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8> v1, T8 v2) => Equals(v1,v2);
        public static bool operator !=(OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8> v1, T8 v2) => !Equals(v1,v2);
        public static bool operator ==(T8 v1, OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8> v2) => Equals(v2,v1);
        public static bool operator !=(T8 v1, OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8> v2) => !Equals(v2,v1);

        public OneOfSwitcher<T1, T2, T3, T4, T5, T6, T7, T8> Switch(Action<T0> action) => new OneOfSwitcher<T0, T1, T2, T3, T4, T5, T6, T7, T8>(value, origType).Switch(action);
        public OneOfSwitcher<T0, T2, T3, T4, T5, T6, T7, T8> Switch(Action<T1> action) => new OneOfSwitcher<T0, T1, T2, T3, T4, T5, T6, T7, T8>(value, origType).Switch(action);
        public OneOfSwitcher<T0, T1, T3, T4, T5, T6, T7, T8> Switch(Action<T2> action) => new OneOfSwitcher<T0, T1, T2, T3, T4, T5, T6, T7, T8>(value, origType).Switch(action);
        public OneOfSwitcher<T0, T1, T2, T4, T5, T6, T7, T8> Switch(Action<T3> action) => new OneOfSwitcher<T0, T1, T2, T3, T4, T5, T6, T7, T8>(value, origType).Switch(action);
        public OneOfSwitcher<T0, T1, T2, T3, T5, T6, T7, T8> Switch(Action<T4> action) => new OneOfSwitcher<T0, T1, T2, T3, T4, T5, T6, T7, T8>(value, origType).Switch(action);
        public OneOfSwitcher<T0, T1, T2, T3, T4, T6, T7, T8> Switch(Action<T5> action) => new OneOfSwitcher<T0, T1, T2, T3, T4, T5, T6, T7, T8>(value, origType).Switch(action);
        public OneOfSwitcher<T0, T1, T2, T3, T4, T5, T7, T8> Switch(Action<T6> action) => new OneOfSwitcher<T0, T1, T2, T3, T4, T5, T6, T7, T8>(value, origType).Switch(action);
        public OneOfSwitcher<T0, T1, T2, T3, T4, T5, T6, T8> Switch(Action<T7> action) => new OneOfSwitcher<T0, T1, T2, T3, T4, T5, T6, T7, T8>(value, origType).Switch(action);
        public OneOfSwitcher<T0, T1, T2, T3, T4, T5, T6, T7> Switch(Action<T8> action) => new OneOfSwitcher<T0, T1, T2, T3, T4, T5, T6, T7, T8>(value, origType).Switch(action);

        public OneOfMatcher<T1, T2, T3, T4, T5, T6, T7, T8, TResult> Match<TResult>(Func<T0, TResult> func) => new OneOfMatcher<T0, T1, T2, T3, T4, T5, T6, T7, T8, TResult>(value, origType).Match(func);
        public OneOfMatcher<T0, T2, T3, T4, T5, T6, T7, T8, TResult> Match<TResult>(Func<T1, TResult> func) => new OneOfMatcher<T0, T1, T2, T3, T4, T5, T6, T7, T8, TResult>(value, origType).Match(func);
        public OneOfMatcher<T0, T1, T3, T4, T5, T6, T7, T8, TResult> Match<TResult>(Func<T2, TResult> func) => new OneOfMatcher<T0, T1, T2, T3, T4, T5, T6, T7, T8, TResult>(value, origType).Match(func);
        public OneOfMatcher<T0, T1, T2, T4, T5, T6, T7, T8, TResult> Match<TResult>(Func<T3, TResult> func) => new OneOfMatcher<T0, T1, T2, T3, T4, T5, T6, T7, T8, TResult>(value, origType).Match(func);
        public OneOfMatcher<T0, T1, T2, T3, T5, T6, T7, T8, TResult> Match<TResult>(Func<T4, TResult> func) => new OneOfMatcher<T0, T1, T2, T3, T4, T5, T6, T7, T8, TResult>(value, origType).Match(func);
        public OneOfMatcher<T0, T1, T2, T3, T4, T6, T7, T8, TResult> Match<TResult>(Func<T5, TResult> func) => new OneOfMatcher<T0, T1, T2, T3, T4, T5, T6, T7, T8, TResult>(value, origType).Match(func);
        public OneOfMatcher<T0, T1, T2, T3, T4, T5, T7, T8, TResult> Match<TResult>(Func<T6, TResult> func) => new OneOfMatcher<T0, T1, T2, T3, T4, T5, T6, T7, T8, TResult>(value, origType).Match(func);
        public OneOfMatcher<T0, T1, T2, T3, T4, T5, T6, T8, TResult> Match<TResult>(Func<T7, TResult> func) => new OneOfMatcher<T0, T1, T2, T3, T4, T5, T6, T7, T8, TResult>(value, origType).Match(func);
        public OneOfMatcher<T0, T1, T2, T3, T4, T5, T6, T7, TResult> Match<TResult>(Func<T8, TResult> func) => new OneOfMatcher<T0, T1, T2, T3, T4, T5, T6, T7, T8, TResult>(value, origType).Match(func);

        public override bool Equals(object obj) => (obj is IOneOf) && Equals(value, ((IOneOf)obj).Value) || value.Equals(obj);
        public override int GetHashCode() => (value?.GetHashCode() ?? origType?.GetHashCode() ?? 0);
        public override string ToString() => (value?.ToString() ?? "");
    }
    public class OneOfBase<T0, T1> : IOneOf
    {
        private readonly object value;
        private readonly Type origType;

        OneOfBase(object value, Type origType)
        {
            this.value = value;
            this.origType = origType;
        }

        protected OneOfBase()
        {
            this.value = this;
            this.origType = GetType();
        }

        object IOneOf.Value => value;

        internal static OneOfBase<T0, T1> CreateRaw(object value)
        {
            if (value == null) throw new ArgumentNullException(nameof(value));
            if (value.GetType() == typeof(T0)) return Create((T0)value);
            if (value.GetType() == typeof(T1)) return Create((T1)value);
            try
            {
                return Create((dynamic)value);
            }
            catch (RuntimeBinderException ex)
            {
                throw new ArgumentException(nameof(value), ex);
            }
        }

        static OneOfBase<T0, T1> Create(T0 value) => new OneOfBase<T0, T1>(value, typeof(T0));
        static OneOfBase<T0, T1> Create(T1 value) => new OneOfBase<T0, T1>(value, typeof(T1));

        public OneOfBase<N0, N1> ToOneOf<N0, N1>() => OneOfBase<N0, N1>.CreateRaw(value);
        public OneOfBase<N0, N1, N2> ToOneOf<N0, N1, N2>() => OneOfBase<N0, N1, N2>.CreateRaw(value);
        public OneOfBase<N0, N1, N2, N3> ToOneOf<N0, N1, N2, N3>() => OneOfBase<N0, N1, N2, N3>.CreateRaw(value);
        public OneOfBase<N0, N1, N2, N3, N4> ToOneOf<N0, N1, N2, N3, N4>() => OneOfBase<N0, N1, N2, N3, N4>.CreateRaw(value);
        public OneOfBase<N0, N1, N2, N3, N4, N5> ToOneOf<N0, N1, N2, N3, N4, N5>() => OneOfBase<N0, N1, N2, N3, N4, N5>.CreateRaw(value);
        public OneOfBase<N0, N1, N2, N3, N4, N5, N6> ToOneOf<N0, N1, N2, N3, N4, N5, N6>() => OneOfBase<N0, N1, N2, N3, N4, N5, N6>.CreateRaw(value);
        public OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7>() => OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7>.CreateRaw(value);
        public OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7, N8> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8>() => OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7, N8>.CreateRaw(value);

        public static implicit operator OneOfBase<T0, T1>(T0 value) => CreateRaw(value);
        public static implicit operator OneOfBase<T0, T1>(T1 value) => CreateRaw(value);

        public static bool operator ==(OneOfBase<T0, T1> v1, IOneOf v2) => Equals(v1,v2);
        public static bool operator !=(OneOfBase<T0, T1> v1, IOneOf v2) => !Equals(v1,v2);
        public static bool operator ==(OneOfBase<T0, T1> v1, T0 v2) => Equals(v1,v2);
        public static bool operator !=(OneOfBase<T0, T1> v1, T0 v2) => !Equals(v1,v2);
        public static bool operator ==(T0 v1, OneOfBase<T0, T1> v2) => Equals(v2,v1);
        public static bool operator !=(T0 v1, OneOfBase<T0, T1> v2) => !Equals(v2,v1);
        public static bool operator ==(OneOfBase<T0, T1> v1, T1 v2) => Equals(v1,v2);
        public static bool operator !=(OneOfBase<T0, T1> v1, T1 v2) => !Equals(v1,v2);
        public static bool operator ==(T1 v1, OneOfBase<T0, T1> v2) => Equals(v2,v1);
        public static bool operator !=(T1 v1, OneOfBase<T0, T1> v2) => !Equals(v2,v1);

        public OneOfSwitcher<T1> Switch(Action<T0> action) => new OneOfSwitcher<T0, T1>(value, origType).Switch(action);
        public OneOfSwitcher<T0> Switch(Action<T1> action) => new OneOfSwitcher<T0, T1>(value, origType).Switch(action);

        public OneOfMatcher<T1, TResult> Match<TResult>(Func<T0, TResult> func) => new OneOfMatcher<T0, T1, TResult>(value, origType).Match(func);
        public OneOfMatcher<T0, TResult> Match<TResult>(Func<T1, TResult> func) => new OneOfMatcher<T0, T1, TResult>(value, origType).Match(func);

        public override bool Equals(object obj) => (obj is IOneOf) && Equals(value, ((IOneOf)obj).Value) || value.Equals(obj);
        public override int GetHashCode() => (value?.GetHashCode() ?? origType?.GetHashCode() ?? 0);
        public override string ToString() => (value?.ToString() ?? "");
    }
    public class OneOfBase<T0, T1, T2> : IOneOf
    {
        private readonly object value;
        private readonly Type origType;

        OneOfBase(object value, Type origType)
        {
            this.value = value;
            this.origType = origType;
        }

        protected OneOfBase()
        {
            this.value = this;
            this.origType = GetType();
        }

        object IOneOf.Value => value;

        internal static OneOfBase<T0, T1, T2> CreateRaw(object value)
        {
            if (value == null) throw new ArgumentNullException(nameof(value));
            if (value.GetType() == typeof(T0)) return Create((T0)value);
            if (value.GetType() == typeof(T1)) return Create((T1)value);
            if (value.GetType() == typeof(T2)) return Create((T2)value);
            try
            {
                return Create((dynamic)value);
            }
            catch (RuntimeBinderException ex)
            {
                throw new ArgumentException(nameof(value), ex);
            }
        }

        static OneOfBase<T0, T1, T2> Create(T0 value) => new OneOfBase<T0, T1, T2>(value, typeof(T0));
        static OneOfBase<T0, T1, T2> Create(T1 value) => new OneOfBase<T0, T1, T2>(value, typeof(T1));
        static OneOfBase<T0, T1, T2> Create(T2 value) => new OneOfBase<T0, T1, T2>(value, typeof(T2));

        public OneOfBase<N0, N1, N2> ToOneOf<N0, N1, N2>() => OneOfBase<N0, N1, N2>.CreateRaw(value);
        public OneOfBase<N0, N1, N2, N3> ToOneOf<N0, N1, N2, N3>() => OneOfBase<N0, N1, N2, N3>.CreateRaw(value);
        public OneOfBase<N0, N1, N2, N3, N4> ToOneOf<N0, N1, N2, N3, N4>() => OneOfBase<N0, N1, N2, N3, N4>.CreateRaw(value);
        public OneOfBase<N0, N1, N2, N3, N4, N5> ToOneOf<N0, N1, N2, N3, N4, N5>() => OneOfBase<N0, N1, N2, N3, N4, N5>.CreateRaw(value);
        public OneOfBase<N0, N1, N2, N3, N4, N5, N6> ToOneOf<N0, N1, N2, N3, N4, N5, N6>() => OneOfBase<N0, N1, N2, N3, N4, N5, N6>.CreateRaw(value);
        public OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7>() => OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7>.CreateRaw(value);
        public OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7, N8> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8>() => OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7, N8>.CreateRaw(value);

        public static implicit operator OneOfBase<T0, T1, T2>(T0 value) => CreateRaw(value);
        public static implicit operator OneOfBase<T0, T1, T2>(T1 value) => CreateRaw(value);
        public static implicit operator OneOfBase<T0, T1, T2>(T2 value) => CreateRaw(value);

        public static bool operator ==(OneOfBase<T0, T1, T2> v1, IOneOf v2) => Equals(v1,v2);
        public static bool operator !=(OneOfBase<T0, T1, T2> v1, IOneOf v2) => !Equals(v1,v2);
        public static bool operator ==(OneOfBase<T0, T1, T2> v1, T0 v2) => Equals(v1,v2);
        public static bool operator !=(OneOfBase<T0, T1, T2> v1, T0 v2) => !Equals(v1,v2);
        public static bool operator ==(T0 v1, OneOfBase<T0, T1, T2> v2) => Equals(v2,v1);
        public static bool operator !=(T0 v1, OneOfBase<T0, T1, T2> v2) => !Equals(v2,v1);
        public static bool operator ==(OneOfBase<T0, T1, T2> v1, T1 v2) => Equals(v1,v2);
        public static bool operator !=(OneOfBase<T0, T1, T2> v1, T1 v2) => !Equals(v1,v2);
        public static bool operator ==(T1 v1, OneOfBase<T0, T1, T2> v2) => Equals(v2,v1);
        public static bool operator !=(T1 v1, OneOfBase<T0, T1, T2> v2) => !Equals(v2,v1);
        public static bool operator ==(OneOfBase<T0, T1, T2> v1, T2 v2) => Equals(v1,v2);
        public static bool operator !=(OneOfBase<T0, T1, T2> v1, T2 v2) => !Equals(v1,v2);
        public static bool operator ==(T2 v1, OneOfBase<T0, T1, T2> v2) => Equals(v2,v1);
        public static bool operator !=(T2 v1, OneOfBase<T0, T1, T2> v2) => !Equals(v2,v1);

        public OneOfSwitcher<T1, T2> Switch(Action<T0> action) => new OneOfSwitcher<T0, T1, T2>(value, origType).Switch(action);
        public OneOfSwitcher<T0, T2> Switch(Action<T1> action) => new OneOfSwitcher<T0, T1, T2>(value, origType).Switch(action);
        public OneOfSwitcher<T0, T1> Switch(Action<T2> action) => new OneOfSwitcher<T0, T1, T2>(value, origType).Switch(action);

        public OneOfMatcher<T1, T2, TResult> Match<TResult>(Func<T0, TResult> func) => new OneOfMatcher<T0, T1, T2, TResult>(value, origType).Match(func);
        public OneOfMatcher<T0, T2, TResult> Match<TResult>(Func<T1, TResult> func) => new OneOfMatcher<T0, T1, T2, TResult>(value, origType).Match(func);
        public OneOfMatcher<T0, T1, TResult> Match<TResult>(Func<T2, TResult> func) => new OneOfMatcher<T0, T1, T2, TResult>(value, origType).Match(func);

        public override bool Equals(object obj) => (obj is IOneOf) && Equals(value, ((IOneOf)obj).Value) || value.Equals(obj);
        public override int GetHashCode() => (value?.GetHashCode() ?? origType?.GetHashCode() ?? 0);
        public override string ToString() => (value?.ToString() ?? "");
    }
    public class OneOfBase<T0, T1, T2, T3> : IOneOf
    {
        private readonly object value;
        private readonly Type origType;

        OneOfBase(object value, Type origType)
        {
            this.value = value;
            this.origType = origType;
        }

        protected OneOfBase()
        {
            this.value = this;
            this.origType = GetType();
        }

        object IOneOf.Value => value;

        internal static OneOfBase<T0, T1, T2, T3> CreateRaw(object value)
        {
            if (value == null) throw new ArgumentNullException(nameof(value));
            if (value.GetType() == typeof(T0)) return Create((T0)value);
            if (value.GetType() == typeof(T1)) return Create((T1)value);
            if (value.GetType() == typeof(T2)) return Create((T2)value);
            if (value.GetType() == typeof(T3)) return Create((T3)value);
            try
            {
                return Create((dynamic)value);
            }
            catch (RuntimeBinderException ex)
            {
                throw new ArgumentException(nameof(value), ex);
            }
        }

        static OneOfBase<T0, T1, T2, T3> Create(T0 value) => new OneOfBase<T0, T1, T2, T3>(value, typeof(T0));
        static OneOfBase<T0, T1, T2, T3> Create(T1 value) => new OneOfBase<T0, T1, T2, T3>(value, typeof(T1));
        static OneOfBase<T0, T1, T2, T3> Create(T2 value) => new OneOfBase<T0, T1, T2, T3>(value, typeof(T2));
        static OneOfBase<T0, T1, T2, T3> Create(T3 value) => new OneOfBase<T0, T1, T2, T3>(value, typeof(T3));

        public OneOfBase<N0, N1, N2, N3> ToOneOf<N0, N1, N2, N3>() => OneOfBase<N0, N1, N2, N3>.CreateRaw(value);
        public OneOfBase<N0, N1, N2, N3, N4> ToOneOf<N0, N1, N2, N3, N4>() => OneOfBase<N0, N1, N2, N3, N4>.CreateRaw(value);
        public OneOfBase<N0, N1, N2, N3, N4, N5> ToOneOf<N0, N1, N2, N3, N4, N5>() => OneOfBase<N0, N1, N2, N3, N4, N5>.CreateRaw(value);
        public OneOfBase<N0, N1, N2, N3, N4, N5, N6> ToOneOf<N0, N1, N2, N3, N4, N5, N6>() => OneOfBase<N0, N1, N2, N3, N4, N5, N6>.CreateRaw(value);
        public OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7>() => OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7>.CreateRaw(value);
        public OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7, N8> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8>() => OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7, N8>.CreateRaw(value);

        public static implicit operator OneOfBase<T0, T1, T2, T3>(T0 value) => CreateRaw(value);
        public static implicit operator OneOfBase<T0, T1, T2, T3>(T1 value) => CreateRaw(value);
        public static implicit operator OneOfBase<T0, T1, T2, T3>(T2 value) => CreateRaw(value);
        public static implicit operator OneOfBase<T0, T1, T2, T3>(T3 value) => CreateRaw(value);

        public static bool operator ==(OneOfBase<T0, T1, T2, T3> v1, IOneOf v2) => Equals(v1,v2);
        public static bool operator !=(OneOfBase<T0, T1, T2, T3> v1, IOneOf v2) => !Equals(v1,v2);
        public static bool operator ==(OneOfBase<T0, T1, T2, T3> v1, T0 v2) => Equals(v1,v2);
        public static bool operator !=(OneOfBase<T0, T1, T2, T3> v1, T0 v2) => !Equals(v1,v2);
        public static bool operator ==(T0 v1, OneOfBase<T0, T1, T2, T3> v2) => Equals(v2,v1);
        public static bool operator !=(T0 v1, OneOfBase<T0, T1, T2, T3> v2) => !Equals(v2,v1);
        public static bool operator ==(OneOfBase<T0, T1, T2, T3> v1, T1 v2) => Equals(v1,v2);
        public static bool operator !=(OneOfBase<T0, T1, T2, T3> v1, T1 v2) => !Equals(v1,v2);
        public static bool operator ==(T1 v1, OneOfBase<T0, T1, T2, T3> v2) => Equals(v2,v1);
        public static bool operator !=(T1 v1, OneOfBase<T0, T1, T2, T3> v2) => !Equals(v2,v1);
        public static bool operator ==(OneOfBase<T0, T1, T2, T3> v1, T2 v2) => Equals(v1,v2);
        public static bool operator !=(OneOfBase<T0, T1, T2, T3> v1, T2 v2) => !Equals(v1,v2);
        public static bool operator ==(T2 v1, OneOfBase<T0, T1, T2, T3> v2) => Equals(v2,v1);
        public static bool operator !=(T2 v1, OneOfBase<T0, T1, T2, T3> v2) => !Equals(v2,v1);
        public static bool operator ==(OneOfBase<T0, T1, T2, T3> v1, T3 v2) => Equals(v1,v2);
        public static bool operator !=(OneOfBase<T0, T1, T2, T3> v1, T3 v2) => !Equals(v1,v2);
        public static bool operator ==(T3 v1, OneOfBase<T0, T1, T2, T3> v2) => Equals(v2,v1);
        public static bool operator !=(T3 v1, OneOfBase<T0, T1, T2, T3> v2) => !Equals(v2,v1);

        public OneOfSwitcher<T1, T2, T3> Switch(Action<T0> action) => new OneOfSwitcher<T0, T1, T2, T3>(value, origType).Switch(action);
        public OneOfSwitcher<T0, T2, T3> Switch(Action<T1> action) => new OneOfSwitcher<T0, T1, T2, T3>(value, origType).Switch(action);
        public OneOfSwitcher<T0, T1, T3> Switch(Action<T2> action) => new OneOfSwitcher<T0, T1, T2, T3>(value, origType).Switch(action);
        public OneOfSwitcher<T0, T1, T2> Switch(Action<T3> action) => new OneOfSwitcher<T0, T1, T2, T3>(value, origType).Switch(action);

        public OneOfMatcher<T1, T2, T3, TResult> Match<TResult>(Func<T0, TResult> func) => new OneOfMatcher<T0, T1, T2, T3, TResult>(value, origType).Match(func);
        public OneOfMatcher<T0, T2, T3, TResult> Match<TResult>(Func<T1, TResult> func) => new OneOfMatcher<T0, T1, T2, T3, TResult>(value, origType).Match(func);
        public OneOfMatcher<T0, T1, T3, TResult> Match<TResult>(Func<T2, TResult> func) => new OneOfMatcher<T0, T1, T2, T3, TResult>(value, origType).Match(func);
        public OneOfMatcher<T0, T1, T2, TResult> Match<TResult>(Func<T3, TResult> func) => new OneOfMatcher<T0, T1, T2, T3, TResult>(value, origType).Match(func);

        public override bool Equals(object obj) => (obj is IOneOf) && Equals(value, ((IOneOf)obj).Value) || value.Equals(obj);
        public override int GetHashCode() => (value?.GetHashCode() ?? origType?.GetHashCode() ?? 0);
        public override string ToString() => (value?.ToString() ?? "");
    }
    public class OneOfBase<T0, T1, T2, T3, T4> : IOneOf
    {
        private readonly object value;
        private readonly Type origType;

        OneOfBase(object value, Type origType)
        {
            this.value = value;
            this.origType = origType;
        }

        protected OneOfBase()
        {
            this.value = this;
            this.origType = GetType();
        }

        object IOneOf.Value => value;

        internal static OneOfBase<T0, T1, T2, T3, T4> CreateRaw(object value)
        {
            if (value == null) throw new ArgumentNullException(nameof(value));
            if (value.GetType() == typeof(T0)) return Create((T0)value);
            if (value.GetType() == typeof(T1)) return Create((T1)value);
            if (value.GetType() == typeof(T2)) return Create((T2)value);
            if (value.GetType() == typeof(T3)) return Create((T3)value);
            if (value.GetType() == typeof(T4)) return Create((T4)value);
            try
            {
                return Create((dynamic)value);
            }
            catch (RuntimeBinderException ex)
            {
                throw new ArgumentException(nameof(value), ex);
            }
        }

        static OneOfBase<T0, T1, T2, T3, T4> Create(T0 value) => new OneOfBase<T0, T1, T2, T3, T4>(value, typeof(T0));
        static OneOfBase<T0, T1, T2, T3, T4> Create(T1 value) => new OneOfBase<T0, T1, T2, T3, T4>(value, typeof(T1));
        static OneOfBase<T0, T1, T2, T3, T4> Create(T2 value) => new OneOfBase<T0, T1, T2, T3, T4>(value, typeof(T2));
        static OneOfBase<T0, T1, T2, T3, T4> Create(T3 value) => new OneOfBase<T0, T1, T2, T3, T4>(value, typeof(T3));
        static OneOfBase<T0, T1, T2, T3, T4> Create(T4 value) => new OneOfBase<T0, T1, T2, T3, T4>(value, typeof(T4));

        public OneOfBase<N0, N1, N2, N3, N4> ToOneOf<N0, N1, N2, N3, N4>() => OneOfBase<N0, N1, N2, N3, N4>.CreateRaw(value);
        public OneOfBase<N0, N1, N2, N3, N4, N5> ToOneOf<N0, N1, N2, N3, N4, N5>() => OneOfBase<N0, N1, N2, N3, N4, N5>.CreateRaw(value);
        public OneOfBase<N0, N1, N2, N3, N4, N5, N6> ToOneOf<N0, N1, N2, N3, N4, N5, N6>() => OneOfBase<N0, N1, N2, N3, N4, N5, N6>.CreateRaw(value);
        public OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7>() => OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7>.CreateRaw(value);
        public OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7, N8> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8>() => OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7, N8>.CreateRaw(value);

        public static implicit operator OneOfBase<T0, T1, T2, T3, T4>(T0 value) => CreateRaw(value);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4>(T1 value) => CreateRaw(value);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4>(T2 value) => CreateRaw(value);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4>(T3 value) => CreateRaw(value);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4>(T4 value) => CreateRaw(value);

        public static bool operator ==(OneOfBase<T0, T1, T2, T3, T4> v1, IOneOf v2) => Equals(v1,v2);
        public static bool operator !=(OneOfBase<T0, T1, T2, T3, T4> v1, IOneOf v2) => !Equals(v1,v2);
        public static bool operator ==(OneOfBase<T0, T1, T2, T3, T4> v1, T0 v2) => Equals(v1,v2);
        public static bool operator !=(OneOfBase<T0, T1, T2, T3, T4> v1, T0 v2) => !Equals(v1,v2);
        public static bool operator ==(T0 v1, OneOfBase<T0, T1, T2, T3, T4> v2) => Equals(v2,v1);
        public static bool operator !=(T0 v1, OneOfBase<T0, T1, T2, T3, T4> v2) => !Equals(v2,v1);
        public static bool operator ==(OneOfBase<T0, T1, T2, T3, T4> v1, T1 v2) => Equals(v1,v2);
        public static bool operator !=(OneOfBase<T0, T1, T2, T3, T4> v1, T1 v2) => !Equals(v1,v2);
        public static bool operator ==(T1 v1, OneOfBase<T0, T1, T2, T3, T4> v2) => Equals(v2,v1);
        public static bool operator !=(T1 v1, OneOfBase<T0, T1, T2, T3, T4> v2) => !Equals(v2,v1);
        public static bool operator ==(OneOfBase<T0, T1, T2, T3, T4> v1, T2 v2) => Equals(v1,v2);
        public static bool operator !=(OneOfBase<T0, T1, T2, T3, T4> v1, T2 v2) => !Equals(v1,v2);
        public static bool operator ==(T2 v1, OneOfBase<T0, T1, T2, T3, T4> v2) => Equals(v2,v1);
        public static bool operator !=(T2 v1, OneOfBase<T0, T1, T2, T3, T4> v2) => !Equals(v2,v1);
        public static bool operator ==(OneOfBase<T0, T1, T2, T3, T4> v1, T3 v2) => Equals(v1,v2);
        public static bool operator !=(OneOfBase<T0, T1, T2, T3, T4> v1, T3 v2) => !Equals(v1,v2);
        public static bool operator ==(T3 v1, OneOfBase<T0, T1, T2, T3, T4> v2) => Equals(v2,v1);
        public static bool operator !=(T3 v1, OneOfBase<T0, T1, T2, T3, T4> v2) => !Equals(v2,v1);
        public static bool operator ==(OneOfBase<T0, T1, T2, T3, T4> v1, T4 v2) => Equals(v1,v2);
        public static bool operator !=(OneOfBase<T0, T1, T2, T3, T4> v1, T4 v2) => !Equals(v1,v2);
        public static bool operator ==(T4 v1, OneOfBase<T0, T1, T2, T3, T4> v2) => Equals(v2,v1);
        public static bool operator !=(T4 v1, OneOfBase<T0, T1, T2, T3, T4> v2) => !Equals(v2,v1);

        public OneOfSwitcher<T1, T2, T3, T4> Switch(Action<T0> action) => new OneOfSwitcher<T0, T1, T2, T3, T4>(value, origType).Switch(action);
        public OneOfSwitcher<T0, T2, T3, T4> Switch(Action<T1> action) => new OneOfSwitcher<T0, T1, T2, T3, T4>(value, origType).Switch(action);
        public OneOfSwitcher<T0, T1, T3, T4> Switch(Action<T2> action) => new OneOfSwitcher<T0, T1, T2, T3, T4>(value, origType).Switch(action);
        public OneOfSwitcher<T0, T1, T2, T4> Switch(Action<T3> action) => new OneOfSwitcher<T0, T1, T2, T3, T4>(value, origType).Switch(action);
        public OneOfSwitcher<T0, T1, T2, T3> Switch(Action<T4> action) => new OneOfSwitcher<T0, T1, T2, T3, T4>(value, origType).Switch(action);

        public OneOfMatcher<T1, T2, T3, T4, TResult> Match<TResult>(Func<T0, TResult> func) => new OneOfMatcher<T0, T1, T2, T3, T4, TResult>(value, origType).Match(func);
        public OneOfMatcher<T0, T2, T3, T4, TResult> Match<TResult>(Func<T1, TResult> func) => new OneOfMatcher<T0, T1, T2, T3, T4, TResult>(value, origType).Match(func);
        public OneOfMatcher<T0, T1, T3, T4, TResult> Match<TResult>(Func<T2, TResult> func) => new OneOfMatcher<T0, T1, T2, T3, T4, TResult>(value, origType).Match(func);
        public OneOfMatcher<T0, T1, T2, T4, TResult> Match<TResult>(Func<T3, TResult> func) => new OneOfMatcher<T0, T1, T2, T3, T4, TResult>(value, origType).Match(func);
        public OneOfMatcher<T0, T1, T2, T3, TResult> Match<TResult>(Func<T4, TResult> func) => new OneOfMatcher<T0, T1, T2, T3, T4, TResult>(value, origType).Match(func);

        public override bool Equals(object obj) => (obj is IOneOf) && Equals(value, ((IOneOf)obj).Value) || value.Equals(obj);
        public override int GetHashCode() => (value?.GetHashCode() ?? origType?.GetHashCode() ?? 0);
        public override string ToString() => (value?.ToString() ?? "");
    }
    public class OneOfBase<T0, T1, T2, T3, T4, T5> : IOneOf
    {
        private readonly object value;
        private readonly Type origType;

        OneOfBase(object value, Type origType)
        {
            this.value = value;
            this.origType = origType;
        }

        protected OneOfBase()
        {
            this.value = this;
            this.origType = GetType();
        }

        object IOneOf.Value => value;

        internal static OneOfBase<T0, T1, T2, T3, T4, T5> CreateRaw(object value)
        {
            if (value == null) throw new ArgumentNullException(nameof(value));
            if (value.GetType() == typeof(T0)) return Create((T0)value);
            if (value.GetType() == typeof(T1)) return Create((T1)value);
            if (value.GetType() == typeof(T2)) return Create((T2)value);
            if (value.GetType() == typeof(T3)) return Create((T3)value);
            if (value.GetType() == typeof(T4)) return Create((T4)value);
            if (value.GetType() == typeof(T5)) return Create((T5)value);
            try
            {
                return Create((dynamic)value);
            }
            catch (RuntimeBinderException ex)
            {
                throw new ArgumentException(nameof(value), ex);
            }
        }

        static OneOfBase<T0, T1, T2, T3, T4, T5> Create(T0 value) => new OneOfBase<T0, T1, T2, T3, T4, T5>(value, typeof(T0));
        static OneOfBase<T0, T1, T2, T3, T4, T5> Create(T1 value) => new OneOfBase<T0, T1, T2, T3, T4, T5>(value, typeof(T1));
        static OneOfBase<T0, T1, T2, T3, T4, T5> Create(T2 value) => new OneOfBase<T0, T1, T2, T3, T4, T5>(value, typeof(T2));
        static OneOfBase<T0, T1, T2, T3, T4, T5> Create(T3 value) => new OneOfBase<T0, T1, T2, T3, T4, T5>(value, typeof(T3));
        static OneOfBase<T0, T1, T2, T3, T4, T5> Create(T4 value) => new OneOfBase<T0, T1, T2, T3, T4, T5>(value, typeof(T4));
        static OneOfBase<T0, T1, T2, T3, T4, T5> Create(T5 value) => new OneOfBase<T0, T1, T2, T3, T4, T5>(value, typeof(T5));

        public OneOfBase<N0, N1, N2, N3, N4, N5> ToOneOf<N0, N1, N2, N3, N4, N5>() => OneOfBase<N0, N1, N2, N3, N4, N5>.CreateRaw(value);
        public OneOfBase<N0, N1, N2, N3, N4, N5, N6> ToOneOf<N0, N1, N2, N3, N4, N5, N6>() => OneOfBase<N0, N1, N2, N3, N4, N5, N6>.CreateRaw(value);
        public OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7>() => OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7>.CreateRaw(value);
        public OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7, N8> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8>() => OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7, N8>.CreateRaw(value);

        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5>(T0 value) => CreateRaw(value);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5>(T1 value) => CreateRaw(value);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5>(T2 value) => CreateRaw(value);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5>(T3 value) => CreateRaw(value);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5>(T4 value) => CreateRaw(value);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5>(T5 value) => CreateRaw(value);

        public static bool operator ==(OneOfBase<T0, T1, T2, T3, T4, T5> v1, IOneOf v2) => Equals(v1,v2);
        public static bool operator !=(OneOfBase<T0, T1, T2, T3, T4, T5> v1, IOneOf v2) => !Equals(v1,v2);
        public static bool operator ==(OneOfBase<T0, T1, T2, T3, T4, T5> v1, T0 v2) => Equals(v1,v2);
        public static bool operator !=(OneOfBase<T0, T1, T2, T3, T4, T5> v1, T0 v2) => !Equals(v1,v2);
        public static bool operator ==(T0 v1, OneOfBase<T0, T1, T2, T3, T4, T5> v2) => Equals(v2,v1);
        public static bool operator !=(T0 v1, OneOfBase<T0, T1, T2, T3, T4, T5> v2) => !Equals(v2,v1);
        public static bool operator ==(OneOfBase<T0, T1, T2, T3, T4, T5> v1, T1 v2) => Equals(v1,v2);
        public static bool operator !=(OneOfBase<T0, T1, T2, T3, T4, T5> v1, T1 v2) => !Equals(v1,v2);
        public static bool operator ==(T1 v1, OneOfBase<T0, T1, T2, T3, T4, T5> v2) => Equals(v2,v1);
        public static bool operator !=(T1 v1, OneOfBase<T0, T1, T2, T3, T4, T5> v2) => !Equals(v2,v1);
        public static bool operator ==(OneOfBase<T0, T1, T2, T3, T4, T5> v1, T2 v2) => Equals(v1,v2);
        public static bool operator !=(OneOfBase<T0, T1, T2, T3, T4, T5> v1, T2 v2) => !Equals(v1,v2);
        public static bool operator ==(T2 v1, OneOfBase<T0, T1, T2, T3, T4, T5> v2) => Equals(v2,v1);
        public static bool operator !=(T2 v1, OneOfBase<T0, T1, T2, T3, T4, T5> v2) => !Equals(v2,v1);
        public static bool operator ==(OneOfBase<T0, T1, T2, T3, T4, T5> v1, T3 v2) => Equals(v1,v2);
        public static bool operator !=(OneOfBase<T0, T1, T2, T3, T4, T5> v1, T3 v2) => !Equals(v1,v2);
        public static bool operator ==(T3 v1, OneOfBase<T0, T1, T2, T3, T4, T5> v2) => Equals(v2,v1);
        public static bool operator !=(T3 v1, OneOfBase<T0, T1, T2, T3, T4, T5> v2) => !Equals(v2,v1);
        public static bool operator ==(OneOfBase<T0, T1, T2, T3, T4, T5> v1, T4 v2) => Equals(v1,v2);
        public static bool operator !=(OneOfBase<T0, T1, T2, T3, T4, T5> v1, T4 v2) => !Equals(v1,v2);
        public static bool operator ==(T4 v1, OneOfBase<T0, T1, T2, T3, T4, T5> v2) => Equals(v2,v1);
        public static bool operator !=(T4 v1, OneOfBase<T0, T1, T2, T3, T4, T5> v2) => !Equals(v2,v1);
        public static bool operator ==(OneOfBase<T0, T1, T2, T3, T4, T5> v1, T5 v2) => Equals(v1,v2);
        public static bool operator !=(OneOfBase<T0, T1, T2, T3, T4, T5> v1, T5 v2) => !Equals(v1,v2);
        public static bool operator ==(T5 v1, OneOfBase<T0, T1, T2, T3, T4, T5> v2) => Equals(v2,v1);
        public static bool operator !=(T5 v1, OneOfBase<T0, T1, T2, T3, T4, T5> v2) => !Equals(v2,v1);

        public OneOfSwitcher<T1, T2, T3, T4, T5> Switch(Action<T0> action) => new OneOfSwitcher<T0, T1, T2, T3, T4, T5>(value, origType).Switch(action);
        public OneOfSwitcher<T0, T2, T3, T4, T5> Switch(Action<T1> action) => new OneOfSwitcher<T0, T1, T2, T3, T4, T5>(value, origType).Switch(action);
        public OneOfSwitcher<T0, T1, T3, T4, T5> Switch(Action<T2> action) => new OneOfSwitcher<T0, T1, T2, T3, T4, T5>(value, origType).Switch(action);
        public OneOfSwitcher<T0, T1, T2, T4, T5> Switch(Action<T3> action) => new OneOfSwitcher<T0, T1, T2, T3, T4, T5>(value, origType).Switch(action);
        public OneOfSwitcher<T0, T1, T2, T3, T5> Switch(Action<T4> action) => new OneOfSwitcher<T0, T1, T2, T3, T4, T5>(value, origType).Switch(action);
        public OneOfSwitcher<T0, T1, T2, T3, T4> Switch(Action<T5> action) => new OneOfSwitcher<T0, T1, T2, T3, T4, T5>(value, origType).Switch(action);

        public OneOfMatcher<T1, T2, T3, T4, T5, TResult> Match<TResult>(Func<T0, TResult> func) => new OneOfMatcher<T0, T1, T2, T3, T4, T5, TResult>(value, origType).Match(func);
        public OneOfMatcher<T0, T2, T3, T4, T5, TResult> Match<TResult>(Func<T1, TResult> func) => new OneOfMatcher<T0, T1, T2, T3, T4, T5, TResult>(value, origType).Match(func);
        public OneOfMatcher<T0, T1, T3, T4, T5, TResult> Match<TResult>(Func<T2, TResult> func) => new OneOfMatcher<T0, T1, T2, T3, T4, T5, TResult>(value, origType).Match(func);
        public OneOfMatcher<T0, T1, T2, T4, T5, TResult> Match<TResult>(Func<T3, TResult> func) => new OneOfMatcher<T0, T1, T2, T3, T4, T5, TResult>(value, origType).Match(func);
        public OneOfMatcher<T0, T1, T2, T3, T5, TResult> Match<TResult>(Func<T4, TResult> func) => new OneOfMatcher<T0, T1, T2, T3, T4, T5, TResult>(value, origType).Match(func);
        public OneOfMatcher<T0, T1, T2, T3, T4, TResult> Match<TResult>(Func<T5, TResult> func) => new OneOfMatcher<T0, T1, T2, T3, T4, T5, TResult>(value, origType).Match(func);

        public override bool Equals(object obj) => (obj is IOneOf) && Equals(value, ((IOneOf)obj).Value) || value.Equals(obj);
        public override int GetHashCode() => (value?.GetHashCode() ?? origType?.GetHashCode() ?? 0);
        public override string ToString() => (value?.ToString() ?? "");
    }
    public class OneOfBase<T0, T1, T2, T3, T4, T5, T6> : IOneOf
    {
        private readonly object value;
        private readonly Type origType;

        OneOfBase(object value, Type origType)
        {
            this.value = value;
            this.origType = origType;
        }

        protected OneOfBase()
        {
            this.value = this;
            this.origType = GetType();
        }

        object IOneOf.Value => value;

        internal static OneOfBase<T0, T1, T2, T3, T4, T5, T6> CreateRaw(object value)
        {
            if (value == null) throw new ArgumentNullException(nameof(value));
            if (value.GetType() == typeof(T0)) return Create((T0)value);
            if (value.GetType() == typeof(T1)) return Create((T1)value);
            if (value.GetType() == typeof(T2)) return Create((T2)value);
            if (value.GetType() == typeof(T3)) return Create((T3)value);
            if (value.GetType() == typeof(T4)) return Create((T4)value);
            if (value.GetType() == typeof(T5)) return Create((T5)value);
            if (value.GetType() == typeof(T6)) return Create((T6)value);
            try
            {
                return Create((dynamic)value);
            }
            catch (RuntimeBinderException ex)
            {
                throw new ArgumentException(nameof(value), ex);
            }
        }

        static OneOfBase<T0, T1, T2, T3, T4, T5, T6> Create(T0 value) => new OneOfBase<T0, T1, T2, T3, T4, T5, T6>(value, typeof(T0));
        static OneOfBase<T0, T1, T2, T3, T4, T5, T6> Create(T1 value) => new OneOfBase<T0, T1, T2, T3, T4, T5, T6>(value, typeof(T1));
        static OneOfBase<T0, T1, T2, T3, T4, T5, T6> Create(T2 value) => new OneOfBase<T0, T1, T2, T3, T4, T5, T6>(value, typeof(T2));
        static OneOfBase<T0, T1, T2, T3, T4, T5, T6> Create(T3 value) => new OneOfBase<T0, T1, T2, T3, T4, T5, T6>(value, typeof(T3));
        static OneOfBase<T0, T1, T2, T3, T4, T5, T6> Create(T4 value) => new OneOfBase<T0, T1, T2, T3, T4, T5, T6>(value, typeof(T4));
        static OneOfBase<T0, T1, T2, T3, T4, T5, T6> Create(T5 value) => new OneOfBase<T0, T1, T2, T3, T4, T5, T6>(value, typeof(T5));
        static OneOfBase<T0, T1, T2, T3, T4, T5, T6> Create(T6 value) => new OneOfBase<T0, T1, T2, T3, T4, T5, T6>(value, typeof(T6));

        public OneOfBase<N0, N1, N2, N3, N4, N5, N6> ToOneOf<N0, N1, N2, N3, N4, N5, N6>() => OneOfBase<N0, N1, N2, N3, N4, N5, N6>.CreateRaw(value);
        public OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7>() => OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7>.CreateRaw(value);
        public OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7, N8> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8>() => OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7, N8>.CreateRaw(value);

        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5, T6>(T0 value) => CreateRaw(value);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5, T6>(T1 value) => CreateRaw(value);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5, T6>(T2 value) => CreateRaw(value);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5, T6>(T3 value) => CreateRaw(value);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5, T6>(T4 value) => CreateRaw(value);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5, T6>(T5 value) => CreateRaw(value);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5, T6>(T6 value) => CreateRaw(value);

        public static bool operator ==(OneOfBase<T0, T1, T2, T3, T4, T5, T6> v1, IOneOf v2) => Equals(v1,v2);
        public static bool operator !=(OneOfBase<T0, T1, T2, T3, T4, T5, T6> v1, IOneOf v2) => !Equals(v1,v2);
        public static bool operator ==(OneOfBase<T0, T1, T2, T3, T4, T5, T6> v1, T0 v2) => Equals(v1,v2);
        public static bool operator !=(OneOfBase<T0, T1, T2, T3, T4, T5, T6> v1, T0 v2) => !Equals(v1,v2);
        public static bool operator ==(T0 v1, OneOfBase<T0, T1, T2, T3, T4, T5, T6> v2) => Equals(v2,v1);
        public static bool operator !=(T0 v1, OneOfBase<T0, T1, T2, T3, T4, T5, T6> v2) => !Equals(v2,v1);
        public static bool operator ==(OneOfBase<T0, T1, T2, T3, T4, T5, T6> v1, T1 v2) => Equals(v1,v2);
        public static bool operator !=(OneOfBase<T0, T1, T2, T3, T4, T5, T6> v1, T1 v2) => !Equals(v1,v2);
        public static bool operator ==(T1 v1, OneOfBase<T0, T1, T2, T3, T4, T5, T6> v2) => Equals(v2,v1);
        public static bool operator !=(T1 v1, OneOfBase<T0, T1, T2, T3, T4, T5, T6> v2) => !Equals(v2,v1);
        public static bool operator ==(OneOfBase<T0, T1, T2, T3, T4, T5, T6> v1, T2 v2) => Equals(v1,v2);
        public static bool operator !=(OneOfBase<T0, T1, T2, T3, T4, T5, T6> v1, T2 v2) => !Equals(v1,v2);
        public static bool operator ==(T2 v1, OneOfBase<T0, T1, T2, T3, T4, T5, T6> v2) => Equals(v2,v1);
        public static bool operator !=(T2 v1, OneOfBase<T0, T1, T2, T3, T4, T5, T6> v2) => !Equals(v2,v1);
        public static bool operator ==(OneOfBase<T0, T1, T2, T3, T4, T5, T6> v1, T3 v2) => Equals(v1,v2);
        public static bool operator !=(OneOfBase<T0, T1, T2, T3, T4, T5, T6> v1, T3 v2) => !Equals(v1,v2);
        public static bool operator ==(T3 v1, OneOfBase<T0, T1, T2, T3, T4, T5, T6> v2) => Equals(v2,v1);
        public static bool operator !=(T3 v1, OneOfBase<T0, T1, T2, T3, T4, T5, T6> v2) => !Equals(v2,v1);
        public static bool operator ==(OneOfBase<T0, T1, T2, T3, T4, T5, T6> v1, T4 v2) => Equals(v1,v2);
        public static bool operator !=(OneOfBase<T0, T1, T2, T3, T4, T5, T6> v1, T4 v2) => !Equals(v1,v2);
        public static bool operator ==(T4 v1, OneOfBase<T0, T1, T2, T3, T4, T5, T6> v2) => Equals(v2,v1);
        public static bool operator !=(T4 v1, OneOfBase<T0, T1, T2, T3, T4, T5, T6> v2) => !Equals(v2,v1);
        public static bool operator ==(OneOfBase<T0, T1, T2, T3, T4, T5, T6> v1, T5 v2) => Equals(v1,v2);
        public static bool operator !=(OneOfBase<T0, T1, T2, T3, T4, T5, T6> v1, T5 v2) => !Equals(v1,v2);
        public static bool operator ==(T5 v1, OneOfBase<T0, T1, T2, T3, T4, T5, T6> v2) => Equals(v2,v1);
        public static bool operator !=(T5 v1, OneOfBase<T0, T1, T2, T3, T4, T5, T6> v2) => !Equals(v2,v1);
        public static bool operator ==(OneOfBase<T0, T1, T2, T3, T4, T5, T6> v1, T6 v2) => Equals(v1,v2);
        public static bool operator !=(OneOfBase<T0, T1, T2, T3, T4, T5, T6> v1, T6 v2) => !Equals(v1,v2);
        public static bool operator ==(T6 v1, OneOfBase<T0, T1, T2, T3, T4, T5, T6> v2) => Equals(v2,v1);
        public static bool operator !=(T6 v1, OneOfBase<T0, T1, T2, T3, T4, T5, T6> v2) => !Equals(v2,v1);

        public OneOfSwitcher<T1, T2, T3, T4, T5, T6> Switch(Action<T0> action) => new OneOfSwitcher<T0, T1, T2, T3, T4, T5, T6>(value, origType).Switch(action);
        public OneOfSwitcher<T0, T2, T3, T4, T5, T6> Switch(Action<T1> action) => new OneOfSwitcher<T0, T1, T2, T3, T4, T5, T6>(value, origType).Switch(action);
        public OneOfSwitcher<T0, T1, T3, T4, T5, T6> Switch(Action<T2> action) => new OneOfSwitcher<T0, T1, T2, T3, T4, T5, T6>(value, origType).Switch(action);
        public OneOfSwitcher<T0, T1, T2, T4, T5, T6> Switch(Action<T3> action) => new OneOfSwitcher<T0, T1, T2, T3, T4, T5, T6>(value, origType).Switch(action);
        public OneOfSwitcher<T0, T1, T2, T3, T5, T6> Switch(Action<T4> action) => new OneOfSwitcher<T0, T1, T2, T3, T4, T5, T6>(value, origType).Switch(action);
        public OneOfSwitcher<T0, T1, T2, T3, T4, T6> Switch(Action<T5> action) => new OneOfSwitcher<T0, T1, T2, T3, T4, T5, T6>(value, origType).Switch(action);
        public OneOfSwitcher<T0, T1, T2, T3, T4, T5> Switch(Action<T6> action) => new OneOfSwitcher<T0, T1, T2, T3, T4, T5, T6>(value, origType).Switch(action);

        public OneOfMatcher<T1, T2, T3, T4, T5, T6, TResult> Match<TResult>(Func<T0, TResult> func) => new OneOfMatcher<T0, T1, T2, T3, T4, T5, T6, TResult>(value, origType).Match(func);
        public OneOfMatcher<T0, T2, T3, T4, T5, T6, TResult> Match<TResult>(Func<T1, TResult> func) => new OneOfMatcher<T0, T1, T2, T3, T4, T5, T6, TResult>(value, origType).Match(func);
        public OneOfMatcher<T0, T1, T3, T4, T5, T6, TResult> Match<TResult>(Func<T2, TResult> func) => new OneOfMatcher<T0, T1, T2, T3, T4, T5, T6, TResult>(value, origType).Match(func);
        public OneOfMatcher<T0, T1, T2, T4, T5, T6, TResult> Match<TResult>(Func<T3, TResult> func) => new OneOfMatcher<T0, T1, T2, T3, T4, T5, T6, TResult>(value, origType).Match(func);
        public OneOfMatcher<T0, T1, T2, T3, T5, T6, TResult> Match<TResult>(Func<T4, TResult> func) => new OneOfMatcher<T0, T1, T2, T3, T4, T5, T6, TResult>(value, origType).Match(func);
        public OneOfMatcher<T0, T1, T2, T3, T4, T6, TResult> Match<TResult>(Func<T5, TResult> func) => new OneOfMatcher<T0, T1, T2, T3, T4, T5, T6, TResult>(value, origType).Match(func);
        public OneOfMatcher<T0, T1, T2, T3, T4, T5, TResult> Match<TResult>(Func<T6, TResult> func) => new OneOfMatcher<T0, T1, T2, T3, T4, T5, T6, TResult>(value, origType).Match(func);

        public override bool Equals(object obj) => (obj is IOneOf) && Equals(value, ((IOneOf)obj).Value) || value.Equals(obj);
        public override int GetHashCode() => (value?.GetHashCode() ?? origType?.GetHashCode() ?? 0);
        public override string ToString() => (value?.ToString() ?? "");
    }
    public class OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> : IOneOf
    {
        private readonly object value;
        private readonly Type origType;

        OneOfBase(object value, Type origType)
        {
            this.value = value;
            this.origType = origType;
        }

        protected OneOfBase()
        {
            this.value = this;
            this.origType = GetType();
        }

        object IOneOf.Value => value;

        internal static OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> CreateRaw(object value)
        {
            if (value == null) throw new ArgumentNullException(nameof(value));
            if (value.GetType() == typeof(T0)) return Create((T0)value);
            if (value.GetType() == typeof(T1)) return Create((T1)value);
            if (value.GetType() == typeof(T2)) return Create((T2)value);
            if (value.GetType() == typeof(T3)) return Create((T3)value);
            if (value.GetType() == typeof(T4)) return Create((T4)value);
            if (value.GetType() == typeof(T5)) return Create((T5)value);
            if (value.GetType() == typeof(T6)) return Create((T6)value);
            if (value.GetType() == typeof(T7)) return Create((T7)value);
            try
            {
                return Create((dynamic)value);
            }
            catch (RuntimeBinderException ex)
            {
                throw new ArgumentException(nameof(value), ex);
            }
        }

        static OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> Create(T0 value) => new OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7>(value, typeof(T0));
        static OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> Create(T1 value) => new OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7>(value, typeof(T1));
        static OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> Create(T2 value) => new OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7>(value, typeof(T2));
        static OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> Create(T3 value) => new OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7>(value, typeof(T3));
        static OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> Create(T4 value) => new OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7>(value, typeof(T4));
        static OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> Create(T5 value) => new OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7>(value, typeof(T5));
        static OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> Create(T6 value) => new OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7>(value, typeof(T6));
        static OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> Create(T7 value) => new OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7>(value, typeof(T7));

        public OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7>() => OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7>.CreateRaw(value);
        public OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7, N8> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8>() => OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7, N8>.CreateRaw(value);

        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7>(T0 value) => CreateRaw(value);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7>(T1 value) => CreateRaw(value);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7>(T2 value) => CreateRaw(value);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7>(T3 value) => CreateRaw(value);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7>(T4 value) => CreateRaw(value);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7>(T5 value) => CreateRaw(value);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7>(T6 value) => CreateRaw(value);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7>(T7 value) => CreateRaw(value);

        public static bool operator ==(OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> v1, IOneOf v2) => Equals(v1,v2);
        public static bool operator !=(OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> v1, IOneOf v2) => !Equals(v1,v2);
        public static bool operator ==(OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> v1, T0 v2) => Equals(v1,v2);
        public static bool operator !=(OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> v1, T0 v2) => !Equals(v1,v2);
        public static bool operator ==(T0 v1, OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> v2) => Equals(v2,v1);
        public static bool operator !=(T0 v1, OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> v2) => !Equals(v2,v1);
        public static bool operator ==(OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> v1, T1 v2) => Equals(v1,v2);
        public static bool operator !=(OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> v1, T1 v2) => !Equals(v1,v2);
        public static bool operator ==(T1 v1, OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> v2) => Equals(v2,v1);
        public static bool operator !=(T1 v1, OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> v2) => !Equals(v2,v1);
        public static bool operator ==(OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> v1, T2 v2) => Equals(v1,v2);
        public static bool operator !=(OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> v1, T2 v2) => !Equals(v1,v2);
        public static bool operator ==(T2 v1, OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> v2) => Equals(v2,v1);
        public static bool operator !=(T2 v1, OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> v2) => !Equals(v2,v1);
        public static bool operator ==(OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> v1, T3 v2) => Equals(v1,v2);
        public static bool operator !=(OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> v1, T3 v2) => !Equals(v1,v2);
        public static bool operator ==(T3 v1, OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> v2) => Equals(v2,v1);
        public static bool operator !=(T3 v1, OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> v2) => !Equals(v2,v1);
        public static bool operator ==(OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> v1, T4 v2) => Equals(v1,v2);
        public static bool operator !=(OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> v1, T4 v2) => !Equals(v1,v2);
        public static bool operator ==(T4 v1, OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> v2) => Equals(v2,v1);
        public static bool operator !=(T4 v1, OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> v2) => !Equals(v2,v1);
        public static bool operator ==(OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> v1, T5 v2) => Equals(v1,v2);
        public static bool operator !=(OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> v1, T5 v2) => !Equals(v1,v2);
        public static bool operator ==(T5 v1, OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> v2) => Equals(v2,v1);
        public static bool operator !=(T5 v1, OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> v2) => !Equals(v2,v1);
        public static bool operator ==(OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> v1, T6 v2) => Equals(v1,v2);
        public static bool operator !=(OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> v1, T6 v2) => !Equals(v1,v2);
        public static bool operator ==(T6 v1, OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> v2) => Equals(v2,v1);
        public static bool operator !=(T6 v1, OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> v2) => !Equals(v2,v1);
        public static bool operator ==(OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> v1, T7 v2) => Equals(v1,v2);
        public static bool operator !=(OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> v1, T7 v2) => !Equals(v1,v2);
        public static bool operator ==(T7 v1, OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> v2) => Equals(v2,v1);
        public static bool operator !=(T7 v1, OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> v2) => !Equals(v2,v1);

        public OneOfSwitcher<T1, T2, T3, T4, T5, T6, T7> Switch(Action<T0> action) => new OneOfSwitcher<T0, T1, T2, T3, T4, T5, T6, T7>(value, origType).Switch(action);
        public OneOfSwitcher<T0, T2, T3, T4, T5, T6, T7> Switch(Action<T1> action) => new OneOfSwitcher<T0, T1, T2, T3, T4, T5, T6, T7>(value, origType).Switch(action);
        public OneOfSwitcher<T0, T1, T3, T4, T5, T6, T7> Switch(Action<T2> action) => new OneOfSwitcher<T0, T1, T2, T3, T4, T5, T6, T7>(value, origType).Switch(action);
        public OneOfSwitcher<T0, T1, T2, T4, T5, T6, T7> Switch(Action<T3> action) => new OneOfSwitcher<T0, T1, T2, T3, T4, T5, T6, T7>(value, origType).Switch(action);
        public OneOfSwitcher<T0, T1, T2, T3, T5, T6, T7> Switch(Action<T4> action) => new OneOfSwitcher<T0, T1, T2, T3, T4, T5, T6, T7>(value, origType).Switch(action);
        public OneOfSwitcher<T0, T1, T2, T3, T4, T6, T7> Switch(Action<T5> action) => new OneOfSwitcher<T0, T1, T2, T3, T4, T5, T6, T7>(value, origType).Switch(action);
        public OneOfSwitcher<T0, T1, T2, T3, T4, T5, T7> Switch(Action<T6> action) => new OneOfSwitcher<T0, T1, T2, T3, T4, T5, T6, T7>(value, origType).Switch(action);
        public OneOfSwitcher<T0, T1, T2, T3, T4, T5, T6> Switch(Action<T7> action) => new OneOfSwitcher<T0, T1, T2, T3, T4, T5, T6, T7>(value, origType).Switch(action);

        public OneOfMatcher<T1, T2, T3, T4, T5, T6, T7, TResult> Match<TResult>(Func<T0, TResult> func) => new OneOfMatcher<T0, T1, T2, T3, T4, T5, T6, T7, TResult>(value, origType).Match(func);
        public OneOfMatcher<T0, T2, T3, T4, T5, T6, T7, TResult> Match<TResult>(Func<T1, TResult> func) => new OneOfMatcher<T0, T1, T2, T3, T4, T5, T6, T7, TResult>(value, origType).Match(func);
        public OneOfMatcher<T0, T1, T3, T4, T5, T6, T7, TResult> Match<TResult>(Func<T2, TResult> func) => new OneOfMatcher<T0, T1, T2, T3, T4, T5, T6, T7, TResult>(value, origType).Match(func);
        public OneOfMatcher<T0, T1, T2, T4, T5, T6, T7, TResult> Match<TResult>(Func<T3, TResult> func) => new OneOfMatcher<T0, T1, T2, T3, T4, T5, T6, T7, TResult>(value, origType).Match(func);
        public OneOfMatcher<T0, T1, T2, T3, T5, T6, T7, TResult> Match<TResult>(Func<T4, TResult> func) => new OneOfMatcher<T0, T1, T2, T3, T4, T5, T6, T7, TResult>(value, origType).Match(func);
        public OneOfMatcher<T0, T1, T2, T3, T4, T6, T7, TResult> Match<TResult>(Func<T5, TResult> func) => new OneOfMatcher<T0, T1, T2, T3, T4, T5, T6, T7, TResult>(value, origType).Match(func);
        public OneOfMatcher<T0, T1, T2, T3, T4, T5, T7, TResult> Match<TResult>(Func<T6, TResult> func) => new OneOfMatcher<T0, T1, T2, T3, T4, T5, T6, T7, TResult>(value, origType).Match(func);
        public OneOfMatcher<T0, T1, T2, T3, T4, T5, T6, TResult> Match<TResult>(Func<T7, TResult> func) => new OneOfMatcher<T0, T1, T2, T3, T4, T5, T6, T7, TResult>(value, origType).Match(func);

        public override bool Equals(object obj) => (obj is IOneOf) && Equals(value, ((IOneOf)obj).Value) || value.Equals(obj);
        public override int GetHashCode() => (value?.GetHashCode() ?? origType?.GetHashCode() ?? 0);
        public override string ToString() => (value?.ToString() ?? "");
    }
    public class OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> : IOneOf
    {
        private readonly object value;
        private readonly Type origType;

        OneOfBase(object value, Type origType)
        {
            this.value = value;
            this.origType = origType;
        }

        protected OneOfBase()
        {
            this.value = this;
            this.origType = GetType();
        }

        object IOneOf.Value => value;

        internal static OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> CreateRaw(object value)
        {
            if (value == null) throw new ArgumentNullException(nameof(value));
            if (value.GetType() == typeof(T0)) return Create((T0)value);
            if (value.GetType() == typeof(T1)) return Create((T1)value);
            if (value.GetType() == typeof(T2)) return Create((T2)value);
            if (value.GetType() == typeof(T3)) return Create((T3)value);
            if (value.GetType() == typeof(T4)) return Create((T4)value);
            if (value.GetType() == typeof(T5)) return Create((T5)value);
            if (value.GetType() == typeof(T6)) return Create((T6)value);
            if (value.GetType() == typeof(T7)) return Create((T7)value);
            if (value.GetType() == typeof(T8)) return Create((T8)value);
            try
            {
                return Create((dynamic)value);
            }
            catch (RuntimeBinderException ex)
            {
                throw new ArgumentException(nameof(value), ex);
            }
        }

        static OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> Create(T0 value) => new OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8>(value, typeof(T0));
        static OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> Create(T1 value) => new OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8>(value, typeof(T1));
        static OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> Create(T2 value) => new OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8>(value, typeof(T2));
        static OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> Create(T3 value) => new OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8>(value, typeof(T3));
        static OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> Create(T4 value) => new OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8>(value, typeof(T4));
        static OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> Create(T5 value) => new OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8>(value, typeof(T5));
        static OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> Create(T6 value) => new OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8>(value, typeof(T6));
        static OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> Create(T7 value) => new OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8>(value, typeof(T7));
        static OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> Create(T8 value) => new OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8>(value, typeof(T8));

        public OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7, N8> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8>() => OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7, N8>.CreateRaw(value);

        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8>(T0 value) => CreateRaw(value);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8>(T1 value) => CreateRaw(value);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8>(T2 value) => CreateRaw(value);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8>(T3 value) => CreateRaw(value);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8>(T4 value) => CreateRaw(value);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8>(T5 value) => CreateRaw(value);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8>(T6 value) => CreateRaw(value);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8>(T7 value) => CreateRaw(value);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8>(T8 value) => CreateRaw(value);

        public static bool operator ==(OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> v1, IOneOf v2) => Equals(v1,v2);
        public static bool operator !=(OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> v1, IOneOf v2) => !Equals(v1,v2);
        public static bool operator ==(OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> v1, T0 v2) => Equals(v1,v2);
        public static bool operator !=(OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> v1, T0 v2) => !Equals(v1,v2);
        public static bool operator ==(T0 v1, OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> v2) => Equals(v2,v1);
        public static bool operator !=(T0 v1, OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> v2) => !Equals(v2,v1);
        public static bool operator ==(OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> v1, T1 v2) => Equals(v1,v2);
        public static bool operator !=(OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> v1, T1 v2) => !Equals(v1,v2);
        public static bool operator ==(T1 v1, OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> v2) => Equals(v2,v1);
        public static bool operator !=(T1 v1, OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> v2) => !Equals(v2,v1);
        public static bool operator ==(OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> v1, T2 v2) => Equals(v1,v2);
        public static bool operator !=(OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> v1, T2 v2) => !Equals(v1,v2);
        public static bool operator ==(T2 v1, OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> v2) => Equals(v2,v1);
        public static bool operator !=(T2 v1, OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> v2) => !Equals(v2,v1);
        public static bool operator ==(OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> v1, T3 v2) => Equals(v1,v2);
        public static bool operator !=(OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> v1, T3 v2) => !Equals(v1,v2);
        public static bool operator ==(T3 v1, OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> v2) => Equals(v2,v1);
        public static bool operator !=(T3 v1, OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> v2) => !Equals(v2,v1);
        public static bool operator ==(OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> v1, T4 v2) => Equals(v1,v2);
        public static bool operator !=(OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> v1, T4 v2) => !Equals(v1,v2);
        public static bool operator ==(T4 v1, OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> v2) => Equals(v2,v1);
        public static bool operator !=(T4 v1, OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> v2) => !Equals(v2,v1);
        public static bool operator ==(OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> v1, T5 v2) => Equals(v1,v2);
        public static bool operator !=(OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> v1, T5 v2) => !Equals(v1,v2);
        public static bool operator ==(T5 v1, OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> v2) => Equals(v2,v1);
        public static bool operator !=(T5 v1, OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> v2) => !Equals(v2,v1);
        public static bool operator ==(OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> v1, T6 v2) => Equals(v1,v2);
        public static bool operator !=(OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> v1, T6 v2) => !Equals(v1,v2);
        public static bool operator ==(T6 v1, OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> v2) => Equals(v2,v1);
        public static bool operator !=(T6 v1, OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> v2) => !Equals(v2,v1);
        public static bool operator ==(OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> v1, T7 v2) => Equals(v1,v2);
        public static bool operator !=(OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> v1, T7 v2) => !Equals(v1,v2);
        public static bool operator ==(T7 v1, OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> v2) => Equals(v2,v1);
        public static bool operator !=(T7 v1, OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> v2) => !Equals(v2,v1);
        public static bool operator ==(OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> v1, T8 v2) => Equals(v1,v2);
        public static bool operator !=(OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> v1, T8 v2) => !Equals(v1,v2);
        public static bool operator ==(T8 v1, OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> v2) => Equals(v2,v1);
        public static bool operator !=(T8 v1, OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> v2) => !Equals(v2,v1);

        public OneOfSwitcher<T1, T2, T3, T4, T5, T6, T7, T8> Switch(Action<T0> action) => new OneOfSwitcher<T0, T1, T2, T3, T4, T5, T6, T7, T8>(value, origType).Switch(action);
        public OneOfSwitcher<T0, T2, T3, T4, T5, T6, T7, T8> Switch(Action<T1> action) => new OneOfSwitcher<T0, T1, T2, T3, T4, T5, T6, T7, T8>(value, origType).Switch(action);
        public OneOfSwitcher<T0, T1, T3, T4, T5, T6, T7, T8> Switch(Action<T2> action) => new OneOfSwitcher<T0, T1, T2, T3, T4, T5, T6, T7, T8>(value, origType).Switch(action);
        public OneOfSwitcher<T0, T1, T2, T4, T5, T6, T7, T8> Switch(Action<T3> action) => new OneOfSwitcher<T0, T1, T2, T3, T4, T5, T6, T7, T8>(value, origType).Switch(action);
        public OneOfSwitcher<T0, T1, T2, T3, T5, T6, T7, T8> Switch(Action<T4> action) => new OneOfSwitcher<T0, T1, T2, T3, T4, T5, T6, T7, T8>(value, origType).Switch(action);
        public OneOfSwitcher<T0, T1, T2, T3, T4, T6, T7, T8> Switch(Action<T5> action) => new OneOfSwitcher<T0, T1, T2, T3, T4, T5, T6, T7, T8>(value, origType).Switch(action);
        public OneOfSwitcher<T0, T1, T2, T3, T4, T5, T7, T8> Switch(Action<T6> action) => new OneOfSwitcher<T0, T1, T2, T3, T4, T5, T6, T7, T8>(value, origType).Switch(action);
        public OneOfSwitcher<T0, T1, T2, T3, T4, T5, T6, T8> Switch(Action<T7> action) => new OneOfSwitcher<T0, T1, T2, T3, T4, T5, T6, T7, T8>(value, origType).Switch(action);
        public OneOfSwitcher<T0, T1, T2, T3, T4, T5, T6, T7> Switch(Action<T8> action) => new OneOfSwitcher<T0, T1, T2, T3, T4, T5, T6, T7, T8>(value, origType).Switch(action);

        public OneOfMatcher<T1, T2, T3, T4, T5, T6, T7, T8, TResult> Match<TResult>(Func<T0, TResult> func) => new OneOfMatcher<T0, T1, T2, T3, T4, T5, T6, T7, T8, TResult>(value, origType).Match(func);
        public OneOfMatcher<T0, T2, T3, T4, T5, T6, T7, T8, TResult> Match<TResult>(Func<T1, TResult> func) => new OneOfMatcher<T0, T1, T2, T3, T4, T5, T6, T7, T8, TResult>(value, origType).Match(func);
        public OneOfMatcher<T0, T1, T3, T4, T5, T6, T7, T8, TResult> Match<TResult>(Func<T2, TResult> func) => new OneOfMatcher<T0, T1, T2, T3, T4, T5, T6, T7, T8, TResult>(value, origType).Match(func);
        public OneOfMatcher<T0, T1, T2, T4, T5, T6, T7, T8, TResult> Match<TResult>(Func<T3, TResult> func) => new OneOfMatcher<T0, T1, T2, T3, T4, T5, T6, T7, T8, TResult>(value, origType).Match(func);
        public OneOfMatcher<T0, T1, T2, T3, T5, T6, T7, T8, TResult> Match<TResult>(Func<T4, TResult> func) => new OneOfMatcher<T0, T1, T2, T3, T4, T5, T6, T7, T8, TResult>(value, origType).Match(func);
        public OneOfMatcher<T0, T1, T2, T3, T4, T6, T7, T8, TResult> Match<TResult>(Func<T5, TResult> func) => new OneOfMatcher<T0, T1, T2, T3, T4, T5, T6, T7, T8, TResult>(value, origType).Match(func);
        public OneOfMatcher<T0, T1, T2, T3, T4, T5, T7, T8, TResult> Match<TResult>(Func<T6, TResult> func) => new OneOfMatcher<T0, T1, T2, T3, T4, T5, T6, T7, T8, TResult>(value, origType).Match(func);
        public OneOfMatcher<T0, T1, T2, T3, T4, T5, T6, T8, TResult> Match<TResult>(Func<T7, TResult> func) => new OneOfMatcher<T0, T1, T2, T3, T4, T5, T6, T7, T8, TResult>(value, origType).Match(func);
        public OneOfMatcher<T0, T1, T2, T3, T4, T5, T6, T7, TResult> Match<TResult>(Func<T8, TResult> func) => new OneOfMatcher<T0, T1, T2, T3, T4, T5, T6, T7, T8, TResult>(value, origType).Match(func);

        public override bool Equals(object obj) => (obj is IOneOf) && Equals(value, ((IOneOf)obj).Value) || value.Equals(obj);
        public override int GetHashCode() => (value?.GetHashCode() ?? origType?.GetHashCode() ?? 0);
        public override string ToString() => (value?.ToString() ?? "");
    }

    public struct OneOfSwitcher<T0>
    {
        readonly object value;
        readonly Type origType;
        bool hasSwitched;

        internal OneOfSwitcher(object value, Type origType) : this(value, origType, false) { }

        internal OneOfSwitcher(object value, Type origType, bool hasSwitched)
        {
            this.value = value;
            this.origType = origType;
            this.hasSwitched = hasSwitched;
        }

        public void Switch(Action<T0> action)
        {
            SwitchIf<T0>(action);
        }

        void SwitchIf<T>(Action<T> action)
        {
            if (!hasSwitched && origType == typeof(T))
            {
                action((T)value);
                hasSwitched = true;
            }
        }

        public void Else(Action<object> action)
        {
            if (!hasSwitched) action(value);
        }

        public void ElseThrow(Func<object, Exception> func)
        {
            if (!hasSwitched) throw func(value);
        }
    }

    public struct OneOfSwitcher<T0, T1>
    {
        readonly object value;
        readonly Type origType;
        bool hasSwitched;

        internal OneOfSwitcher(object value, Type origType) : this(value, origType, false) { }

        internal OneOfSwitcher(object value, Type origType, bool hasSwitched)
        {
            this.value = value;
            this.origType = origType;
            this.hasSwitched = hasSwitched;
        }

        public OneOfSwitcher<T1> Switch(Action<T0> action)
        {
            SwitchIf<T0>(action);
            return new OneOfSwitcher<T1>(value, origType, hasSwitched);
        }

        public OneOfSwitcher<T0> Switch(Action<T1> action)
        {
            SwitchIf<T1>(action);
            return new OneOfSwitcher<T0>(value, origType, hasSwitched);
        }

        void SwitchIf<T>(Action<T> action)
        {
            if (!hasSwitched && origType == typeof(T))
            {
                action((T)value);
                hasSwitched = true;
            }
        }

        public void Else(Action<object> action)
        {
            if (!hasSwitched) action(value);
        }

        public void ElseThrow(Func<object, Exception> func)
        {
            if (!hasSwitched) throw func(value);
        }
    }

    public struct OneOfSwitcher<T0, T1, T2>
    {
        readonly object value;
        readonly Type origType;
        bool hasSwitched;

        internal OneOfSwitcher(object value, Type origType) : this(value, origType, false) { }

        internal OneOfSwitcher(object value, Type origType, bool hasSwitched)
        {
            this.value = value;
            this.origType = origType;
            this.hasSwitched = hasSwitched;
        }

        public OneOfSwitcher<T1, T2> Switch(Action<T0> action)
        {
            SwitchIf<T0>(action);
            return new OneOfSwitcher<T1, T2>(value, origType, hasSwitched);
        }

        public OneOfSwitcher<T0, T2> Switch(Action<T1> action)
        {
            SwitchIf<T1>(action);
            return new OneOfSwitcher<T0, T2>(value, origType, hasSwitched);
        }

        public OneOfSwitcher<T0, T1> Switch(Action<T2> action)
        {
            SwitchIf<T2>(action);
            return new OneOfSwitcher<T0, T1>(value, origType, hasSwitched);
        }

        void SwitchIf<T>(Action<T> action)
        {
            if (!hasSwitched && origType == typeof(T))
            {
                action((T)value);
                hasSwitched = true;
            }
        }

        public void Else(Action<object> action)
        {
            if (!hasSwitched) action(value);
        }

        public void ElseThrow(Func<object, Exception> func)
        {
            if (!hasSwitched) throw func(value);
        }
    }

    public struct OneOfSwitcher<T0, T1, T2, T3>
    {
        readonly object value;
        readonly Type origType;
        bool hasSwitched;

        internal OneOfSwitcher(object value, Type origType) : this(value, origType, false) { }

        internal OneOfSwitcher(object value, Type origType, bool hasSwitched)
        {
            this.value = value;
            this.origType = origType;
            this.hasSwitched = hasSwitched;
        }

        public OneOfSwitcher<T1, T2, T3> Switch(Action<T0> action)
        {
            SwitchIf<T0>(action);
            return new OneOfSwitcher<T1, T2, T3>(value, origType, hasSwitched);
        }

        public OneOfSwitcher<T0, T2, T3> Switch(Action<T1> action)
        {
            SwitchIf<T1>(action);
            return new OneOfSwitcher<T0, T2, T3>(value, origType, hasSwitched);
        }

        public OneOfSwitcher<T0, T1, T3> Switch(Action<T2> action)
        {
            SwitchIf<T2>(action);
            return new OneOfSwitcher<T0, T1, T3>(value, origType, hasSwitched);
        }

        public OneOfSwitcher<T0, T1, T2> Switch(Action<T3> action)
        {
            SwitchIf<T3>(action);
            return new OneOfSwitcher<T0, T1, T2>(value, origType, hasSwitched);
        }

        void SwitchIf<T>(Action<T> action)
        {
            if (!hasSwitched && origType == typeof(T))
            {
                action((T)value);
                hasSwitched = true;
            }
        }

        public void Else(Action<object> action)
        {
            if (!hasSwitched) action(value);
        }

        public void ElseThrow(Func<object, Exception> func)
        {
            if (!hasSwitched) throw func(value);
        }
    }

    public struct OneOfSwitcher<T0, T1, T2, T3, T4>
    {
        readonly object value;
        readonly Type origType;
        bool hasSwitched;

        internal OneOfSwitcher(object value, Type origType) : this(value, origType, false) { }

        internal OneOfSwitcher(object value, Type origType, bool hasSwitched)
        {
            this.value = value;
            this.origType = origType;
            this.hasSwitched = hasSwitched;
        }

        public OneOfSwitcher<T1, T2, T3, T4> Switch(Action<T0> action)
        {
            SwitchIf<T0>(action);
            return new OneOfSwitcher<T1, T2, T3, T4>(value, origType, hasSwitched);
        }

        public OneOfSwitcher<T0, T2, T3, T4> Switch(Action<T1> action)
        {
            SwitchIf<T1>(action);
            return new OneOfSwitcher<T0, T2, T3, T4>(value, origType, hasSwitched);
        }

        public OneOfSwitcher<T0, T1, T3, T4> Switch(Action<T2> action)
        {
            SwitchIf<T2>(action);
            return new OneOfSwitcher<T0, T1, T3, T4>(value, origType, hasSwitched);
        }

        public OneOfSwitcher<T0, T1, T2, T4> Switch(Action<T3> action)
        {
            SwitchIf<T3>(action);
            return new OneOfSwitcher<T0, T1, T2, T4>(value, origType, hasSwitched);
        }

        public OneOfSwitcher<T0, T1, T2, T3> Switch(Action<T4> action)
        {
            SwitchIf<T4>(action);
            return new OneOfSwitcher<T0, T1, T2, T3>(value, origType, hasSwitched);
        }

        void SwitchIf<T>(Action<T> action)
        {
            if (!hasSwitched && origType == typeof(T))
            {
                action((T)value);
                hasSwitched = true;
            }
        }

        public void Else(Action<object> action)
        {
            if (!hasSwitched) action(value);
        }

        public void ElseThrow(Func<object, Exception> func)
        {
            if (!hasSwitched) throw func(value);
        }
    }

    public struct OneOfSwitcher<T0, T1, T2, T3, T4, T5>
    {
        readonly object value;
        readonly Type origType;
        bool hasSwitched;

        internal OneOfSwitcher(object value, Type origType) : this(value, origType, false) { }

        internal OneOfSwitcher(object value, Type origType, bool hasSwitched)
        {
            this.value = value;
            this.origType = origType;
            this.hasSwitched = hasSwitched;
        }

        public OneOfSwitcher<T1, T2, T3, T4, T5> Switch(Action<T0> action)
        {
            SwitchIf<T0>(action);
            return new OneOfSwitcher<T1, T2, T3, T4, T5>(value, origType, hasSwitched);
        }

        public OneOfSwitcher<T0, T2, T3, T4, T5> Switch(Action<T1> action)
        {
            SwitchIf<T1>(action);
            return new OneOfSwitcher<T0, T2, T3, T4, T5>(value, origType, hasSwitched);
        }

        public OneOfSwitcher<T0, T1, T3, T4, T5> Switch(Action<T2> action)
        {
            SwitchIf<T2>(action);
            return new OneOfSwitcher<T0, T1, T3, T4, T5>(value, origType, hasSwitched);
        }

        public OneOfSwitcher<T0, T1, T2, T4, T5> Switch(Action<T3> action)
        {
            SwitchIf<T3>(action);
            return new OneOfSwitcher<T0, T1, T2, T4, T5>(value, origType, hasSwitched);
        }

        public OneOfSwitcher<T0, T1, T2, T3, T5> Switch(Action<T4> action)
        {
            SwitchIf<T4>(action);
            return new OneOfSwitcher<T0, T1, T2, T3, T5>(value, origType, hasSwitched);
        }

        public OneOfSwitcher<T0, T1, T2, T3, T4> Switch(Action<T5> action)
        {
            SwitchIf<T5>(action);
            return new OneOfSwitcher<T0, T1, T2, T3, T4>(value, origType, hasSwitched);
        }

        void SwitchIf<T>(Action<T> action)
        {
            if (!hasSwitched && origType == typeof(T))
            {
                action((T)value);
                hasSwitched = true;
            }
        }

        public void Else(Action<object> action)
        {
            if (!hasSwitched) action(value);
        }

        public void ElseThrow(Func<object, Exception> func)
        {
            if (!hasSwitched) throw func(value);
        }
    }

    public struct OneOfSwitcher<T0, T1, T2, T3, T4, T5, T6>
    {
        readonly object value;
        readonly Type origType;
        bool hasSwitched;

        internal OneOfSwitcher(object value, Type origType) : this(value, origType, false) { }

        internal OneOfSwitcher(object value, Type origType, bool hasSwitched)
        {
            this.value = value;
            this.origType = origType;
            this.hasSwitched = hasSwitched;
        }

        public OneOfSwitcher<T1, T2, T3, T4, T5, T6> Switch(Action<T0> action)
        {
            SwitchIf<T0>(action);
            return new OneOfSwitcher<T1, T2, T3, T4, T5, T6>(value, origType, hasSwitched);
        }

        public OneOfSwitcher<T0, T2, T3, T4, T5, T6> Switch(Action<T1> action)
        {
            SwitchIf<T1>(action);
            return new OneOfSwitcher<T0, T2, T3, T4, T5, T6>(value, origType, hasSwitched);
        }

        public OneOfSwitcher<T0, T1, T3, T4, T5, T6> Switch(Action<T2> action)
        {
            SwitchIf<T2>(action);
            return new OneOfSwitcher<T0, T1, T3, T4, T5, T6>(value, origType, hasSwitched);
        }

        public OneOfSwitcher<T0, T1, T2, T4, T5, T6> Switch(Action<T3> action)
        {
            SwitchIf<T3>(action);
            return new OneOfSwitcher<T0, T1, T2, T4, T5, T6>(value, origType, hasSwitched);
        }

        public OneOfSwitcher<T0, T1, T2, T3, T5, T6> Switch(Action<T4> action)
        {
            SwitchIf<T4>(action);
            return new OneOfSwitcher<T0, T1, T2, T3, T5, T6>(value, origType, hasSwitched);
        }

        public OneOfSwitcher<T0, T1, T2, T3, T4, T6> Switch(Action<T5> action)
        {
            SwitchIf<T5>(action);
            return new OneOfSwitcher<T0, T1, T2, T3, T4, T6>(value, origType, hasSwitched);
        }

        public OneOfSwitcher<T0, T1, T2, T3, T4, T5> Switch(Action<T6> action)
        {
            SwitchIf<T6>(action);
            return new OneOfSwitcher<T0, T1, T2, T3, T4, T5>(value, origType, hasSwitched);
        }

        void SwitchIf<T>(Action<T> action)
        {
            if (!hasSwitched && origType == typeof(T))
            {
                action((T)value);
                hasSwitched = true;
            }
        }

        public void Else(Action<object> action)
        {
            if (!hasSwitched) action(value);
        }

        public void ElseThrow(Func<object, Exception> func)
        {
            if (!hasSwitched) throw func(value);
        }
    }

    public struct OneOfSwitcher<T0, T1, T2, T3, T4, T5, T6, T7>
    {
        readonly object value;
        readonly Type origType;
        bool hasSwitched;

        internal OneOfSwitcher(object value, Type origType) : this(value, origType, false) { }

        internal OneOfSwitcher(object value, Type origType, bool hasSwitched)
        {
            this.value = value;
            this.origType = origType;
            this.hasSwitched = hasSwitched;
        }

        public OneOfSwitcher<T1, T2, T3, T4, T5, T6, T7> Switch(Action<T0> action)
        {
            SwitchIf<T0>(action);
            return new OneOfSwitcher<T1, T2, T3, T4, T5, T6, T7>(value, origType, hasSwitched);
        }

        public OneOfSwitcher<T0, T2, T3, T4, T5, T6, T7> Switch(Action<T1> action)
        {
            SwitchIf<T1>(action);
            return new OneOfSwitcher<T0, T2, T3, T4, T5, T6, T7>(value, origType, hasSwitched);
        }

        public OneOfSwitcher<T0, T1, T3, T4, T5, T6, T7> Switch(Action<T2> action)
        {
            SwitchIf<T2>(action);
            return new OneOfSwitcher<T0, T1, T3, T4, T5, T6, T7>(value, origType, hasSwitched);
        }

        public OneOfSwitcher<T0, T1, T2, T4, T5, T6, T7> Switch(Action<T3> action)
        {
            SwitchIf<T3>(action);
            return new OneOfSwitcher<T0, T1, T2, T4, T5, T6, T7>(value, origType, hasSwitched);
        }

        public OneOfSwitcher<T0, T1, T2, T3, T5, T6, T7> Switch(Action<T4> action)
        {
            SwitchIf<T4>(action);
            return new OneOfSwitcher<T0, T1, T2, T3, T5, T6, T7>(value, origType, hasSwitched);
        }

        public OneOfSwitcher<T0, T1, T2, T3, T4, T6, T7> Switch(Action<T5> action)
        {
            SwitchIf<T5>(action);
            return new OneOfSwitcher<T0, T1, T2, T3, T4, T6, T7>(value, origType, hasSwitched);
        }

        public OneOfSwitcher<T0, T1, T2, T3, T4, T5, T7> Switch(Action<T6> action)
        {
            SwitchIf<T6>(action);
            return new OneOfSwitcher<T0, T1, T2, T3, T4, T5, T7>(value, origType, hasSwitched);
        }

        public OneOfSwitcher<T0, T1, T2, T3, T4, T5, T6> Switch(Action<T7> action)
        {
            SwitchIf<T7>(action);
            return new OneOfSwitcher<T0, T1, T2, T3, T4, T5, T6>(value, origType, hasSwitched);
        }

        void SwitchIf<T>(Action<T> action)
        {
            if (!hasSwitched && origType == typeof(T))
            {
                action((T)value);
                hasSwitched = true;
            }
        }

        public void Else(Action<object> action)
        {
            if (!hasSwitched) action(value);
        }

        public void ElseThrow(Func<object, Exception> func)
        {
            if (!hasSwitched) throw func(value);
        }
    }

    public struct OneOfSwitcher<T0, T1, T2, T3, T4, T5, T6, T7, T8>
    {
        readonly object value;
        readonly Type origType;
        bool hasSwitched;

        internal OneOfSwitcher(object value, Type origType) : this(value, origType, false) { }

        internal OneOfSwitcher(object value, Type origType, bool hasSwitched)
        {
            this.value = value;
            this.origType = origType;
            this.hasSwitched = hasSwitched;
        }

        public OneOfSwitcher<T1, T2, T3, T4, T5, T6, T7, T8> Switch(Action<T0> action)
        {
            SwitchIf<T0>(action);
            return new OneOfSwitcher<T1, T2, T3, T4, T5, T6, T7, T8>(value, origType, hasSwitched);
        }

        public OneOfSwitcher<T0, T2, T3, T4, T5, T6, T7, T8> Switch(Action<T1> action)
        {
            SwitchIf<T1>(action);
            return new OneOfSwitcher<T0, T2, T3, T4, T5, T6, T7, T8>(value, origType, hasSwitched);
        }

        public OneOfSwitcher<T0, T1, T3, T4, T5, T6, T7, T8> Switch(Action<T2> action)
        {
            SwitchIf<T2>(action);
            return new OneOfSwitcher<T0, T1, T3, T4, T5, T6, T7, T8>(value, origType, hasSwitched);
        }

        public OneOfSwitcher<T0, T1, T2, T4, T5, T6, T7, T8> Switch(Action<T3> action)
        {
            SwitchIf<T3>(action);
            return new OneOfSwitcher<T0, T1, T2, T4, T5, T6, T7, T8>(value, origType, hasSwitched);
        }

        public OneOfSwitcher<T0, T1, T2, T3, T5, T6, T7, T8> Switch(Action<T4> action)
        {
            SwitchIf<T4>(action);
            return new OneOfSwitcher<T0, T1, T2, T3, T5, T6, T7, T8>(value, origType, hasSwitched);
        }

        public OneOfSwitcher<T0, T1, T2, T3, T4, T6, T7, T8> Switch(Action<T5> action)
        {
            SwitchIf<T5>(action);
            return new OneOfSwitcher<T0, T1, T2, T3, T4, T6, T7, T8>(value, origType, hasSwitched);
        }

        public OneOfSwitcher<T0, T1, T2, T3, T4, T5, T7, T8> Switch(Action<T6> action)
        {
            SwitchIf<T6>(action);
            return new OneOfSwitcher<T0, T1, T2, T3, T4, T5, T7, T8>(value, origType, hasSwitched);
        }

        public OneOfSwitcher<T0, T1, T2, T3, T4, T5, T6, T8> Switch(Action<T7> action)
        {
            SwitchIf<T7>(action);
            return new OneOfSwitcher<T0, T1, T2, T3, T4, T5, T6, T8>(value, origType, hasSwitched);
        }

        public OneOfSwitcher<T0, T1, T2, T3, T4, T5, T6, T7> Switch(Action<T8> action)
        {
            SwitchIf<T8>(action);
            return new OneOfSwitcher<T0, T1, T2, T3, T4, T5, T6, T7>(value, origType, hasSwitched);
        }

        void SwitchIf<T>(Action<T> action)
        {
            if (!hasSwitched && origType == typeof(T))
            {
                action((T)value);
                hasSwitched = true;
            }
        }

        public void Else(Action<object> action)
        {
            if (!hasSwitched) action(value);
        }

        public void ElseThrow(Func<object, Exception> func)
        {
            if (!hasSwitched) throw func(value);
        }
    }

    public struct OneOfMatcher<T0, TResult>
    {
        readonly object value;
        readonly Type origType;
        object result;

        internal OneOfMatcher(object value, Type origType) : this(value, origType, null) { }

        internal OneOfMatcher(object value, Type origType, object result)
        {
            this.value = value;
            this.origType = origType;
            this.result = result;
        }
        public TResult Match(Func<T0, TResult> createResult)
        {
            MatchIf<T0>(createResult);
            return (TResult)result;
        }

        void MatchIf<T>(Func<T, TResult> createResult)
        {
            if (result == null && origType == typeof(T))
            {
                result = createResult((T)value);
            }
        }

        public TResult Else(TResult defaultValue)
        {
            if (result == null) result = defaultValue;
            return (TResult)result;
        }

        public TResult Else(Func<object, TResult> createResult)
        {
            if (result == null) result = createResult(value);
            return (TResult)result;
        }

        public TResult ElseThrow(Func<object, Exception> createException)
        {
            if (result == null) throw createException(value);
            return (TResult)result;
        }
    }

    public struct OneOfMatcher<T0, T1, TResult>
    {
        readonly object value;
        readonly Type origType;
        object result;

        internal OneOfMatcher(object value, Type origType) : this(value, origType, null) { }

        internal OneOfMatcher(object value, Type origType, object result)
        {
            this.value = value;
            this.origType = origType;
            this.result = result;
        }

        public OneOfMatcher<T1, TResult> Match(Func<T0, TResult> createResult)
        {
            MatchIf<T0>(createResult);
            return new OneOfMatcher<T1, TResult>(value, origType, result);
        }

        public OneOfMatcher<T0, TResult> Match(Func<T1, TResult> createResult)
        {
            MatchIf<T1>(createResult);
            return new OneOfMatcher<T0, TResult>(value, origType, result);
        }

        void MatchIf<T>(Func<T, TResult> createResult)
        {
            if (result == null && origType == typeof(T))
            {
                result = createResult((T)value);
            }
        }

        public TResult Else(TResult defaultValue)
        {
            if (result == null) result = defaultValue;
            return (TResult)result;
        }

        public TResult Else(Func<object, TResult> createResult)
        {
            if (result == null) result = createResult(value);
            return (TResult)result;
        }

        public TResult ElseThrow(Func<object, Exception> createException)
        {
            if (result == null) throw createException(value);
            return (TResult)result;
        }
    }

    public struct OneOfMatcher<T0, T1, T2, TResult>
    {
        readonly object value;
        readonly Type origType;
        object result;

        internal OneOfMatcher(object value, Type origType) : this(value, origType, null) { }

        internal OneOfMatcher(object value, Type origType, object result)
        {
            this.value = value;
            this.origType = origType;
            this.result = result;
        }

        public OneOfMatcher<T1, T2, TResult> Match(Func<T0, TResult> createResult)
        {
            MatchIf<T0>(createResult);
            return new OneOfMatcher<T1, T2, TResult>(value, origType, result);
        }

        public OneOfMatcher<T0, T2, TResult> Match(Func<T1, TResult> createResult)
        {
            MatchIf<T1>(createResult);
            return new OneOfMatcher<T0, T2, TResult>(value, origType, result);
        }

        public OneOfMatcher<T0, T1, TResult> Match(Func<T2, TResult> createResult)
        {
            MatchIf<T2>(createResult);
            return new OneOfMatcher<T0, T1, TResult>(value, origType, result);
        }

        void MatchIf<T>(Func<T, TResult> createResult)
        {
            if (result == null && origType == typeof(T))
            {
                result = createResult((T)value);
            }
        }

        public TResult Else(TResult defaultValue)
        {
            if (result == null) result = defaultValue;
            return (TResult)result;
        }

        public TResult Else(Func<object, TResult> createResult)
        {
            if (result == null) result = createResult(value);
            return (TResult)result;
        }

        public TResult ElseThrow(Func<object, Exception> createException)
        {
            if (result == null) throw createException(value);
            return (TResult)result;
        }
    }

    public struct OneOfMatcher<T0, T1, T2, T3, TResult>
    {
        readonly object value;
        readonly Type origType;
        object result;

        internal OneOfMatcher(object value, Type origType) : this(value, origType, null) { }

        internal OneOfMatcher(object value, Type origType, object result)
        {
            this.value = value;
            this.origType = origType;
            this.result = result;
        }

        public OneOfMatcher<T1, T2, T3, TResult> Match(Func<T0, TResult> createResult)
        {
            MatchIf<T0>(createResult);
            return new OneOfMatcher<T1, T2, T3, TResult>(value, origType, result);
        }

        public OneOfMatcher<T0, T2, T3, TResult> Match(Func<T1, TResult> createResult)
        {
            MatchIf<T1>(createResult);
            return new OneOfMatcher<T0, T2, T3, TResult>(value, origType, result);
        }

        public OneOfMatcher<T0, T1, T3, TResult> Match(Func<T2, TResult> createResult)
        {
            MatchIf<T2>(createResult);
            return new OneOfMatcher<T0, T1, T3, TResult>(value, origType, result);
        }

        public OneOfMatcher<T0, T1, T2, TResult> Match(Func<T3, TResult> createResult)
        {
            MatchIf<T3>(createResult);
            return new OneOfMatcher<T0, T1, T2, TResult>(value, origType, result);
        }

        void MatchIf<T>(Func<T, TResult> createResult)
        {
            if (result == null && origType == typeof(T))
            {
                result = createResult((T)value);
            }
        }

        public TResult Else(TResult defaultValue)
        {
            if (result == null) result = defaultValue;
            return (TResult)result;
        }

        public TResult Else(Func<object, TResult> createResult)
        {
            if (result == null) result = createResult(value);
            return (TResult)result;
        }

        public TResult ElseThrow(Func<object, Exception> createException)
        {
            if (result == null) throw createException(value);
            return (TResult)result;
        }
    }

    public struct OneOfMatcher<T0, T1, T2, T3, T4, TResult>
    {
        readonly object value;
        readonly Type origType;
        object result;

        internal OneOfMatcher(object value, Type origType) : this(value, origType, null) { }

        internal OneOfMatcher(object value, Type origType, object result)
        {
            this.value = value;
            this.origType = origType;
            this.result = result;
        }

        public OneOfMatcher<T1, T2, T3, T4, TResult> Match(Func<T0, TResult> createResult)
        {
            MatchIf<T0>(createResult);
            return new OneOfMatcher<T1, T2, T3, T4, TResult>(value, origType, result);
        }

        public OneOfMatcher<T0, T2, T3, T4, TResult> Match(Func<T1, TResult> createResult)
        {
            MatchIf<T1>(createResult);
            return new OneOfMatcher<T0, T2, T3, T4, TResult>(value, origType, result);
        }

        public OneOfMatcher<T0, T1, T3, T4, TResult> Match(Func<T2, TResult> createResult)
        {
            MatchIf<T2>(createResult);
            return new OneOfMatcher<T0, T1, T3, T4, TResult>(value, origType, result);
        }

        public OneOfMatcher<T0, T1, T2, T4, TResult> Match(Func<T3, TResult> createResult)
        {
            MatchIf<T3>(createResult);
            return new OneOfMatcher<T0, T1, T2, T4, TResult>(value, origType, result);
        }

        public OneOfMatcher<T0, T1, T2, T3, TResult> Match(Func<T4, TResult> createResult)
        {
            MatchIf<T4>(createResult);
            return new OneOfMatcher<T0, T1, T2, T3, TResult>(value, origType, result);
        }

        void MatchIf<T>(Func<T, TResult> createResult)
        {
            if (result == null && origType == typeof(T))
            {
                result = createResult((T)value);
            }
        }

        public TResult Else(TResult defaultValue)
        {
            if (result == null) result = defaultValue;
            return (TResult)result;
        }

        public TResult Else(Func<object, TResult> createResult)
        {
            if (result == null) result = createResult(value);
            return (TResult)result;
        }

        public TResult ElseThrow(Func<object, Exception> createException)
        {
            if (result == null) throw createException(value);
            return (TResult)result;
        }
    }

    public struct OneOfMatcher<T0, T1, T2, T3, T4, T5, TResult>
    {
        readonly object value;
        readonly Type origType;
        object result;

        internal OneOfMatcher(object value, Type origType) : this(value, origType, null) { }

        internal OneOfMatcher(object value, Type origType, object result)
        {
            this.value = value;
            this.origType = origType;
            this.result = result;
        }

        public OneOfMatcher<T1, T2, T3, T4, T5, TResult> Match(Func<T0, TResult> createResult)
        {
            MatchIf<T0>(createResult);
            return new OneOfMatcher<T1, T2, T3, T4, T5, TResult>(value, origType, result);
        }

        public OneOfMatcher<T0, T2, T3, T4, T5, TResult> Match(Func<T1, TResult> createResult)
        {
            MatchIf<T1>(createResult);
            return new OneOfMatcher<T0, T2, T3, T4, T5, TResult>(value, origType, result);
        }

        public OneOfMatcher<T0, T1, T3, T4, T5, TResult> Match(Func<T2, TResult> createResult)
        {
            MatchIf<T2>(createResult);
            return new OneOfMatcher<T0, T1, T3, T4, T5, TResult>(value, origType, result);
        }

        public OneOfMatcher<T0, T1, T2, T4, T5, TResult> Match(Func<T3, TResult> createResult)
        {
            MatchIf<T3>(createResult);
            return new OneOfMatcher<T0, T1, T2, T4, T5, TResult>(value, origType, result);
        }

        public OneOfMatcher<T0, T1, T2, T3, T5, TResult> Match(Func<T4, TResult> createResult)
        {
            MatchIf<T4>(createResult);
            return new OneOfMatcher<T0, T1, T2, T3, T5, TResult>(value, origType, result);
        }

        public OneOfMatcher<T0, T1, T2, T3, T4, TResult> Match(Func<T5, TResult> createResult)
        {
            MatchIf<T5>(createResult);
            return new OneOfMatcher<T0, T1, T2, T3, T4, TResult>(value, origType, result);
        }

        void MatchIf<T>(Func<T, TResult> createResult)
        {
            if (result == null && origType == typeof(T))
            {
                result = createResult((T)value);
            }
        }

        public TResult Else(TResult defaultValue)
        {
            if (result == null) result = defaultValue;
            return (TResult)result;
        }

        public TResult Else(Func<object, TResult> createResult)
        {
            if (result == null) result = createResult(value);
            return (TResult)result;
        }

        public TResult ElseThrow(Func<object, Exception> createException)
        {
            if (result == null) throw createException(value);
            return (TResult)result;
        }
    }

    public struct OneOfMatcher<T0, T1, T2, T3, T4, T5, T6, TResult>
    {
        readonly object value;
        readonly Type origType;
        object result;

        internal OneOfMatcher(object value, Type origType) : this(value, origType, null) { }

        internal OneOfMatcher(object value, Type origType, object result)
        {
            this.value = value;
            this.origType = origType;
            this.result = result;
        }

        public OneOfMatcher<T1, T2, T3, T4, T5, T6, TResult> Match(Func<T0, TResult> createResult)
        {
            MatchIf<T0>(createResult);
            return new OneOfMatcher<T1, T2, T3, T4, T5, T6, TResult>(value, origType, result);
        }

        public OneOfMatcher<T0, T2, T3, T4, T5, T6, TResult> Match(Func<T1, TResult> createResult)
        {
            MatchIf<T1>(createResult);
            return new OneOfMatcher<T0, T2, T3, T4, T5, T6, TResult>(value, origType, result);
        }

        public OneOfMatcher<T0, T1, T3, T4, T5, T6, TResult> Match(Func<T2, TResult> createResult)
        {
            MatchIf<T2>(createResult);
            return new OneOfMatcher<T0, T1, T3, T4, T5, T6, TResult>(value, origType, result);
        }

        public OneOfMatcher<T0, T1, T2, T4, T5, T6, TResult> Match(Func<T3, TResult> createResult)
        {
            MatchIf<T3>(createResult);
            return new OneOfMatcher<T0, T1, T2, T4, T5, T6, TResult>(value, origType, result);
        }

        public OneOfMatcher<T0, T1, T2, T3, T5, T6, TResult> Match(Func<T4, TResult> createResult)
        {
            MatchIf<T4>(createResult);
            return new OneOfMatcher<T0, T1, T2, T3, T5, T6, TResult>(value, origType, result);
        }

        public OneOfMatcher<T0, T1, T2, T3, T4, T6, TResult> Match(Func<T5, TResult> createResult)
        {
            MatchIf<T5>(createResult);
            return new OneOfMatcher<T0, T1, T2, T3, T4, T6, TResult>(value, origType, result);
        }

        public OneOfMatcher<T0, T1, T2, T3, T4, T5, TResult> Match(Func<T6, TResult> createResult)
        {
            MatchIf<T6>(createResult);
            return new OneOfMatcher<T0, T1, T2, T3, T4, T5, TResult>(value, origType, result);
        }

        void MatchIf<T>(Func<T, TResult> createResult)
        {
            if (result == null && origType == typeof(T))
            {
                result = createResult((T)value);
            }
        }

        public TResult Else(TResult defaultValue)
        {
            if (result == null) result = defaultValue;
            return (TResult)result;
        }

        public TResult Else(Func<object, TResult> createResult)
        {
            if (result == null) result = createResult(value);
            return (TResult)result;
        }

        public TResult ElseThrow(Func<object, Exception> createException)
        {
            if (result == null) throw createException(value);
            return (TResult)result;
        }
    }

    public struct OneOfMatcher<T0, T1, T2, T3, T4, T5, T6, T7, TResult>
    {
        readonly object value;
        readonly Type origType;
        object result;

        internal OneOfMatcher(object value, Type origType) : this(value, origType, null) { }

        internal OneOfMatcher(object value, Type origType, object result)
        {
            this.value = value;
            this.origType = origType;
            this.result = result;
        }

        public OneOfMatcher<T1, T2, T3, T4, T5, T6, T7, TResult> Match(Func<T0, TResult> createResult)
        {
            MatchIf<T0>(createResult);
            return new OneOfMatcher<T1, T2, T3, T4, T5, T6, T7, TResult>(value, origType, result);
        }

        public OneOfMatcher<T0, T2, T3, T4, T5, T6, T7, TResult> Match(Func<T1, TResult> createResult)
        {
            MatchIf<T1>(createResult);
            return new OneOfMatcher<T0, T2, T3, T4, T5, T6, T7, TResult>(value, origType, result);
        }

        public OneOfMatcher<T0, T1, T3, T4, T5, T6, T7, TResult> Match(Func<T2, TResult> createResult)
        {
            MatchIf<T2>(createResult);
            return new OneOfMatcher<T0, T1, T3, T4, T5, T6, T7, TResult>(value, origType, result);
        }

        public OneOfMatcher<T0, T1, T2, T4, T5, T6, T7, TResult> Match(Func<T3, TResult> createResult)
        {
            MatchIf<T3>(createResult);
            return new OneOfMatcher<T0, T1, T2, T4, T5, T6, T7, TResult>(value, origType, result);
        }

        public OneOfMatcher<T0, T1, T2, T3, T5, T6, T7, TResult> Match(Func<T4, TResult> createResult)
        {
            MatchIf<T4>(createResult);
            return new OneOfMatcher<T0, T1, T2, T3, T5, T6, T7, TResult>(value, origType, result);
        }

        public OneOfMatcher<T0, T1, T2, T3, T4, T6, T7, TResult> Match(Func<T5, TResult> createResult)
        {
            MatchIf<T5>(createResult);
            return new OneOfMatcher<T0, T1, T2, T3, T4, T6, T7, TResult>(value, origType, result);
        }

        public OneOfMatcher<T0, T1, T2, T3, T4, T5, T7, TResult> Match(Func<T6, TResult> createResult)
        {
            MatchIf<T6>(createResult);
            return new OneOfMatcher<T0, T1, T2, T3, T4, T5, T7, TResult>(value, origType, result);
        }

        public OneOfMatcher<T0, T1, T2, T3, T4, T5, T6, TResult> Match(Func<T7, TResult> createResult)
        {
            MatchIf<T7>(createResult);
            return new OneOfMatcher<T0, T1, T2, T3, T4, T5, T6, TResult>(value, origType, result);
        }

        void MatchIf<T>(Func<T, TResult> createResult)
        {
            if (result == null && origType == typeof(T))
            {
                result = createResult((T)value);
            }
        }

        public TResult Else(TResult defaultValue)
        {
            if (result == null) result = defaultValue;
            return (TResult)result;
        }

        public TResult Else(Func<object, TResult> createResult)
        {
            if (result == null) result = createResult(value);
            return (TResult)result;
        }

        public TResult ElseThrow(Func<object, Exception> createException)
        {
            if (result == null) throw createException(value);
            return (TResult)result;
        }
    }

    public struct OneOfMatcher<T0, T1, T2, T3, T4, T5, T6, T7, T8, TResult>
    {
        readonly object value;
        readonly Type origType;
        object result;

        internal OneOfMatcher(object value, Type origType) : this(value, origType, null) { }

        internal OneOfMatcher(object value, Type origType, object result)
        {
            this.value = value;
            this.origType = origType;
            this.result = result;
        }

        public OneOfMatcher<T1, T2, T3, T4, T5, T6, T7, T8, TResult> Match(Func<T0, TResult> createResult)
        {
            MatchIf<T0>(createResult);
            return new OneOfMatcher<T1, T2, T3, T4, T5, T6, T7, T8, TResult>(value, origType, result);
        }

        public OneOfMatcher<T0, T2, T3, T4, T5, T6, T7, T8, TResult> Match(Func<T1, TResult> createResult)
        {
            MatchIf<T1>(createResult);
            return new OneOfMatcher<T0, T2, T3, T4, T5, T6, T7, T8, TResult>(value, origType, result);
        }

        public OneOfMatcher<T0, T1, T3, T4, T5, T6, T7, T8, TResult> Match(Func<T2, TResult> createResult)
        {
            MatchIf<T2>(createResult);
            return new OneOfMatcher<T0, T1, T3, T4, T5, T6, T7, T8, TResult>(value, origType, result);
        }

        public OneOfMatcher<T0, T1, T2, T4, T5, T6, T7, T8, TResult> Match(Func<T3, TResult> createResult)
        {
            MatchIf<T3>(createResult);
            return new OneOfMatcher<T0, T1, T2, T4, T5, T6, T7, T8, TResult>(value, origType, result);
        }

        public OneOfMatcher<T0, T1, T2, T3, T5, T6, T7, T8, TResult> Match(Func<T4, TResult> createResult)
        {
            MatchIf<T4>(createResult);
            return new OneOfMatcher<T0, T1, T2, T3, T5, T6, T7, T8, TResult>(value, origType, result);
        }

        public OneOfMatcher<T0, T1, T2, T3, T4, T6, T7, T8, TResult> Match(Func<T5, TResult> createResult)
        {
            MatchIf<T5>(createResult);
            return new OneOfMatcher<T0, T1, T2, T3, T4, T6, T7, T8, TResult>(value, origType, result);
        }

        public OneOfMatcher<T0, T1, T2, T3, T4, T5, T7, T8, TResult> Match(Func<T6, TResult> createResult)
        {
            MatchIf<T6>(createResult);
            return new OneOfMatcher<T0, T1, T2, T3, T4, T5, T7, T8, TResult>(value, origType, result);
        }

        public OneOfMatcher<T0, T1, T2, T3, T4, T5, T6, T8, TResult> Match(Func<T7, TResult> createResult)
        {
            MatchIf<T7>(createResult);
            return new OneOfMatcher<T0, T1, T2, T3, T4, T5, T6, T8, TResult>(value, origType, result);
        }

        public OneOfMatcher<T0, T1, T2, T3, T4, T5, T6, T7, TResult> Match(Func<T8, TResult> createResult)
        {
            MatchIf<T8>(createResult);
            return new OneOfMatcher<T0, T1, T2, T3, T4, T5, T6, T7, TResult>(value, origType, result);
        }

        void MatchIf<T>(Func<T, TResult> createResult)
        {
            if (result == null && origType == typeof(T))
            {
                result = createResult((T)value);
            }
        }

        public TResult Else(TResult defaultValue)
        {
            if (result == null) result = defaultValue;
            return (TResult)result;
        }

        public TResult Else(Func<object, TResult> createResult)
        {
            if (result == null) result = createResult(value);
            return (TResult)result;
        }

        public TResult ElseThrow(Func<object, Exception> createException)
        {
            if (result == null) throw createException(value);
            return (TResult)result;
        }
    }
}
