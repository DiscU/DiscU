// ===========================================================================
// Generated by OneOf.tt
// ===========================================================================

using System;
using Newtonsoft.Json;

namespace OneOf
{
    [JsonConverter(typeof(OneOfJsonConverter))]
    public struct OneOf<T0> : IOneOf
    {
        readonly object value;
        static readonly Type typeT0 = typeof(T0);

        OneOf(object value)
        {
            // assumes will only be called after being validated in some way
            this.value = value;
        }

        internal static OneOf<T0> Create(object value)
        {
            if (value == null) throw new ArgumentNullException("value");

            var valueType = value.GetType();
            if (valueType == typeT0) return new OneOf<T0>((T0)value);

            throw new ArgumentException("value");
        }

        void EnsureValueNotNull()
        {
            if (value == null) throw new InvalidOperationException("Value has not been set");
        }

        object IOneOf.Value => value;

        public bool Is<T>()
        {
            EnsureValueNotNull();
            if (this.value.GetType() == typeof(T)) return true;

            return false;
        }

        public T As<T>()
        {
            EnsureValueNotNull();
            if (this.value.GetType() == typeof(T)) return (T)this.value;

            throw new InvalidOperationException();
        }

        // Use slower Create method which does full type checks at runtime as compiler couldn't do them for us.
        public OneOf<N0> ToOneOf<N0>() => OneOf<N0>.Create(value);
        public OneOf<N0, N1> ToOneOf<N0, N1>() => OneOf<N0, N1>.Create(value);
        public OneOf<N0, N1, N2> ToOneOf<N0, N1, N2>() => OneOf<N0, N1, N2>.Create(value);
        public OneOf<N0, N1, N2, N3> ToOneOf<N0, N1, N2, N3>() => OneOf<N0, N1, N2, N3>.Create(value);
        public OneOf<N0, N1, N2, N3, N4> ToOneOf<N0, N1, N2, N3, N4>() => OneOf<N0, N1, N2, N3, N4>.Create(value);
        public OneOf<N0, N1, N2, N3, N4, N5> ToOneOf<N0, N1, N2, N3, N4, N5>() => OneOf<N0, N1, N2, N3, N4, N5>.Create(value);
        public OneOf<N0, N1, N2, N3, N4, N5, N6> ToOneOf<N0, N1, N2, N3, N4, N5, N6>() => OneOf<N0, N1, N2, N3, N4, N5, N6>.Create(value);
        public OneOf<N0, N1, N2, N3, N4, N5, N6, N7> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7>() => OneOf<N0, N1, N2, N3, N4, N5, N6, N7>.Create(value);
        public OneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8>() => OneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8>.Create(value);

        // Can use fast Ctor as compiler can check types for us.
        public static implicit operator OneOf<T0>(T0 value) => new OneOf<T0>(value);

        public OneOfSwitcher Switch()
        {
            EnsureValueNotNull();
            return new OneOfSwitcher(value);
        }

        public OneOfMatcher<T> Match<T>()
        {
            EnsureValueNotNull();
            return new OneOfMatcher<T>(value);
        }

        public override bool Equals(object obj)
        {
            if (!(obj is OneOf<T0>)) return false;

            var other = (OneOf<T0>)obj;
            return Equals(value, other.value);
        }

        public override int GetHashCode() => (value?.GetHashCode() ?? 0);

        public override string ToString() => (value?.ToString() ?? "");
    }

    [JsonConverter(typeof(OneOfJsonConverter))]
    public struct OneOf<T0, T1> : IOneOf
    {
        readonly object value;
        static readonly Type typeT0 = typeof(T0);
        static readonly Type typeT1 = typeof(T1);

        OneOf(object value)
        {
            // assumes will only be called after being validated in some way
            this.value = value;
        }

        internal static OneOf<T0, T1> Create(object value)
        {
            if (value == null) throw new ArgumentNullException("value");

            var valueType = value.GetType();
            if (valueType == typeT0) return new OneOf<T0, T1>((T0)value);
            if (valueType == typeT1) return new OneOf<T0, T1>((T1)value);

            throw new ArgumentException("value");
        }

        void EnsureValueNotNull()
        {
            if (value == null) throw new InvalidOperationException("Value has not been set");
        }

        object IOneOf.Value => value;

        public bool Is<T>()
        {
            EnsureValueNotNull();
            if (this.value.GetType() == typeof(T)) return true;

            return false;
        }

        public T As<T>()
        {
            EnsureValueNotNull();
            if (this.value.GetType() == typeof(T)) return (T)this.value;

            throw new InvalidOperationException();
        }

        // Use slower Create method which does full type checks at runtime as compiler couldn't do them for us.
        public OneOf<N0> ToOneOf<N0>() => OneOf<N0>.Create(value);
        public OneOf<N0, N1> ToOneOf<N0, N1>() => OneOf<N0, N1>.Create(value);
        public OneOf<N0, N1, N2> ToOneOf<N0, N1, N2>() => OneOf<N0, N1, N2>.Create(value);
        public OneOf<N0, N1, N2, N3> ToOneOf<N0, N1, N2, N3>() => OneOf<N0, N1, N2, N3>.Create(value);
        public OneOf<N0, N1, N2, N3, N4> ToOneOf<N0, N1, N2, N3, N4>() => OneOf<N0, N1, N2, N3, N4>.Create(value);
        public OneOf<N0, N1, N2, N3, N4, N5> ToOneOf<N0, N1, N2, N3, N4, N5>() => OneOf<N0, N1, N2, N3, N4, N5>.Create(value);
        public OneOf<N0, N1, N2, N3, N4, N5, N6> ToOneOf<N0, N1, N2, N3, N4, N5, N6>() => OneOf<N0, N1, N2, N3, N4, N5, N6>.Create(value);
        public OneOf<N0, N1, N2, N3, N4, N5, N6, N7> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7>() => OneOf<N0, N1, N2, N3, N4, N5, N6, N7>.Create(value);
        public OneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8>() => OneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8>.Create(value);

        // Can use fast Ctor as compiler can check types for us.
        public static implicit operator OneOf<T0, T1>(T0 value) => new OneOf<T0, T1>(value);
        public static implicit operator OneOf<T0, T1>(T1 value) => new OneOf<T0, T1>(value);

        public OneOfSwitcher Switch()
        {
            EnsureValueNotNull();
            return new OneOfSwitcher(value);
        }

        public OneOfMatcher<T> Match<T>()
        {
            EnsureValueNotNull();
            return new OneOfMatcher<T>(value);
        }

        public override bool Equals(object obj)
        {
            if (!(obj is OneOf<T0, T1>)) return false;

            var other = (OneOf<T0, T1>)obj;
            return Equals(value, other.value);
        }

        public override int GetHashCode() => (value?.GetHashCode() ?? 0);

        public override string ToString() => (value?.ToString() ?? "");
    }

    [JsonConverter(typeof(OneOfJsonConverter))]
    public struct OneOf<T0, T1, T2> : IOneOf
    {
        readonly object value;
        static readonly Type typeT0 = typeof(T0);
        static readonly Type typeT1 = typeof(T1);
        static readonly Type typeT2 = typeof(T2);

        OneOf(object value)
        {
            // assumes will only be called after being validated in some way
            this.value = value;
        }

        internal static OneOf<T0, T1, T2> Create(object value)
        {
            if (value == null) throw new ArgumentNullException("value");

            var valueType = value.GetType();
            if (valueType == typeT0) return new OneOf<T0, T1, T2>((T0)value);
            if (valueType == typeT1) return new OneOf<T0, T1, T2>((T1)value);
            if (valueType == typeT2) return new OneOf<T0, T1, T2>((T2)value);

            throw new ArgumentException("value");
        }

        void EnsureValueNotNull()
        {
            if (value == null) throw new InvalidOperationException("Value has not been set");
        }

        object IOneOf.Value => value;

        public bool Is<T>()
        {
            EnsureValueNotNull();
            if (this.value.GetType() == typeof(T)) return true;

            return false;
        }

        public T As<T>()
        {
            EnsureValueNotNull();
            if (this.value.GetType() == typeof(T)) return (T)this.value;

            throw new InvalidOperationException();
        }

        // Use slower Create method which does full type checks at runtime as compiler couldn't do them for us.
        public OneOf<N0> ToOneOf<N0>() => OneOf<N0>.Create(value);
        public OneOf<N0, N1> ToOneOf<N0, N1>() => OneOf<N0, N1>.Create(value);
        public OneOf<N0, N1, N2> ToOneOf<N0, N1, N2>() => OneOf<N0, N1, N2>.Create(value);
        public OneOf<N0, N1, N2, N3> ToOneOf<N0, N1, N2, N3>() => OneOf<N0, N1, N2, N3>.Create(value);
        public OneOf<N0, N1, N2, N3, N4> ToOneOf<N0, N1, N2, N3, N4>() => OneOf<N0, N1, N2, N3, N4>.Create(value);
        public OneOf<N0, N1, N2, N3, N4, N5> ToOneOf<N0, N1, N2, N3, N4, N5>() => OneOf<N0, N1, N2, N3, N4, N5>.Create(value);
        public OneOf<N0, N1, N2, N3, N4, N5, N6> ToOneOf<N0, N1, N2, N3, N4, N5, N6>() => OneOf<N0, N1, N2, N3, N4, N5, N6>.Create(value);
        public OneOf<N0, N1, N2, N3, N4, N5, N6, N7> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7>() => OneOf<N0, N1, N2, N3, N4, N5, N6, N7>.Create(value);
        public OneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8>() => OneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8>.Create(value);

        // Can use fast Ctor as compiler can check types for us.
        public static implicit operator OneOf<T0, T1, T2>(T0 value) => new OneOf<T0, T1, T2>(value);
        public static implicit operator OneOf<T0, T1, T2>(T1 value) => new OneOf<T0, T1, T2>(value);
        public static implicit operator OneOf<T0, T1, T2>(T2 value) => new OneOf<T0, T1, T2>(value);

        public OneOfSwitcher Switch()
        {
            EnsureValueNotNull();
            return new OneOfSwitcher(value);
        }

        public OneOfMatcher<T> Match<T>()
        {
            EnsureValueNotNull();
            return new OneOfMatcher<T>(value);
        }

        public override bool Equals(object obj)
        {
            if (!(obj is OneOf<T0, T1, T2>)) return false;

            var other = (OneOf<T0, T1, T2>)obj;
            return Equals(value, other.value);
        }

        public override int GetHashCode() => (value?.GetHashCode() ?? 0);

        public override string ToString() => (value?.ToString() ?? "");
    }

    [JsonConverter(typeof(OneOfJsonConverter))]
    public struct OneOf<T0, T1, T2, T3> : IOneOf
    {
        readonly object value;
        static readonly Type typeT0 = typeof(T0);
        static readonly Type typeT1 = typeof(T1);
        static readonly Type typeT2 = typeof(T2);
        static readonly Type typeT3 = typeof(T3);

        OneOf(object value)
        {
            // assumes will only be called after being validated in some way
            this.value = value;
        }

        internal static OneOf<T0, T1, T2, T3> Create(object value)
        {
            if (value == null) throw new ArgumentNullException("value");

            var valueType = value.GetType();
            if (valueType == typeT0) return new OneOf<T0, T1, T2, T3>((T0)value);
            if (valueType == typeT1) return new OneOf<T0, T1, T2, T3>((T1)value);
            if (valueType == typeT2) return new OneOf<T0, T1, T2, T3>((T2)value);
            if (valueType == typeT3) return new OneOf<T0, T1, T2, T3>((T3)value);

            throw new ArgumentException("value");
        }

        void EnsureValueNotNull()
        {
            if (value == null) throw new InvalidOperationException("Value has not been set");
        }

        object IOneOf.Value => value;

        public bool Is<T>()
        {
            EnsureValueNotNull();
            if (this.value.GetType() == typeof(T)) return true;

            return false;
        }

        public T As<T>()
        {
            EnsureValueNotNull();
            if (this.value.GetType() == typeof(T)) return (T)this.value;

            throw new InvalidOperationException();
        }

        // Use slower Create method which does full type checks at runtime as compiler couldn't do them for us.
        public OneOf<N0> ToOneOf<N0>() => OneOf<N0>.Create(value);
        public OneOf<N0, N1> ToOneOf<N0, N1>() => OneOf<N0, N1>.Create(value);
        public OneOf<N0, N1, N2> ToOneOf<N0, N1, N2>() => OneOf<N0, N1, N2>.Create(value);
        public OneOf<N0, N1, N2, N3> ToOneOf<N0, N1, N2, N3>() => OneOf<N0, N1, N2, N3>.Create(value);
        public OneOf<N0, N1, N2, N3, N4> ToOneOf<N0, N1, N2, N3, N4>() => OneOf<N0, N1, N2, N3, N4>.Create(value);
        public OneOf<N0, N1, N2, N3, N4, N5> ToOneOf<N0, N1, N2, N3, N4, N5>() => OneOf<N0, N1, N2, N3, N4, N5>.Create(value);
        public OneOf<N0, N1, N2, N3, N4, N5, N6> ToOneOf<N0, N1, N2, N3, N4, N5, N6>() => OneOf<N0, N1, N2, N3, N4, N5, N6>.Create(value);
        public OneOf<N0, N1, N2, N3, N4, N5, N6, N7> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7>() => OneOf<N0, N1, N2, N3, N4, N5, N6, N7>.Create(value);
        public OneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8>() => OneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8>.Create(value);

        // Can use fast Ctor as compiler can check types for us.
        public static implicit operator OneOf<T0, T1, T2, T3>(T0 value) => new OneOf<T0, T1, T2, T3>(value);
        public static implicit operator OneOf<T0, T1, T2, T3>(T1 value) => new OneOf<T0, T1, T2, T3>(value);
        public static implicit operator OneOf<T0, T1, T2, T3>(T2 value) => new OneOf<T0, T1, T2, T3>(value);
        public static implicit operator OneOf<T0, T1, T2, T3>(T3 value) => new OneOf<T0, T1, T2, T3>(value);

        public OneOfSwitcher Switch()
        {
            EnsureValueNotNull();
            return new OneOfSwitcher(value);
        }

        public OneOfMatcher<T> Match<T>()
        {
            EnsureValueNotNull();
            return new OneOfMatcher<T>(value);
        }

        public override bool Equals(object obj)
        {
            if (!(obj is OneOf<T0, T1, T2, T3>)) return false;

            var other = (OneOf<T0, T1, T2, T3>)obj;
            return Equals(value, other.value);
        }

        public override int GetHashCode() => (value?.GetHashCode() ?? 0);

        public override string ToString() => (value?.ToString() ?? "");
    }

    [JsonConverter(typeof(OneOfJsonConverter))]
    public struct OneOf<T0, T1, T2, T3, T4> : IOneOf
    {
        readonly object value;
        static readonly Type typeT0 = typeof(T0);
        static readonly Type typeT1 = typeof(T1);
        static readonly Type typeT2 = typeof(T2);
        static readonly Type typeT3 = typeof(T3);
        static readonly Type typeT4 = typeof(T4);

        OneOf(object value)
        {
            // assumes will only be called after being validated in some way
            this.value = value;
        }

        internal static OneOf<T0, T1, T2, T3, T4> Create(object value)
        {
            if (value == null) throw new ArgumentNullException("value");

            var valueType = value.GetType();
            if (valueType == typeT0) return new OneOf<T0, T1, T2, T3, T4>((T0)value);
            if (valueType == typeT1) return new OneOf<T0, T1, T2, T3, T4>((T1)value);
            if (valueType == typeT2) return new OneOf<T0, T1, T2, T3, T4>((T2)value);
            if (valueType == typeT3) return new OneOf<T0, T1, T2, T3, T4>((T3)value);
            if (valueType == typeT4) return new OneOf<T0, T1, T2, T3, T4>((T4)value);

            throw new ArgumentException("value");
        }

        void EnsureValueNotNull()
        {
            if (value == null) throw new InvalidOperationException("Value has not been set");
        }

        object IOneOf.Value => value;

        public bool Is<T>()
        {
            EnsureValueNotNull();
            if (this.value.GetType() == typeof(T)) return true;

            return false;
        }

        public T As<T>()
        {
            EnsureValueNotNull();
            if (this.value.GetType() == typeof(T)) return (T)this.value;

            throw new InvalidOperationException();
        }

        // Use slower Create method which does full type checks at runtime as compiler couldn't do them for us.
        public OneOf<N0> ToOneOf<N0>() => OneOf<N0>.Create(value);
        public OneOf<N0, N1> ToOneOf<N0, N1>() => OneOf<N0, N1>.Create(value);
        public OneOf<N0, N1, N2> ToOneOf<N0, N1, N2>() => OneOf<N0, N1, N2>.Create(value);
        public OneOf<N0, N1, N2, N3> ToOneOf<N0, N1, N2, N3>() => OneOf<N0, N1, N2, N3>.Create(value);
        public OneOf<N0, N1, N2, N3, N4> ToOneOf<N0, N1, N2, N3, N4>() => OneOf<N0, N1, N2, N3, N4>.Create(value);
        public OneOf<N0, N1, N2, N3, N4, N5> ToOneOf<N0, N1, N2, N3, N4, N5>() => OneOf<N0, N1, N2, N3, N4, N5>.Create(value);
        public OneOf<N0, N1, N2, N3, N4, N5, N6> ToOneOf<N0, N1, N2, N3, N4, N5, N6>() => OneOf<N0, N1, N2, N3, N4, N5, N6>.Create(value);
        public OneOf<N0, N1, N2, N3, N4, N5, N6, N7> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7>() => OneOf<N0, N1, N2, N3, N4, N5, N6, N7>.Create(value);
        public OneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8>() => OneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8>.Create(value);

        // Can use fast Ctor as compiler can check types for us.
        public static implicit operator OneOf<T0, T1, T2, T3, T4>(T0 value) => new OneOf<T0, T1, T2, T3, T4>(value);
        public static implicit operator OneOf<T0, T1, T2, T3, T4>(T1 value) => new OneOf<T0, T1, T2, T3, T4>(value);
        public static implicit operator OneOf<T0, T1, T2, T3, T4>(T2 value) => new OneOf<T0, T1, T2, T3, T4>(value);
        public static implicit operator OneOf<T0, T1, T2, T3, T4>(T3 value) => new OneOf<T0, T1, T2, T3, T4>(value);
        public static implicit operator OneOf<T0, T1, T2, T3, T4>(T4 value) => new OneOf<T0, T1, T2, T3, T4>(value);

        public OneOfSwitcher Switch()
        {
            EnsureValueNotNull();
            return new OneOfSwitcher(value);
        }

        public OneOfMatcher<T> Match<T>()
        {
            EnsureValueNotNull();
            return new OneOfMatcher<T>(value);
        }

        public override bool Equals(object obj)
        {
            if (!(obj is OneOf<T0, T1, T2, T3, T4>)) return false;

            var other = (OneOf<T0, T1, T2, T3, T4>)obj;
            return Equals(value, other.value);
        }

        public override int GetHashCode() => (value?.GetHashCode() ?? 0);

        public override string ToString() => (value?.ToString() ?? "");
    }

    [JsonConverter(typeof(OneOfJsonConverter))]
    public struct OneOf<T0, T1, T2, T3, T4, T5> : IOneOf
    {
        readonly object value;
        static readonly Type typeT0 = typeof(T0);
        static readonly Type typeT1 = typeof(T1);
        static readonly Type typeT2 = typeof(T2);
        static readonly Type typeT3 = typeof(T3);
        static readonly Type typeT4 = typeof(T4);
        static readonly Type typeT5 = typeof(T5);

        OneOf(object value)
        {
            // assumes will only be called after being validated in some way
            this.value = value;
        }

        internal static OneOf<T0, T1, T2, T3, T4, T5> Create(object value)
        {
            if (value == null) throw new ArgumentNullException("value");

            var valueType = value.GetType();
            if (valueType == typeT0) return new OneOf<T0, T1, T2, T3, T4, T5>((T0)value);
            if (valueType == typeT1) return new OneOf<T0, T1, T2, T3, T4, T5>((T1)value);
            if (valueType == typeT2) return new OneOf<T0, T1, T2, T3, T4, T5>((T2)value);
            if (valueType == typeT3) return new OneOf<T0, T1, T2, T3, T4, T5>((T3)value);
            if (valueType == typeT4) return new OneOf<T0, T1, T2, T3, T4, T5>((T4)value);
            if (valueType == typeT5) return new OneOf<T0, T1, T2, T3, T4, T5>((T5)value);

            throw new ArgumentException("value");
        }

        void EnsureValueNotNull()
        {
            if (value == null) throw new InvalidOperationException("Value has not been set");
        }

        object IOneOf.Value => value;

        public bool Is<T>()
        {
            EnsureValueNotNull();
            if (this.value.GetType() == typeof(T)) return true;

            return false;
        }

        public T As<T>()
        {
            EnsureValueNotNull();
            if (this.value.GetType() == typeof(T)) return (T)this.value;

            throw new InvalidOperationException();
        }

        // Use slower Create method which does full type checks at runtime as compiler couldn't do them for us.
        public OneOf<N0> ToOneOf<N0>() => OneOf<N0>.Create(value);
        public OneOf<N0, N1> ToOneOf<N0, N1>() => OneOf<N0, N1>.Create(value);
        public OneOf<N0, N1, N2> ToOneOf<N0, N1, N2>() => OneOf<N0, N1, N2>.Create(value);
        public OneOf<N0, N1, N2, N3> ToOneOf<N0, N1, N2, N3>() => OneOf<N0, N1, N2, N3>.Create(value);
        public OneOf<N0, N1, N2, N3, N4> ToOneOf<N0, N1, N2, N3, N4>() => OneOf<N0, N1, N2, N3, N4>.Create(value);
        public OneOf<N0, N1, N2, N3, N4, N5> ToOneOf<N0, N1, N2, N3, N4, N5>() => OneOf<N0, N1, N2, N3, N4, N5>.Create(value);
        public OneOf<N0, N1, N2, N3, N4, N5, N6> ToOneOf<N0, N1, N2, N3, N4, N5, N6>() => OneOf<N0, N1, N2, N3, N4, N5, N6>.Create(value);
        public OneOf<N0, N1, N2, N3, N4, N5, N6, N7> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7>() => OneOf<N0, N1, N2, N3, N4, N5, N6, N7>.Create(value);
        public OneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8>() => OneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8>.Create(value);

        // Can use fast Ctor as compiler can check types for us.
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5>(T0 value) => new OneOf<T0, T1, T2, T3, T4, T5>(value);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5>(T1 value) => new OneOf<T0, T1, T2, T3, T4, T5>(value);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5>(T2 value) => new OneOf<T0, T1, T2, T3, T4, T5>(value);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5>(T3 value) => new OneOf<T0, T1, T2, T3, T4, T5>(value);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5>(T4 value) => new OneOf<T0, T1, T2, T3, T4, T5>(value);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5>(T5 value) => new OneOf<T0, T1, T2, T3, T4, T5>(value);

        public OneOfSwitcher Switch()
        {
            EnsureValueNotNull();
            return new OneOfSwitcher(value);
        }

        public OneOfMatcher<T> Match<T>()
        {
            EnsureValueNotNull();
            return new OneOfMatcher<T>(value);
        }

        public override bool Equals(object obj)
        {
            if (!(obj is OneOf<T0, T1, T2, T3, T4, T5>)) return false;

            var other = (OneOf<T0, T1, T2, T3, T4, T5>)obj;
            return Equals(value, other.value);
        }

        public override int GetHashCode() => (value?.GetHashCode() ?? 0);

        public override string ToString() => (value?.ToString() ?? "");
    }

    [JsonConverter(typeof(OneOfJsonConverter))]
    public struct OneOf<T0, T1, T2, T3, T4, T5, T6> : IOneOf
    {
        readonly object value;
        static readonly Type typeT0 = typeof(T0);
        static readonly Type typeT1 = typeof(T1);
        static readonly Type typeT2 = typeof(T2);
        static readonly Type typeT3 = typeof(T3);
        static readonly Type typeT4 = typeof(T4);
        static readonly Type typeT5 = typeof(T5);
        static readonly Type typeT6 = typeof(T6);

        OneOf(object value)
        {
            // assumes will only be called after being validated in some way
            this.value = value;
        }

        internal static OneOf<T0, T1, T2, T3, T4, T5, T6> Create(object value)
        {
            if (value == null) throw new ArgumentNullException("value");

            var valueType = value.GetType();
            if (valueType == typeT0) return new OneOf<T0, T1, T2, T3, T4, T5, T6>((T0)value);
            if (valueType == typeT1) return new OneOf<T0, T1, T2, T3, T4, T5, T6>((T1)value);
            if (valueType == typeT2) return new OneOf<T0, T1, T2, T3, T4, T5, T6>((T2)value);
            if (valueType == typeT3) return new OneOf<T0, T1, T2, T3, T4, T5, T6>((T3)value);
            if (valueType == typeT4) return new OneOf<T0, T1, T2, T3, T4, T5, T6>((T4)value);
            if (valueType == typeT5) return new OneOf<T0, T1, T2, T3, T4, T5, T6>((T5)value);
            if (valueType == typeT6) return new OneOf<T0, T1, T2, T3, T4, T5, T6>((T6)value);

            throw new ArgumentException("value");
        }

        void EnsureValueNotNull()
        {
            if (value == null) throw new InvalidOperationException("Value has not been set");
        }

        object IOneOf.Value => value;

        public bool Is<T>()
        {
            EnsureValueNotNull();
            if (this.value.GetType() == typeof(T)) return true;

            return false;
        }

        public T As<T>()
        {
            EnsureValueNotNull();
            if (this.value.GetType() == typeof(T)) return (T)this.value;

            throw new InvalidOperationException();
        }

        // Use slower Create method which does full type checks at runtime as compiler couldn't do them for us.
        public OneOf<N0> ToOneOf<N0>() => OneOf<N0>.Create(value);
        public OneOf<N0, N1> ToOneOf<N0, N1>() => OneOf<N0, N1>.Create(value);
        public OneOf<N0, N1, N2> ToOneOf<N0, N1, N2>() => OneOf<N0, N1, N2>.Create(value);
        public OneOf<N0, N1, N2, N3> ToOneOf<N0, N1, N2, N3>() => OneOf<N0, N1, N2, N3>.Create(value);
        public OneOf<N0, N1, N2, N3, N4> ToOneOf<N0, N1, N2, N3, N4>() => OneOf<N0, N1, N2, N3, N4>.Create(value);
        public OneOf<N0, N1, N2, N3, N4, N5> ToOneOf<N0, N1, N2, N3, N4, N5>() => OneOf<N0, N1, N2, N3, N4, N5>.Create(value);
        public OneOf<N0, N1, N2, N3, N4, N5, N6> ToOneOf<N0, N1, N2, N3, N4, N5, N6>() => OneOf<N0, N1, N2, N3, N4, N5, N6>.Create(value);
        public OneOf<N0, N1, N2, N3, N4, N5, N6, N7> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7>() => OneOf<N0, N1, N2, N3, N4, N5, N6, N7>.Create(value);
        public OneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8>() => OneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8>.Create(value);

        // Can use fast Ctor as compiler can check types for us.
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5, T6>(T0 value) => new OneOf<T0, T1, T2, T3, T4, T5, T6>(value);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5, T6>(T1 value) => new OneOf<T0, T1, T2, T3, T4, T5, T6>(value);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5, T6>(T2 value) => new OneOf<T0, T1, T2, T3, T4, T5, T6>(value);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5, T6>(T3 value) => new OneOf<T0, T1, T2, T3, T4, T5, T6>(value);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5, T6>(T4 value) => new OneOf<T0, T1, T2, T3, T4, T5, T6>(value);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5, T6>(T5 value) => new OneOf<T0, T1, T2, T3, T4, T5, T6>(value);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5, T6>(T6 value) => new OneOf<T0, T1, T2, T3, T4, T5, T6>(value);

        public OneOfSwitcher Switch()
        {
            EnsureValueNotNull();
            return new OneOfSwitcher(value);
        }

        public OneOfMatcher<T> Match<T>()
        {
            EnsureValueNotNull();
            return new OneOfMatcher<T>(value);
        }

        public override bool Equals(object obj)
        {
            if (!(obj is OneOf<T0, T1, T2, T3, T4, T5, T6>)) return false;

            var other = (OneOf<T0, T1, T2, T3, T4, T5, T6>)obj;
            return Equals(value, other.value);
        }

        public override int GetHashCode() => (value?.GetHashCode() ?? 0);

        public override string ToString() => (value?.ToString() ?? "");
    }

    [JsonConverter(typeof(OneOfJsonConverter))]
    public struct OneOf<T0, T1, T2, T3, T4, T5, T6, T7> : IOneOf
    {
        readonly object value;
        static readonly Type typeT0 = typeof(T0);
        static readonly Type typeT1 = typeof(T1);
        static readonly Type typeT2 = typeof(T2);
        static readonly Type typeT3 = typeof(T3);
        static readonly Type typeT4 = typeof(T4);
        static readonly Type typeT5 = typeof(T5);
        static readonly Type typeT6 = typeof(T6);
        static readonly Type typeT7 = typeof(T7);

        OneOf(object value)
        {
            // assumes will only be called after being validated in some way
            this.value = value;
        }

        internal static OneOf<T0, T1, T2, T3, T4, T5, T6, T7> Create(object value)
        {
            if (value == null) throw new ArgumentNullException("value");

            var valueType = value.GetType();
            if (valueType == typeT0) return new OneOf<T0, T1, T2, T3, T4, T5, T6, T7>((T0)value);
            if (valueType == typeT1) return new OneOf<T0, T1, T2, T3, T4, T5, T6, T7>((T1)value);
            if (valueType == typeT2) return new OneOf<T0, T1, T2, T3, T4, T5, T6, T7>((T2)value);
            if (valueType == typeT3) return new OneOf<T0, T1, T2, T3, T4, T5, T6, T7>((T3)value);
            if (valueType == typeT4) return new OneOf<T0, T1, T2, T3, T4, T5, T6, T7>((T4)value);
            if (valueType == typeT5) return new OneOf<T0, T1, T2, T3, T4, T5, T6, T7>((T5)value);
            if (valueType == typeT6) return new OneOf<T0, T1, T2, T3, T4, T5, T6, T7>((T6)value);
            if (valueType == typeT7) return new OneOf<T0, T1, T2, T3, T4, T5, T6, T7>((T7)value);

            throw new ArgumentException("value");
        }

        void EnsureValueNotNull()
        {
            if (value == null) throw new InvalidOperationException("Value has not been set");
        }

        object IOneOf.Value => value;

        public bool Is<T>()
        {
            EnsureValueNotNull();
            if (this.value.GetType() == typeof(T)) return true;

            return false;
        }

        public T As<T>()
        {
            EnsureValueNotNull();
            if (this.value.GetType() == typeof(T)) return (T)this.value;

            throw new InvalidOperationException();
        }

        // Use slower Create method which does full type checks at runtime as compiler couldn't do them for us.
        public OneOf<N0> ToOneOf<N0>() => OneOf<N0>.Create(value);
        public OneOf<N0, N1> ToOneOf<N0, N1>() => OneOf<N0, N1>.Create(value);
        public OneOf<N0, N1, N2> ToOneOf<N0, N1, N2>() => OneOf<N0, N1, N2>.Create(value);
        public OneOf<N0, N1, N2, N3> ToOneOf<N0, N1, N2, N3>() => OneOf<N0, N1, N2, N3>.Create(value);
        public OneOf<N0, N1, N2, N3, N4> ToOneOf<N0, N1, N2, N3, N4>() => OneOf<N0, N1, N2, N3, N4>.Create(value);
        public OneOf<N0, N1, N2, N3, N4, N5> ToOneOf<N0, N1, N2, N3, N4, N5>() => OneOf<N0, N1, N2, N3, N4, N5>.Create(value);
        public OneOf<N0, N1, N2, N3, N4, N5, N6> ToOneOf<N0, N1, N2, N3, N4, N5, N6>() => OneOf<N0, N1, N2, N3, N4, N5, N6>.Create(value);
        public OneOf<N0, N1, N2, N3, N4, N5, N6, N7> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7>() => OneOf<N0, N1, N2, N3, N4, N5, N6, N7>.Create(value);
        public OneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8>() => OneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8>.Create(value);

        // Can use fast Ctor as compiler can check types for us.
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5, T6, T7>(T0 value) => new OneOf<T0, T1, T2, T3, T4, T5, T6, T7>(value);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5, T6, T7>(T1 value) => new OneOf<T0, T1, T2, T3, T4, T5, T6, T7>(value);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5, T6, T7>(T2 value) => new OneOf<T0, T1, T2, T3, T4, T5, T6, T7>(value);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5, T6, T7>(T3 value) => new OneOf<T0, T1, T2, T3, T4, T5, T6, T7>(value);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5, T6, T7>(T4 value) => new OneOf<T0, T1, T2, T3, T4, T5, T6, T7>(value);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5, T6, T7>(T5 value) => new OneOf<T0, T1, T2, T3, T4, T5, T6, T7>(value);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5, T6, T7>(T6 value) => new OneOf<T0, T1, T2, T3, T4, T5, T6, T7>(value);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5, T6, T7>(T7 value) => new OneOf<T0, T1, T2, T3, T4, T5, T6, T7>(value);

        public OneOfSwitcher Switch()
        {
            EnsureValueNotNull();
            return new OneOfSwitcher(value);
        }

        public OneOfMatcher<T> Match<T>()
        {
            EnsureValueNotNull();
            return new OneOfMatcher<T>(value);
        }

        public override bool Equals(object obj)
        {
            if (!(obj is OneOf<T0, T1, T2, T3, T4, T5, T6, T7>)) return false;

            var other = (OneOf<T0, T1, T2, T3, T4, T5, T6, T7>)obj;
            return Equals(value, other.value);
        }

        public override int GetHashCode() => (value?.GetHashCode() ?? 0);

        public override string ToString() => (value?.ToString() ?? "");
    }

    [JsonConverter(typeof(OneOfJsonConverter))]
    public struct OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8> : IOneOf
    {
        readonly object value;
        static readonly Type typeT0 = typeof(T0);
        static readonly Type typeT1 = typeof(T1);
        static readonly Type typeT2 = typeof(T2);
        static readonly Type typeT3 = typeof(T3);
        static readonly Type typeT4 = typeof(T4);
        static readonly Type typeT5 = typeof(T5);
        static readonly Type typeT6 = typeof(T6);
        static readonly Type typeT7 = typeof(T7);
        static readonly Type typeT8 = typeof(T8);

        OneOf(object value)
        {
            // assumes will only be called after being validated in some way
            this.value = value;
        }

        internal static OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8> Create(object value)
        {
            if (value == null) throw new ArgumentNullException("value");

            var valueType = value.GetType();
            if (valueType == typeT0) return new OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8>((T0)value);
            if (valueType == typeT1) return new OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8>((T1)value);
            if (valueType == typeT2) return new OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8>((T2)value);
            if (valueType == typeT3) return new OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8>((T3)value);
            if (valueType == typeT4) return new OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8>((T4)value);
            if (valueType == typeT5) return new OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8>((T5)value);
            if (valueType == typeT6) return new OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8>((T6)value);
            if (valueType == typeT7) return new OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8>((T7)value);
            if (valueType == typeT8) return new OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8>((T8)value);

            throw new ArgumentException("value");
        }

        void EnsureValueNotNull()
        {
            if (value == null) throw new InvalidOperationException("Value has not been set");
        }

        object IOneOf.Value => value;

        public bool Is<T>()
        {
            EnsureValueNotNull();
            if (this.value.GetType() == typeof(T)) return true;

            return false;
        }

        public T As<T>()
        {
            EnsureValueNotNull();
            if (this.value.GetType() == typeof(T)) return (T)this.value;

            throw new InvalidOperationException();
        }

        // Use slower Create method which does full type checks at runtime as compiler couldn't do them for us.
        public OneOf<N0> ToOneOf<N0>() => OneOf<N0>.Create(value);
        public OneOf<N0, N1> ToOneOf<N0, N1>() => OneOf<N0, N1>.Create(value);
        public OneOf<N0, N1, N2> ToOneOf<N0, N1, N2>() => OneOf<N0, N1, N2>.Create(value);
        public OneOf<N0, N1, N2, N3> ToOneOf<N0, N1, N2, N3>() => OneOf<N0, N1, N2, N3>.Create(value);
        public OneOf<N0, N1, N2, N3, N4> ToOneOf<N0, N1, N2, N3, N4>() => OneOf<N0, N1, N2, N3, N4>.Create(value);
        public OneOf<N0, N1, N2, N3, N4, N5> ToOneOf<N0, N1, N2, N3, N4, N5>() => OneOf<N0, N1, N2, N3, N4, N5>.Create(value);
        public OneOf<N0, N1, N2, N3, N4, N5, N6> ToOneOf<N0, N1, N2, N3, N4, N5, N6>() => OneOf<N0, N1, N2, N3, N4, N5, N6>.Create(value);
        public OneOf<N0, N1, N2, N3, N4, N5, N6, N7> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7>() => OneOf<N0, N1, N2, N3, N4, N5, N6, N7>.Create(value);
        public OneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8>() => OneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8>.Create(value);

        // Can use fast Ctor as compiler can check types for us.
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8>(T0 value) => new OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8>(value);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8>(T1 value) => new OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8>(value);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8>(T2 value) => new OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8>(value);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8>(T3 value) => new OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8>(value);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8>(T4 value) => new OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8>(value);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8>(T5 value) => new OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8>(value);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8>(T6 value) => new OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8>(value);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8>(T7 value) => new OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8>(value);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8>(T8 value) => new OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8>(value);

        public OneOfSwitcher Switch()
        {
            EnsureValueNotNull();
            return new OneOfSwitcher(value);
        }

        public OneOfMatcher<T> Match<T>()
        {
            EnsureValueNotNull();
            return new OneOfMatcher<T>(value);
        }

        public override bool Equals(object obj)
        {
            if (!(obj is OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8>)) return false;

            var other = (OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8>)obj;
            return Equals(value, other.value);
        }

        public override int GetHashCode() => (value?.GetHashCode() ?? 0);

        public override string ToString() => (value?.ToString() ?? "");
    }

    [JsonConverter(typeof(OneOfJsonConverter))]
    public class OneOfBase<T0> : IOneOf
    {
        readonly object value;
        static readonly Type typeT0 = typeof(T0);

        OneOfBase(object value)
        {
            // assumes will only be called after being validated in some way
            this.value = value;
        }

        protected OneOfBase()
        {
            // assumes will only be called after being validated in some way
            this.value = this;
        }

        internal static OneOfBase<T0> Create(object value)
        {
            if (value == null) throw new ArgumentNullException("value");

            var valueType = value.GetType();
            if (valueType == typeT0) return new OneOfBase<T0>((T0)value);

            throw new ArgumentException("value");
        }

        void EnsureValueNotNull()
        {
            if (value == null) throw new InvalidOperationException("Value has not been set");
        }

        object IOneOf.Value => value;

        public bool Is<T>()
        {
            EnsureValueNotNull();
            if (this.value.GetType() == typeof(T)) return true;

            return false;
        }

        public T As<T>()
        {
            EnsureValueNotNull();
            if (this.value.GetType() == typeof(T)) return (T)this.value;

            throw new InvalidOperationException();
        }

        // Use slower Create method which does full type checks at runtime as compiler couldn't do them for us.
        public OneOfBase<N0> ToOneOf<N0>() => OneOfBase<N0>.Create(value);
        public OneOfBase<N0, N1> ToOneOf<N0, N1>() => OneOfBase<N0, N1>.Create(value);
        public OneOfBase<N0, N1, N2> ToOneOf<N0, N1, N2>() => OneOfBase<N0, N1, N2>.Create(value);
        public OneOfBase<N0, N1, N2, N3> ToOneOf<N0, N1, N2, N3>() => OneOfBase<N0, N1, N2, N3>.Create(value);
        public OneOfBase<N0, N1, N2, N3, N4> ToOneOf<N0, N1, N2, N3, N4>() => OneOfBase<N0, N1, N2, N3, N4>.Create(value);
        public OneOfBase<N0, N1, N2, N3, N4, N5> ToOneOf<N0, N1, N2, N3, N4, N5>() => OneOfBase<N0, N1, N2, N3, N4, N5>.Create(value);
        public OneOfBase<N0, N1, N2, N3, N4, N5, N6> ToOneOf<N0, N1, N2, N3, N4, N5, N6>() => OneOfBase<N0, N1, N2, N3, N4, N5, N6>.Create(value);
        public OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7>() => OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7>.Create(value);
        public OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7, N8> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8>() => OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7, N8>.Create(value);

        // Can use fast Ctor as compiler can check types for us.
        public static implicit operator OneOfBase<T0>(T0 value) => new OneOfBase<T0>(value);

        public OneOfSwitcher Switch()
        {
            EnsureValueNotNull();
            return new OneOfSwitcher(value);
        }

        public OneOfMatcher<T> Match<T>()
        {
            EnsureValueNotNull();
            return new OneOfMatcher<T>(value);
        }

        public override bool Equals(object obj)
        {
            if (!(obj is OneOfBase<T0>)) return false;

            var other = (OneOfBase<T0>)obj;
            return Equals(value, other.value);
        }

        public override int GetHashCode() => (value?.GetHashCode() ?? 0);

        public override string ToString() => (value?.ToString() ?? "");
    }

    [JsonConverter(typeof(OneOfJsonConverter))]
    public class OneOfBase<T0, T1> : IOneOf
    {
        readonly object value;
        static readonly Type typeT0 = typeof(T0);
        static readonly Type typeT1 = typeof(T1);

        OneOfBase(object value)
        {
            // assumes will only be called after being validated in some way
            this.value = value;
        }

        protected OneOfBase()
        {
            // assumes will only be called after being validated in some way
            this.value = this;
        }

        internal static OneOfBase<T0, T1> Create(object value)
        {
            if (value == null) throw new ArgumentNullException("value");

            var valueType = value.GetType();
            if (valueType == typeT0) return new OneOfBase<T0, T1>((T0)value);
            if (valueType == typeT1) return new OneOfBase<T0, T1>((T1)value);

            throw new ArgumentException("value");
        }

        void EnsureValueNotNull()
        {
            if (value == null) throw new InvalidOperationException("Value has not been set");
        }

        object IOneOf.Value => value;

        public bool Is<T>()
        {
            EnsureValueNotNull();
            if (this.value.GetType() == typeof(T)) return true;

            return false;
        }

        public T As<T>()
        {
            EnsureValueNotNull();
            if (this.value.GetType() == typeof(T)) return (T)this.value;

            throw new InvalidOperationException();
        }

        // Use slower Create method which does full type checks at runtime as compiler couldn't do them for us.
        public OneOfBase<N0> ToOneOf<N0>() => OneOfBase<N0>.Create(value);
        public OneOfBase<N0, N1> ToOneOf<N0, N1>() => OneOfBase<N0, N1>.Create(value);
        public OneOfBase<N0, N1, N2> ToOneOf<N0, N1, N2>() => OneOfBase<N0, N1, N2>.Create(value);
        public OneOfBase<N0, N1, N2, N3> ToOneOf<N0, N1, N2, N3>() => OneOfBase<N0, N1, N2, N3>.Create(value);
        public OneOfBase<N0, N1, N2, N3, N4> ToOneOf<N0, N1, N2, N3, N4>() => OneOfBase<N0, N1, N2, N3, N4>.Create(value);
        public OneOfBase<N0, N1, N2, N3, N4, N5> ToOneOf<N0, N1, N2, N3, N4, N5>() => OneOfBase<N0, N1, N2, N3, N4, N5>.Create(value);
        public OneOfBase<N0, N1, N2, N3, N4, N5, N6> ToOneOf<N0, N1, N2, N3, N4, N5, N6>() => OneOfBase<N0, N1, N2, N3, N4, N5, N6>.Create(value);
        public OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7>() => OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7>.Create(value);
        public OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7, N8> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8>() => OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7, N8>.Create(value);

        // Can use fast Ctor as compiler can check types for us.
        public static implicit operator OneOfBase<T0, T1>(T0 value) => new OneOfBase<T0, T1>(value);
        public static implicit operator OneOfBase<T0, T1>(T1 value) => new OneOfBase<T0, T1>(value);

        public OneOfSwitcher Switch()
        {
            EnsureValueNotNull();
            return new OneOfSwitcher(value);
        }

        public OneOfMatcher<T> Match<T>()
        {
            EnsureValueNotNull();
            return new OneOfMatcher<T>(value);
        }

        public override bool Equals(object obj)
        {
            if (!(obj is OneOfBase<T0, T1>)) return false;

            var other = (OneOfBase<T0, T1>)obj;
            return Equals(value, other.value);
        }

        public override int GetHashCode() => (value?.GetHashCode() ?? 0);

        public override string ToString() => (value?.ToString() ?? "");
    }

    [JsonConverter(typeof(OneOfJsonConverter))]
    public class OneOfBase<T0, T1, T2> : IOneOf
    {
        readonly object value;
        static readonly Type typeT0 = typeof(T0);
        static readonly Type typeT1 = typeof(T1);
        static readonly Type typeT2 = typeof(T2);

        OneOfBase(object value)
        {
            // assumes will only be called after being validated in some way
            this.value = value;
        }

        protected OneOfBase()
        {
            // assumes will only be called after being validated in some way
            this.value = this;
        }

        internal static OneOfBase<T0, T1, T2> Create(object value)
        {
            if (value == null) throw new ArgumentNullException("value");

            var valueType = value.GetType();
            if (valueType == typeT0) return new OneOfBase<T0, T1, T2>((T0)value);
            if (valueType == typeT1) return new OneOfBase<T0, T1, T2>((T1)value);
            if (valueType == typeT2) return new OneOfBase<T0, T1, T2>((T2)value);

            throw new ArgumentException("value");
        }

        void EnsureValueNotNull()
        {
            if (value == null) throw new InvalidOperationException("Value has not been set");
        }

        object IOneOf.Value => value;

        public bool Is<T>()
        {
            EnsureValueNotNull();
            if (this.value.GetType() == typeof(T)) return true;

            return false;
        }

        public T As<T>()
        {
            EnsureValueNotNull();
            if (this.value.GetType() == typeof(T)) return (T)this.value;

            throw new InvalidOperationException();
        }

        // Use slower Create method which does full type checks at runtime as compiler couldn't do them for us.
        public OneOfBase<N0> ToOneOf<N0>() => OneOfBase<N0>.Create(value);
        public OneOfBase<N0, N1> ToOneOf<N0, N1>() => OneOfBase<N0, N1>.Create(value);
        public OneOfBase<N0, N1, N2> ToOneOf<N0, N1, N2>() => OneOfBase<N0, N1, N2>.Create(value);
        public OneOfBase<N0, N1, N2, N3> ToOneOf<N0, N1, N2, N3>() => OneOfBase<N0, N1, N2, N3>.Create(value);
        public OneOfBase<N0, N1, N2, N3, N4> ToOneOf<N0, N1, N2, N3, N4>() => OneOfBase<N0, N1, N2, N3, N4>.Create(value);
        public OneOfBase<N0, N1, N2, N3, N4, N5> ToOneOf<N0, N1, N2, N3, N4, N5>() => OneOfBase<N0, N1, N2, N3, N4, N5>.Create(value);
        public OneOfBase<N0, N1, N2, N3, N4, N5, N6> ToOneOf<N0, N1, N2, N3, N4, N5, N6>() => OneOfBase<N0, N1, N2, N3, N4, N5, N6>.Create(value);
        public OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7>() => OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7>.Create(value);
        public OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7, N8> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8>() => OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7, N8>.Create(value);

        // Can use fast Ctor as compiler can check types for us.
        public static implicit operator OneOfBase<T0, T1, T2>(T0 value) => new OneOfBase<T0, T1, T2>(value);
        public static implicit operator OneOfBase<T0, T1, T2>(T1 value) => new OneOfBase<T0, T1, T2>(value);
        public static implicit operator OneOfBase<T0, T1, T2>(T2 value) => new OneOfBase<T0, T1, T2>(value);

        public OneOfSwitcher Switch()
        {
            EnsureValueNotNull();
            return new OneOfSwitcher(value);
        }

        public OneOfMatcher<T> Match<T>()
        {
            EnsureValueNotNull();
            return new OneOfMatcher<T>(value);
        }

        public override bool Equals(object obj)
        {
            if (!(obj is OneOfBase<T0, T1, T2>)) return false;

            var other = (OneOfBase<T0, T1, T2>)obj;
            return Equals(value, other.value);
        }

        public override int GetHashCode() => (value?.GetHashCode() ?? 0);

        public override string ToString() => (value?.ToString() ?? "");
    }

    [JsonConverter(typeof(OneOfJsonConverter))]
    public class OneOfBase<T0, T1, T2, T3> : IOneOf
    {
        readonly object value;
        static readonly Type typeT0 = typeof(T0);
        static readonly Type typeT1 = typeof(T1);
        static readonly Type typeT2 = typeof(T2);
        static readonly Type typeT3 = typeof(T3);

        OneOfBase(object value)
        {
            // assumes will only be called after being validated in some way
            this.value = value;
        }

        protected OneOfBase()
        {
            // assumes will only be called after being validated in some way
            this.value = this;
        }

        internal static OneOfBase<T0, T1, T2, T3> Create(object value)
        {
            if (value == null) throw new ArgumentNullException("value");

            var valueType = value.GetType();
            if (valueType == typeT0) return new OneOfBase<T0, T1, T2, T3>((T0)value);
            if (valueType == typeT1) return new OneOfBase<T0, T1, T2, T3>((T1)value);
            if (valueType == typeT2) return new OneOfBase<T0, T1, T2, T3>((T2)value);
            if (valueType == typeT3) return new OneOfBase<T0, T1, T2, T3>((T3)value);

            throw new ArgumentException("value");
        }

        void EnsureValueNotNull()
        {
            if (value == null) throw new InvalidOperationException("Value has not been set");
        }

        object IOneOf.Value => value;

        public bool Is<T>()
        {
            EnsureValueNotNull();
            if (this.value.GetType() == typeof(T)) return true;

            return false;
        }

        public T As<T>()
        {
            EnsureValueNotNull();
            if (this.value.GetType() == typeof(T)) return (T)this.value;

            throw new InvalidOperationException();
        }

        // Use slower Create method which does full type checks at runtime as compiler couldn't do them for us.
        public OneOfBase<N0> ToOneOf<N0>() => OneOfBase<N0>.Create(value);
        public OneOfBase<N0, N1> ToOneOf<N0, N1>() => OneOfBase<N0, N1>.Create(value);
        public OneOfBase<N0, N1, N2> ToOneOf<N0, N1, N2>() => OneOfBase<N0, N1, N2>.Create(value);
        public OneOfBase<N0, N1, N2, N3> ToOneOf<N0, N1, N2, N3>() => OneOfBase<N0, N1, N2, N3>.Create(value);
        public OneOfBase<N0, N1, N2, N3, N4> ToOneOf<N0, N1, N2, N3, N4>() => OneOfBase<N0, N1, N2, N3, N4>.Create(value);
        public OneOfBase<N0, N1, N2, N3, N4, N5> ToOneOf<N0, N1, N2, N3, N4, N5>() => OneOfBase<N0, N1, N2, N3, N4, N5>.Create(value);
        public OneOfBase<N0, N1, N2, N3, N4, N5, N6> ToOneOf<N0, N1, N2, N3, N4, N5, N6>() => OneOfBase<N0, N1, N2, N3, N4, N5, N6>.Create(value);
        public OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7>() => OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7>.Create(value);
        public OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7, N8> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8>() => OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7, N8>.Create(value);

        // Can use fast Ctor as compiler can check types for us.
        public static implicit operator OneOfBase<T0, T1, T2, T3>(T0 value) => new OneOfBase<T0, T1, T2, T3>(value);
        public static implicit operator OneOfBase<T0, T1, T2, T3>(T1 value) => new OneOfBase<T0, T1, T2, T3>(value);
        public static implicit operator OneOfBase<T0, T1, T2, T3>(T2 value) => new OneOfBase<T0, T1, T2, T3>(value);
        public static implicit operator OneOfBase<T0, T1, T2, T3>(T3 value) => new OneOfBase<T0, T1, T2, T3>(value);

        public OneOfSwitcher Switch()
        {
            EnsureValueNotNull();
            return new OneOfSwitcher(value);
        }

        public OneOfMatcher<T> Match<T>()
        {
            EnsureValueNotNull();
            return new OneOfMatcher<T>(value);
        }

        public override bool Equals(object obj)
        {
            if (!(obj is OneOfBase<T0, T1, T2, T3>)) return false;

            var other = (OneOfBase<T0, T1, T2, T3>)obj;
            return Equals(value, other.value);
        }

        public override int GetHashCode() => (value?.GetHashCode() ?? 0);

        public override string ToString() => (value?.ToString() ?? "");
    }

    [JsonConverter(typeof(OneOfJsonConverter))]
    public class OneOfBase<T0, T1, T2, T3, T4> : IOneOf
    {
        readonly object value;
        static readonly Type typeT0 = typeof(T0);
        static readonly Type typeT1 = typeof(T1);
        static readonly Type typeT2 = typeof(T2);
        static readonly Type typeT3 = typeof(T3);
        static readonly Type typeT4 = typeof(T4);

        OneOfBase(object value)
        {
            // assumes will only be called after being validated in some way
            this.value = value;
        }

        protected OneOfBase()
        {
            // assumes will only be called after being validated in some way
            this.value = this;
        }

        internal static OneOfBase<T0, T1, T2, T3, T4> Create(object value)
        {
            if (value == null) throw new ArgumentNullException("value");

            var valueType = value.GetType();
            if (valueType == typeT0) return new OneOfBase<T0, T1, T2, T3, T4>((T0)value);
            if (valueType == typeT1) return new OneOfBase<T0, T1, T2, T3, T4>((T1)value);
            if (valueType == typeT2) return new OneOfBase<T0, T1, T2, T3, T4>((T2)value);
            if (valueType == typeT3) return new OneOfBase<T0, T1, T2, T3, T4>((T3)value);
            if (valueType == typeT4) return new OneOfBase<T0, T1, T2, T3, T4>((T4)value);

            throw new ArgumentException("value");
        }

        void EnsureValueNotNull()
        {
            if (value == null) throw new InvalidOperationException("Value has not been set");
        }

        object IOneOf.Value => value;

        public bool Is<T>()
        {
            EnsureValueNotNull();
            if (this.value.GetType() == typeof(T)) return true;

            return false;
        }

        public T As<T>()
        {
            EnsureValueNotNull();
            if (this.value.GetType() == typeof(T)) return (T)this.value;

            throw new InvalidOperationException();
        }

        // Use slower Create method which does full type checks at runtime as compiler couldn't do them for us.
        public OneOfBase<N0> ToOneOf<N0>() => OneOfBase<N0>.Create(value);
        public OneOfBase<N0, N1> ToOneOf<N0, N1>() => OneOfBase<N0, N1>.Create(value);
        public OneOfBase<N0, N1, N2> ToOneOf<N0, N1, N2>() => OneOfBase<N0, N1, N2>.Create(value);
        public OneOfBase<N0, N1, N2, N3> ToOneOf<N0, N1, N2, N3>() => OneOfBase<N0, N1, N2, N3>.Create(value);
        public OneOfBase<N0, N1, N2, N3, N4> ToOneOf<N0, N1, N2, N3, N4>() => OneOfBase<N0, N1, N2, N3, N4>.Create(value);
        public OneOfBase<N0, N1, N2, N3, N4, N5> ToOneOf<N0, N1, N2, N3, N4, N5>() => OneOfBase<N0, N1, N2, N3, N4, N5>.Create(value);
        public OneOfBase<N0, N1, N2, N3, N4, N5, N6> ToOneOf<N0, N1, N2, N3, N4, N5, N6>() => OneOfBase<N0, N1, N2, N3, N4, N5, N6>.Create(value);
        public OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7>() => OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7>.Create(value);
        public OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7, N8> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8>() => OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7, N8>.Create(value);

        // Can use fast Ctor as compiler can check types for us.
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4>(T0 value) => new OneOfBase<T0, T1, T2, T3, T4>(value);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4>(T1 value) => new OneOfBase<T0, T1, T2, T3, T4>(value);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4>(T2 value) => new OneOfBase<T0, T1, T2, T3, T4>(value);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4>(T3 value) => new OneOfBase<T0, T1, T2, T3, T4>(value);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4>(T4 value) => new OneOfBase<T0, T1, T2, T3, T4>(value);

        public OneOfSwitcher Switch()
        {
            EnsureValueNotNull();
            return new OneOfSwitcher(value);
        }

        public OneOfMatcher<T> Match<T>()
        {
            EnsureValueNotNull();
            return new OneOfMatcher<T>(value);
        }

        public override bool Equals(object obj)
        {
            if (!(obj is OneOfBase<T0, T1, T2, T3, T4>)) return false;

            var other = (OneOfBase<T0, T1, T2, T3, T4>)obj;
            return Equals(value, other.value);
        }

        public override int GetHashCode() => (value?.GetHashCode() ?? 0);

        public override string ToString() => (value?.ToString() ?? "");
    }

    [JsonConverter(typeof(OneOfJsonConverter))]
    public class OneOfBase<T0, T1, T2, T3, T4, T5> : IOneOf
    {
        readonly object value;
        static readonly Type typeT0 = typeof(T0);
        static readonly Type typeT1 = typeof(T1);
        static readonly Type typeT2 = typeof(T2);
        static readonly Type typeT3 = typeof(T3);
        static readonly Type typeT4 = typeof(T4);
        static readonly Type typeT5 = typeof(T5);

        OneOfBase(object value)
        {
            // assumes will only be called after being validated in some way
            this.value = value;
        }

        protected OneOfBase()
        {
            // assumes will only be called after being validated in some way
            this.value = this;
        }

        internal static OneOfBase<T0, T1, T2, T3, T4, T5> Create(object value)
        {
            if (value == null) throw new ArgumentNullException("value");

            var valueType = value.GetType();
            if (valueType == typeT0) return new OneOfBase<T0, T1, T2, T3, T4, T5>((T0)value);
            if (valueType == typeT1) return new OneOfBase<T0, T1, T2, T3, T4, T5>((T1)value);
            if (valueType == typeT2) return new OneOfBase<T0, T1, T2, T3, T4, T5>((T2)value);
            if (valueType == typeT3) return new OneOfBase<T0, T1, T2, T3, T4, T5>((T3)value);
            if (valueType == typeT4) return new OneOfBase<T0, T1, T2, T3, T4, T5>((T4)value);
            if (valueType == typeT5) return new OneOfBase<T0, T1, T2, T3, T4, T5>((T5)value);

            throw new ArgumentException("value");
        }

        void EnsureValueNotNull()
        {
            if (value == null) throw new InvalidOperationException("Value has not been set");
        }

        object IOneOf.Value => value;

        public bool Is<T>()
        {
            EnsureValueNotNull();
            if (this.value.GetType() == typeof(T)) return true;

            return false;
        }

        public T As<T>()
        {
            EnsureValueNotNull();
            if (this.value.GetType() == typeof(T)) return (T)this.value;

            throw new InvalidOperationException();
        }

        // Use slower Create method which does full type checks at runtime as compiler couldn't do them for us.
        public OneOfBase<N0> ToOneOf<N0>() => OneOfBase<N0>.Create(value);
        public OneOfBase<N0, N1> ToOneOf<N0, N1>() => OneOfBase<N0, N1>.Create(value);
        public OneOfBase<N0, N1, N2> ToOneOf<N0, N1, N2>() => OneOfBase<N0, N1, N2>.Create(value);
        public OneOfBase<N0, N1, N2, N3> ToOneOf<N0, N1, N2, N3>() => OneOfBase<N0, N1, N2, N3>.Create(value);
        public OneOfBase<N0, N1, N2, N3, N4> ToOneOf<N0, N1, N2, N3, N4>() => OneOfBase<N0, N1, N2, N3, N4>.Create(value);
        public OneOfBase<N0, N1, N2, N3, N4, N5> ToOneOf<N0, N1, N2, N3, N4, N5>() => OneOfBase<N0, N1, N2, N3, N4, N5>.Create(value);
        public OneOfBase<N0, N1, N2, N3, N4, N5, N6> ToOneOf<N0, N1, N2, N3, N4, N5, N6>() => OneOfBase<N0, N1, N2, N3, N4, N5, N6>.Create(value);
        public OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7>() => OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7>.Create(value);
        public OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7, N8> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8>() => OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7, N8>.Create(value);

        // Can use fast Ctor as compiler can check types for us.
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5>(T0 value) => new OneOfBase<T0, T1, T2, T3, T4, T5>(value);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5>(T1 value) => new OneOfBase<T0, T1, T2, T3, T4, T5>(value);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5>(T2 value) => new OneOfBase<T0, T1, T2, T3, T4, T5>(value);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5>(T3 value) => new OneOfBase<T0, T1, T2, T3, T4, T5>(value);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5>(T4 value) => new OneOfBase<T0, T1, T2, T3, T4, T5>(value);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5>(T5 value) => new OneOfBase<T0, T1, T2, T3, T4, T5>(value);

        public OneOfSwitcher Switch()
        {
            EnsureValueNotNull();
            return new OneOfSwitcher(value);
        }

        public OneOfMatcher<T> Match<T>()
        {
            EnsureValueNotNull();
            return new OneOfMatcher<T>(value);
        }

        public override bool Equals(object obj)
        {
            if (!(obj is OneOfBase<T0, T1, T2, T3, T4, T5>)) return false;

            var other = (OneOfBase<T0, T1, T2, T3, T4, T5>)obj;
            return Equals(value, other.value);
        }

        public override int GetHashCode() => (value?.GetHashCode() ?? 0);

        public override string ToString() => (value?.ToString() ?? "");
    }

    [JsonConverter(typeof(OneOfJsonConverter))]
    public class OneOfBase<T0, T1, T2, T3, T4, T5, T6> : IOneOf
    {
        readonly object value;
        static readonly Type typeT0 = typeof(T0);
        static readonly Type typeT1 = typeof(T1);
        static readonly Type typeT2 = typeof(T2);
        static readonly Type typeT3 = typeof(T3);
        static readonly Type typeT4 = typeof(T4);
        static readonly Type typeT5 = typeof(T5);
        static readonly Type typeT6 = typeof(T6);

        OneOfBase(object value)
        {
            // assumes will only be called after being validated in some way
            this.value = value;
        }

        protected OneOfBase()
        {
            // assumes will only be called after being validated in some way
            this.value = this;
        }

        internal static OneOfBase<T0, T1, T2, T3, T4, T5, T6> Create(object value)
        {
            if (value == null) throw new ArgumentNullException("value");

            var valueType = value.GetType();
            if (valueType == typeT0) return new OneOfBase<T0, T1, T2, T3, T4, T5, T6>((T0)value);
            if (valueType == typeT1) return new OneOfBase<T0, T1, T2, T3, T4, T5, T6>((T1)value);
            if (valueType == typeT2) return new OneOfBase<T0, T1, T2, T3, T4, T5, T6>((T2)value);
            if (valueType == typeT3) return new OneOfBase<T0, T1, T2, T3, T4, T5, T6>((T3)value);
            if (valueType == typeT4) return new OneOfBase<T0, T1, T2, T3, T4, T5, T6>((T4)value);
            if (valueType == typeT5) return new OneOfBase<T0, T1, T2, T3, T4, T5, T6>((T5)value);
            if (valueType == typeT6) return new OneOfBase<T0, T1, T2, T3, T4, T5, T6>((T6)value);

            throw new ArgumentException("value");
        }

        void EnsureValueNotNull()
        {
            if (value == null) throw new InvalidOperationException("Value has not been set");
        }

        object IOneOf.Value => value;

        public bool Is<T>()
        {
            EnsureValueNotNull();
            if (this.value.GetType() == typeof(T)) return true;

            return false;
        }

        public T As<T>()
        {
            EnsureValueNotNull();
            if (this.value.GetType() == typeof(T)) return (T)this.value;

            throw new InvalidOperationException();
        }

        // Use slower Create method which does full type checks at runtime as compiler couldn't do them for us.
        public OneOfBase<N0> ToOneOf<N0>() => OneOfBase<N0>.Create(value);
        public OneOfBase<N0, N1> ToOneOf<N0, N1>() => OneOfBase<N0, N1>.Create(value);
        public OneOfBase<N0, N1, N2> ToOneOf<N0, N1, N2>() => OneOfBase<N0, N1, N2>.Create(value);
        public OneOfBase<N0, N1, N2, N3> ToOneOf<N0, N1, N2, N3>() => OneOfBase<N0, N1, N2, N3>.Create(value);
        public OneOfBase<N0, N1, N2, N3, N4> ToOneOf<N0, N1, N2, N3, N4>() => OneOfBase<N0, N1, N2, N3, N4>.Create(value);
        public OneOfBase<N0, N1, N2, N3, N4, N5> ToOneOf<N0, N1, N2, N3, N4, N5>() => OneOfBase<N0, N1, N2, N3, N4, N5>.Create(value);
        public OneOfBase<N0, N1, N2, N3, N4, N5, N6> ToOneOf<N0, N1, N2, N3, N4, N5, N6>() => OneOfBase<N0, N1, N2, N3, N4, N5, N6>.Create(value);
        public OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7>() => OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7>.Create(value);
        public OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7, N8> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8>() => OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7, N8>.Create(value);

        // Can use fast Ctor as compiler can check types for us.
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5, T6>(T0 value) => new OneOfBase<T0, T1, T2, T3, T4, T5, T6>(value);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5, T6>(T1 value) => new OneOfBase<T0, T1, T2, T3, T4, T5, T6>(value);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5, T6>(T2 value) => new OneOfBase<T0, T1, T2, T3, T4, T5, T6>(value);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5, T6>(T3 value) => new OneOfBase<T0, T1, T2, T3, T4, T5, T6>(value);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5, T6>(T4 value) => new OneOfBase<T0, T1, T2, T3, T4, T5, T6>(value);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5, T6>(T5 value) => new OneOfBase<T0, T1, T2, T3, T4, T5, T6>(value);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5, T6>(T6 value) => new OneOfBase<T0, T1, T2, T3, T4, T5, T6>(value);

        public OneOfSwitcher Switch()
        {
            EnsureValueNotNull();
            return new OneOfSwitcher(value);
        }

        public OneOfMatcher<T> Match<T>()
        {
            EnsureValueNotNull();
            return new OneOfMatcher<T>(value);
        }

        public override bool Equals(object obj)
        {
            if (!(obj is OneOfBase<T0, T1, T2, T3, T4, T5, T6>)) return false;

            var other = (OneOfBase<T0, T1, T2, T3, T4, T5, T6>)obj;
            return Equals(value, other.value);
        }

        public override int GetHashCode() => (value?.GetHashCode() ?? 0);

        public override string ToString() => (value?.ToString() ?? "");
    }

    [JsonConverter(typeof(OneOfJsonConverter))]
    public class OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> : IOneOf
    {
        readonly object value;
        static readonly Type typeT0 = typeof(T0);
        static readonly Type typeT1 = typeof(T1);
        static readonly Type typeT2 = typeof(T2);
        static readonly Type typeT3 = typeof(T3);
        static readonly Type typeT4 = typeof(T4);
        static readonly Type typeT5 = typeof(T5);
        static readonly Type typeT6 = typeof(T6);
        static readonly Type typeT7 = typeof(T7);

        OneOfBase(object value)
        {
            // assumes will only be called after being validated in some way
            this.value = value;
        }

        protected OneOfBase()
        {
            // assumes will only be called after being validated in some way
            this.value = this;
        }

        internal static OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> Create(object value)
        {
            if (value == null) throw new ArgumentNullException("value");

            var valueType = value.GetType();
            if (valueType == typeT0) return new OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7>((T0)value);
            if (valueType == typeT1) return new OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7>((T1)value);
            if (valueType == typeT2) return new OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7>((T2)value);
            if (valueType == typeT3) return new OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7>((T3)value);
            if (valueType == typeT4) return new OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7>((T4)value);
            if (valueType == typeT5) return new OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7>((T5)value);
            if (valueType == typeT6) return new OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7>((T6)value);
            if (valueType == typeT7) return new OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7>((T7)value);

            throw new ArgumentException("value");
        }

        void EnsureValueNotNull()
        {
            if (value == null) throw new InvalidOperationException("Value has not been set");
        }

        object IOneOf.Value => value;

        public bool Is<T>()
        {
            EnsureValueNotNull();
            if (this.value.GetType() == typeof(T)) return true;

            return false;
        }

        public T As<T>()
        {
            EnsureValueNotNull();
            if (this.value.GetType() == typeof(T)) return (T)this.value;

            throw new InvalidOperationException();
        }

        // Use slower Create method which does full type checks at runtime as compiler couldn't do them for us.
        public OneOfBase<N0> ToOneOf<N0>() => OneOfBase<N0>.Create(value);
        public OneOfBase<N0, N1> ToOneOf<N0, N1>() => OneOfBase<N0, N1>.Create(value);
        public OneOfBase<N0, N1, N2> ToOneOf<N0, N1, N2>() => OneOfBase<N0, N1, N2>.Create(value);
        public OneOfBase<N0, N1, N2, N3> ToOneOf<N0, N1, N2, N3>() => OneOfBase<N0, N1, N2, N3>.Create(value);
        public OneOfBase<N0, N1, N2, N3, N4> ToOneOf<N0, N1, N2, N3, N4>() => OneOfBase<N0, N1, N2, N3, N4>.Create(value);
        public OneOfBase<N0, N1, N2, N3, N4, N5> ToOneOf<N0, N1, N2, N3, N4, N5>() => OneOfBase<N0, N1, N2, N3, N4, N5>.Create(value);
        public OneOfBase<N0, N1, N2, N3, N4, N5, N6> ToOneOf<N0, N1, N2, N3, N4, N5, N6>() => OneOfBase<N0, N1, N2, N3, N4, N5, N6>.Create(value);
        public OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7>() => OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7>.Create(value);
        public OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7, N8> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8>() => OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7, N8>.Create(value);

        // Can use fast Ctor as compiler can check types for us.
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7>(T0 value) => new OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7>(value);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7>(T1 value) => new OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7>(value);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7>(T2 value) => new OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7>(value);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7>(T3 value) => new OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7>(value);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7>(T4 value) => new OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7>(value);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7>(T5 value) => new OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7>(value);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7>(T6 value) => new OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7>(value);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7>(T7 value) => new OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7>(value);

        public OneOfSwitcher Switch()
        {
            EnsureValueNotNull();
            return new OneOfSwitcher(value);
        }

        public OneOfMatcher<T> Match<T>()
        {
            EnsureValueNotNull();
            return new OneOfMatcher<T>(value);
        }

        public override bool Equals(object obj)
        {
            if (!(obj is OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7>)) return false;

            var other = (OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7>)obj;
            return Equals(value, other.value);
        }

        public override int GetHashCode() => (value?.GetHashCode() ?? 0);

        public override string ToString() => (value?.ToString() ?? "");
    }

    [JsonConverter(typeof(OneOfJsonConverter))]
    public class OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> : IOneOf
    {
        readonly object value;
        static readonly Type typeT0 = typeof(T0);
        static readonly Type typeT1 = typeof(T1);
        static readonly Type typeT2 = typeof(T2);
        static readonly Type typeT3 = typeof(T3);
        static readonly Type typeT4 = typeof(T4);
        static readonly Type typeT5 = typeof(T5);
        static readonly Type typeT6 = typeof(T6);
        static readonly Type typeT7 = typeof(T7);
        static readonly Type typeT8 = typeof(T8);

        OneOfBase(object value)
        {
            // assumes will only be called after being validated in some way
            this.value = value;
        }

        protected OneOfBase()
        {
            // assumes will only be called after being validated in some way
            this.value = this;
        }

        internal static OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> Create(object value)
        {
            if (value == null) throw new ArgumentNullException("value");

            var valueType = value.GetType();
            if (valueType == typeT0) return new OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8>((T0)value);
            if (valueType == typeT1) return new OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8>((T1)value);
            if (valueType == typeT2) return new OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8>((T2)value);
            if (valueType == typeT3) return new OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8>((T3)value);
            if (valueType == typeT4) return new OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8>((T4)value);
            if (valueType == typeT5) return new OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8>((T5)value);
            if (valueType == typeT6) return new OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8>((T6)value);
            if (valueType == typeT7) return new OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8>((T7)value);
            if (valueType == typeT8) return new OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8>((T8)value);

            throw new ArgumentException("value");
        }

        void EnsureValueNotNull()
        {
            if (value == null) throw new InvalidOperationException("Value has not been set");
        }

        object IOneOf.Value => value;

        public bool Is<T>()
        {
            EnsureValueNotNull();
            if (this.value.GetType() == typeof(T)) return true;

            return false;
        }

        public T As<T>()
        {
            EnsureValueNotNull();
            if (this.value.GetType() == typeof(T)) return (T)this.value;

            throw new InvalidOperationException();
        }

        // Use slower Create method which does full type checks at runtime as compiler couldn't do them for us.
        public OneOfBase<N0> ToOneOf<N0>() => OneOfBase<N0>.Create(value);
        public OneOfBase<N0, N1> ToOneOf<N0, N1>() => OneOfBase<N0, N1>.Create(value);
        public OneOfBase<N0, N1, N2> ToOneOf<N0, N1, N2>() => OneOfBase<N0, N1, N2>.Create(value);
        public OneOfBase<N0, N1, N2, N3> ToOneOf<N0, N1, N2, N3>() => OneOfBase<N0, N1, N2, N3>.Create(value);
        public OneOfBase<N0, N1, N2, N3, N4> ToOneOf<N0, N1, N2, N3, N4>() => OneOfBase<N0, N1, N2, N3, N4>.Create(value);
        public OneOfBase<N0, N1, N2, N3, N4, N5> ToOneOf<N0, N1, N2, N3, N4, N5>() => OneOfBase<N0, N1, N2, N3, N4, N5>.Create(value);
        public OneOfBase<N0, N1, N2, N3, N4, N5, N6> ToOneOf<N0, N1, N2, N3, N4, N5, N6>() => OneOfBase<N0, N1, N2, N3, N4, N5, N6>.Create(value);
        public OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7>() => OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7>.Create(value);
        public OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7, N8> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8>() => OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7, N8>.Create(value);

        // Can use fast Ctor as compiler can check types for us.
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8>(T0 value) => new OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8>(value);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8>(T1 value) => new OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8>(value);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8>(T2 value) => new OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8>(value);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8>(T3 value) => new OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8>(value);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8>(T4 value) => new OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8>(value);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8>(T5 value) => new OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8>(value);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8>(T6 value) => new OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8>(value);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8>(T7 value) => new OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8>(value);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8>(T8 value) => new OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8>(value);

        public OneOfSwitcher Switch()
        {
            EnsureValueNotNull();
            return new OneOfSwitcher(value);
        }

        public OneOfMatcher<T> Match<T>()
        {
            EnsureValueNotNull();
            return new OneOfMatcher<T>(value);
        }

        public override bool Equals(object obj)
        {
            if (!(obj is OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8>)) return false;

            var other = (OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8>)obj;
            return Equals(value, other.value);
        }

        public override int GetHashCode() => (value?.GetHashCode() ?? 0);

        public override string ToString() => (value?.ToString() ?? "");
    }

}
