// ===========================================================================
// Generated by OneOf.tt
// ===========================================================================

using System;
using Newtonsoft.Json;

namespace OneOf
{
    [JsonConverter(typeof(OneOfJsonConverter))]
    public struct OneOf<T0> : IOneOf
    {
        readonly object value;

        internal OneOf(object value)
        {
            EnsureValueIsValid(value);
            this.value = value;
        }

        static void EnsureValueIsValid(object value)
        {
            if (value == null) throw new ArgumentNullException("value");

            var valueType = value.GetType();
            if (valueType == typeof(T0)) return;

            throw new ArgumentException("value");
        }

        void EnsureValueNotNull()
        {
            if (value == null) throw new InvalidOperationException("Value has not been set");
        }

        object IOneOf.Value => value;

        public bool Is<T>()
        {
            EnsureValueNotNull();
            if (this.value.GetType() == typeof(T)) return true;

            return false;
        }

        public T As<T>()
        {
            EnsureValueNotNull();
            if (this.value.GetType() == typeof(T)) return (T)this.value;

            throw new InvalidOperationException();
        }

        public OneOf<N0> ToOneOf<N0>() => new OneOf<N0>(value);
        public OneOf<N0, N1> ToOneOf<N0, N1>() => new OneOf<N0, N1>(value);
        public OneOf<N0, N1, N2> ToOneOf<N0, N1, N2>() => new OneOf<N0, N1, N2>(value);
        public OneOf<N0, N1, N2, N3> ToOneOf<N0, N1, N2, N3>() => new OneOf<N0, N1, N2, N3>(value);
        public OneOf<N0, N1, N2, N3, N4> ToOneOf<N0, N1, N2, N3, N4>() => new OneOf<N0, N1, N2, N3, N4>(value);
        public OneOf<N0, N1, N2, N3, N4, N5> ToOneOf<N0, N1, N2, N3, N4, N5>() => new OneOf<N0, N1, N2, N3, N4, N5>(value);
        public OneOf<N0, N1, N2, N3, N4, N5, N6> ToOneOf<N0, N1, N2, N3, N4, N5, N6>() => new OneOf<N0, N1, N2, N3, N4, N5, N6>(value);
        public OneOf<N0, N1, N2, N3, N4, N5, N6, N7> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7>() => new OneOf<N0, N1, N2, N3, N4, N5, N6, N7>(value);
        public OneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8>() => new OneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8>(value);

        public static implicit operator OneOf<T0>(T0 value) => new OneOf<T0>(value);

        public void Switch(Action<T0> f0 = null, Action otherwise = null)
        {
            EnsureValueNotNull();
            var valueType = value.GetType();
            if (f0 != null && valueType == typeof(T0)) { f0((T0)this.value); return; }

            if (otherwise != null) { otherwise(); return; }

            throw new InvalidOperationException();
        }

        public TResult Match<TResult>(Func<T0, TResult> f0 = null, Func<TResult> otherwise = null)
        {
            EnsureValueNotNull();
            var valueType = value.GetType();
            if (f0 != null && valueType == typeof(T0)) return f0((T0)this.value);

            if (otherwise != null) return otherwise();

            throw new InvalidOperationException();
        }

        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            if (!(obj is OneOf<T0>)) return false;

            var other = (OneOf<T0>)obj;
            return Equals(value, other.value);
        }

        public override int GetHashCode() => (value?.GetHashCode() ?? 0);

        public override string ToString() => (value?.ToString() ?? "");
    }

    [JsonConverter(typeof(OneOfJsonConverter))]
    public struct OneOf<T0, T1> : IOneOf
    {
        readonly object value;

        internal OneOf(object value)
        {
            EnsureValueIsValid(value);
            this.value = value;
        }

        static void EnsureValueIsValid(object value)
        {
            if (value == null) throw new ArgumentNullException("value");

            var valueType = value.GetType();
            if (valueType == typeof(T0)) return;
            if (valueType == typeof(T1)) return;

            throw new ArgumentException("value");
        }

        void EnsureValueNotNull()
        {
            if (value == null) throw new InvalidOperationException("Value has not been set");
        }

        object IOneOf.Value => value;

        public bool Is<T>()
        {
            EnsureValueNotNull();
            if (this.value.GetType() == typeof(T)) return true;

            return false;
        }

        public T As<T>()
        {
            EnsureValueNotNull();
            if (this.value.GetType() == typeof(T)) return (T)this.value;

            throw new InvalidOperationException();
        }

        public OneOf<N0> ToOneOf<N0>() => new OneOf<N0>(value);
        public OneOf<N0, N1> ToOneOf<N0, N1>() => new OneOf<N0, N1>(value);
        public OneOf<N0, N1, N2> ToOneOf<N0, N1, N2>() => new OneOf<N0, N1, N2>(value);
        public OneOf<N0, N1, N2, N3> ToOneOf<N0, N1, N2, N3>() => new OneOf<N0, N1, N2, N3>(value);
        public OneOf<N0, N1, N2, N3, N4> ToOneOf<N0, N1, N2, N3, N4>() => new OneOf<N0, N1, N2, N3, N4>(value);
        public OneOf<N0, N1, N2, N3, N4, N5> ToOneOf<N0, N1, N2, N3, N4, N5>() => new OneOf<N0, N1, N2, N3, N4, N5>(value);
        public OneOf<N0, N1, N2, N3, N4, N5, N6> ToOneOf<N0, N1, N2, N3, N4, N5, N6>() => new OneOf<N0, N1, N2, N3, N4, N5, N6>(value);
        public OneOf<N0, N1, N2, N3, N4, N5, N6, N7> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7>() => new OneOf<N0, N1, N2, N3, N4, N5, N6, N7>(value);
        public OneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8>() => new OneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8>(value);

        public static implicit operator OneOf<T0, T1>(T0 value) => new OneOf<T0, T1>(value);
        public static implicit operator OneOf<T0, T1>(T1 value) => new OneOf<T0, T1>(value);

        public void Switch(Action<T0> f0 = null, Action<T1> f1 = null, Action otherwise = null)
        {
            EnsureValueNotNull();
            var valueType = value.GetType();
            if (f0 != null && valueType == typeof(T0)) { f0((T0)this.value); return; }
            if (f1 != null && valueType == typeof(T1)) { f1((T1)this.value); return; }

            if (otherwise != null) { otherwise(); return; }

            throw new InvalidOperationException();
        }

        public TResult Match<TResult>(Func<T0, TResult> f0 = null, Func<T1, TResult> f1 = null, Func<TResult> otherwise = null)
        {
            EnsureValueNotNull();
            var valueType = value.GetType();
            if (f0 != null && valueType == typeof(T0)) return f0((T0)this.value);
            if (f1 != null && valueType == typeof(T1)) return f1((T1)this.value);

            if (otherwise != null) return otherwise();

            throw new InvalidOperationException();
        }

        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            if (!(obj is OneOf<T0, T1>)) return false;

            var other = (OneOf<T0, T1>)obj;
            return Equals(value, other.value);
        }

        public override int GetHashCode() => (value?.GetHashCode() ?? 0);

        public override string ToString() => (value?.ToString() ?? "");
    }

    [JsonConverter(typeof(OneOfJsonConverter))]
    public struct OneOf<T0, T1, T2> : IOneOf
    {
        readonly object value;

        internal OneOf(object value)
        {
            EnsureValueIsValid(value);
            this.value = value;
        }

        static void EnsureValueIsValid(object value)
        {
            if (value == null) throw new ArgumentNullException("value");

            var valueType = value.GetType();
            if (valueType == typeof(T0)) return;
            if (valueType == typeof(T1)) return;
            if (valueType == typeof(T2)) return;

            throw new ArgumentException("value");
        }

        void EnsureValueNotNull()
        {
            if (value == null) throw new InvalidOperationException("Value has not been set");
        }

        object IOneOf.Value => value;

        public bool Is<T>()
        {
            EnsureValueNotNull();
            if (this.value.GetType() == typeof(T)) return true;

            return false;
        }

        public T As<T>()
        {
            EnsureValueNotNull();
            if (this.value.GetType() == typeof(T)) return (T)this.value;

            throw new InvalidOperationException();
        }

        public OneOf<N0> ToOneOf<N0>() => new OneOf<N0>(value);
        public OneOf<N0, N1> ToOneOf<N0, N1>() => new OneOf<N0, N1>(value);
        public OneOf<N0, N1, N2> ToOneOf<N0, N1, N2>() => new OneOf<N0, N1, N2>(value);
        public OneOf<N0, N1, N2, N3> ToOneOf<N0, N1, N2, N3>() => new OneOf<N0, N1, N2, N3>(value);
        public OneOf<N0, N1, N2, N3, N4> ToOneOf<N0, N1, N2, N3, N4>() => new OneOf<N0, N1, N2, N3, N4>(value);
        public OneOf<N0, N1, N2, N3, N4, N5> ToOneOf<N0, N1, N2, N3, N4, N5>() => new OneOf<N0, N1, N2, N3, N4, N5>(value);
        public OneOf<N0, N1, N2, N3, N4, N5, N6> ToOneOf<N0, N1, N2, N3, N4, N5, N6>() => new OneOf<N0, N1, N2, N3, N4, N5, N6>(value);
        public OneOf<N0, N1, N2, N3, N4, N5, N6, N7> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7>() => new OneOf<N0, N1, N2, N3, N4, N5, N6, N7>(value);
        public OneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8>() => new OneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8>(value);

        public static implicit operator OneOf<T0, T1, T2>(T0 value) => new OneOf<T0, T1, T2>(value);
        public static implicit operator OneOf<T0, T1, T2>(T1 value) => new OneOf<T0, T1, T2>(value);
        public static implicit operator OneOf<T0, T1, T2>(T2 value) => new OneOf<T0, T1, T2>(value);

        public void Switch(Action<T0> f0 = null, Action<T1> f1 = null, Action<T2> f2 = null, Action otherwise = null)
        {
            EnsureValueNotNull();
            var valueType = value.GetType();
            if (f0 != null && valueType == typeof(T0)) { f0((T0)this.value); return; }
            if (f1 != null && valueType == typeof(T1)) { f1((T1)this.value); return; }
            if (f2 != null && valueType == typeof(T2)) { f2((T2)this.value); return; }

            if (otherwise != null) { otherwise(); return; }

            throw new InvalidOperationException();
        }

        public TResult Match<TResult>(Func<T0, TResult> f0 = null, Func<T1, TResult> f1 = null, Func<T2, TResult> f2 = null, Func<TResult> otherwise = null)
        {
            EnsureValueNotNull();
            var valueType = value.GetType();
            if (f0 != null && valueType == typeof(T0)) return f0((T0)this.value);
            if (f1 != null && valueType == typeof(T1)) return f1((T1)this.value);
            if (f2 != null && valueType == typeof(T2)) return f2((T2)this.value);

            if (otherwise != null) return otherwise();

            throw new InvalidOperationException();
        }

        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            if (!(obj is OneOf<T0, T1, T2>)) return false;

            var other = (OneOf<T0, T1, T2>)obj;
            return Equals(value, other.value);
        }

        public override int GetHashCode() => (value?.GetHashCode() ?? 0);

        public override string ToString() => (value?.ToString() ?? "");
    }

    [JsonConverter(typeof(OneOfJsonConverter))]
    public struct OneOf<T0, T1, T2, T3> : IOneOf
    {
        readonly object value;

        internal OneOf(object value)
        {
            EnsureValueIsValid(value);
            this.value = value;
        }

        static void EnsureValueIsValid(object value)
        {
            if (value == null) throw new ArgumentNullException("value");

            var valueType = value.GetType();
            if (valueType == typeof(T0)) return;
            if (valueType == typeof(T1)) return;
            if (valueType == typeof(T2)) return;
            if (valueType == typeof(T3)) return;

            throw new ArgumentException("value");
        }

        void EnsureValueNotNull()
        {
            if (value == null) throw new InvalidOperationException("Value has not been set");
        }

        object IOneOf.Value => value;

        public bool Is<T>()
        {
            EnsureValueNotNull();
            if (this.value.GetType() == typeof(T)) return true;

            return false;
        }

        public T As<T>()
        {
            EnsureValueNotNull();
            if (this.value.GetType() == typeof(T)) return (T)this.value;

            throw new InvalidOperationException();
        }

        public OneOf<N0> ToOneOf<N0>() => new OneOf<N0>(value);
        public OneOf<N0, N1> ToOneOf<N0, N1>() => new OneOf<N0, N1>(value);
        public OneOf<N0, N1, N2> ToOneOf<N0, N1, N2>() => new OneOf<N0, N1, N2>(value);
        public OneOf<N0, N1, N2, N3> ToOneOf<N0, N1, N2, N3>() => new OneOf<N0, N1, N2, N3>(value);
        public OneOf<N0, N1, N2, N3, N4> ToOneOf<N0, N1, N2, N3, N4>() => new OneOf<N0, N1, N2, N3, N4>(value);
        public OneOf<N0, N1, N2, N3, N4, N5> ToOneOf<N0, N1, N2, N3, N4, N5>() => new OneOf<N0, N1, N2, N3, N4, N5>(value);
        public OneOf<N0, N1, N2, N3, N4, N5, N6> ToOneOf<N0, N1, N2, N3, N4, N5, N6>() => new OneOf<N0, N1, N2, N3, N4, N5, N6>(value);
        public OneOf<N0, N1, N2, N3, N4, N5, N6, N7> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7>() => new OneOf<N0, N1, N2, N3, N4, N5, N6, N7>(value);
        public OneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8>() => new OneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8>(value);

        public static implicit operator OneOf<T0, T1, T2, T3>(T0 value) => new OneOf<T0, T1, T2, T3>(value);
        public static implicit operator OneOf<T0, T1, T2, T3>(T1 value) => new OneOf<T0, T1, T2, T3>(value);
        public static implicit operator OneOf<T0, T1, T2, T3>(T2 value) => new OneOf<T0, T1, T2, T3>(value);
        public static implicit operator OneOf<T0, T1, T2, T3>(T3 value) => new OneOf<T0, T1, T2, T3>(value);

        public void Switch(Action<T0> f0 = null, Action<T1> f1 = null, Action<T2> f2 = null, Action<T3> f3 = null, Action otherwise = null)
        {
            EnsureValueNotNull();
            var valueType = value.GetType();
            if (f0 != null && valueType == typeof(T0)) { f0((T0)this.value); return; }
            if (f1 != null && valueType == typeof(T1)) { f1((T1)this.value); return; }
            if (f2 != null && valueType == typeof(T2)) { f2((T2)this.value); return; }
            if (f3 != null && valueType == typeof(T3)) { f3((T3)this.value); return; }

            if (otherwise != null) { otherwise(); return; }

            throw new InvalidOperationException();
        }

        public TResult Match<TResult>(Func<T0, TResult> f0 = null, Func<T1, TResult> f1 = null, Func<T2, TResult> f2 = null, Func<T3, TResult> f3 = null, Func<TResult> otherwise = null)
        {
            EnsureValueNotNull();
            var valueType = value.GetType();
            if (f0 != null && valueType == typeof(T0)) return f0((T0)this.value);
            if (f1 != null && valueType == typeof(T1)) return f1((T1)this.value);
            if (f2 != null && valueType == typeof(T2)) return f2((T2)this.value);
            if (f3 != null && valueType == typeof(T3)) return f3((T3)this.value);

            if (otherwise != null) return otherwise();

            throw new InvalidOperationException();
        }

        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            if (!(obj is OneOf<T0, T1, T2, T3>)) return false;

            var other = (OneOf<T0, T1, T2, T3>)obj;
            return Equals(value, other.value);
        }

        public override int GetHashCode() => (value?.GetHashCode() ?? 0);

        public override string ToString() => (value?.ToString() ?? "");
    }

    [JsonConverter(typeof(OneOfJsonConverter))]
    public struct OneOf<T0, T1, T2, T3, T4> : IOneOf
    {
        readonly object value;

        internal OneOf(object value)
        {
            EnsureValueIsValid(value);
            this.value = value;
        }

        static void EnsureValueIsValid(object value)
        {
            if (value == null) throw new ArgumentNullException("value");

            var valueType = value.GetType();
            if (valueType == typeof(T0)) return;
            if (valueType == typeof(T1)) return;
            if (valueType == typeof(T2)) return;
            if (valueType == typeof(T3)) return;
            if (valueType == typeof(T4)) return;

            throw new ArgumentException("value");
        }

        void EnsureValueNotNull()
        {
            if (value == null) throw new InvalidOperationException("Value has not been set");
        }

        object IOneOf.Value => value;

        public bool Is<T>()
        {
            EnsureValueNotNull();
            if (this.value.GetType() == typeof(T)) return true;

            return false;
        }

        public T As<T>()
        {
            EnsureValueNotNull();
            if (this.value.GetType() == typeof(T)) return (T)this.value;

            throw new InvalidOperationException();
        }

        public OneOf<N0> ToOneOf<N0>() => new OneOf<N0>(value);
        public OneOf<N0, N1> ToOneOf<N0, N1>() => new OneOf<N0, N1>(value);
        public OneOf<N0, N1, N2> ToOneOf<N0, N1, N2>() => new OneOf<N0, N1, N2>(value);
        public OneOf<N0, N1, N2, N3> ToOneOf<N0, N1, N2, N3>() => new OneOf<N0, N1, N2, N3>(value);
        public OneOf<N0, N1, N2, N3, N4> ToOneOf<N0, N1, N2, N3, N4>() => new OneOf<N0, N1, N2, N3, N4>(value);
        public OneOf<N0, N1, N2, N3, N4, N5> ToOneOf<N0, N1, N2, N3, N4, N5>() => new OneOf<N0, N1, N2, N3, N4, N5>(value);
        public OneOf<N0, N1, N2, N3, N4, N5, N6> ToOneOf<N0, N1, N2, N3, N4, N5, N6>() => new OneOf<N0, N1, N2, N3, N4, N5, N6>(value);
        public OneOf<N0, N1, N2, N3, N4, N5, N6, N7> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7>() => new OneOf<N0, N1, N2, N3, N4, N5, N6, N7>(value);
        public OneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8>() => new OneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8>(value);

        public static implicit operator OneOf<T0, T1, T2, T3, T4>(T0 value) => new OneOf<T0, T1, T2, T3, T4>(value);
        public static implicit operator OneOf<T0, T1, T2, T3, T4>(T1 value) => new OneOf<T0, T1, T2, T3, T4>(value);
        public static implicit operator OneOf<T0, T1, T2, T3, T4>(T2 value) => new OneOf<T0, T1, T2, T3, T4>(value);
        public static implicit operator OneOf<T0, T1, T2, T3, T4>(T3 value) => new OneOf<T0, T1, T2, T3, T4>(value);
        public static implicit operator OneOf<T0, T1, T2, T3, T4>(T4 value) => new OneOf<T0, T1, T2, T3, T4>(value);

        public void Switch(Action<T0> f0 = null, Action<T1> f1 = null, Action<T2> f2 = null, Action<T3> f3 = null, Action<T4> f4 = null, Action otherwise = null)
        {
            EnsureValueNotNull();
            var valueType = value.GetType();
            if (f0 != null && valueType == typeof(T0)) { f0((T0)this.value); return; }
            if (f1 != null && valueType == typeof(T1)) { f1((T1)this.value); return; }
            if (f2 != null && valueType == typeof(T2)) { f2((T2)this.value); return; }
            if (f3 != null && valueType == typeof(T3)) { f3((T3)this.value); return; }
            if (f4 != null && valueType == typeof(T4)) { f4((T4)this.value); return; }

            if (otherwise != null) { otherwise(); return; }

            throw new InvalidOperationException();
        }

        public TResult Match<TResult>(Func<T0, TResult> f0 = null, Func<T1, TResult> f1 = null, Func<T2, TResult> f2 = null, Func<T3, TResult> f3 = null, Func<T4, TResult> f4 = null, Func<TResult> otherwise = null)
        {
            EnsureValueNotNull();
            var valueType = value.GetType();
            if (f0 != null && valueType == typeof(T0)) return f0((T0)this.value);
            if (f1 != null && valueType == typeof(T1)) return f1((T1)this.value);
            if (f2 != null && valueType == typeof(T2)) return f2((T2)this.value);
            if (f3 != null && valueType == typeof(T3)) return f3((T3)this.value);
            if (f4 != null && valueType == typeof(T4)) return f4((T4)this.value);

            if (otherwise != null) return otherwise();

            throw new InvalidOperationException();
        }

        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            if (!(obj is OneOf<T0, T1, T2, T3, T4>)) return false;

            var other = (OneOf<T0, T1, T2, T3, T4>)obj;
            return Equals(value, other.value);
        }

        public override int GetHashCode() => (value?.GetHashCode() ?? 0);

        public override string ToString() => (value?.ToString() ?? "");
    }

    [JsonConverter(typeof(OneOfJsonConverter))]
    public struct OneOf<T0, T1, T2, T3, T4, T5> : IOneOf
    {
        readonly object value;

        internal OneOf(object value)
        {
            EnsureValueIsValid(value);
            this.value = value;
        }

        static void EnsureValueIsValid(object value)
        {
            if (value == null) throw new ArgumentNullException("value");

            var valueType = value.GetType();
            if (valueType == typeof(T0)) return;
            if (valueType == typeof(T1)) return;
            if (valueType == typeof(T2)) return;
            if (valueType == typeof(T3)) return;
            if (valueType == typeof(T4)) return;
            if (valueType == typeof(T5)) return;

            throw new ArgumentException("value");
        }

        void EnsureValueNotNull()
        {
            if (value == null) throw new InvalidOperationException("Value has not been set");
        }

        object IOneOf.Value => value;

        public bool Is<T>()
        {
            EnsureValueNotNull();
            if (this.value.GetType() == typeof(T)) return true;

            return false;
        }

        public T As<T>()
        {
            EnsureValueNotNull();
            if (this.value.GetType() == typeof(T)) return (T)this.value;

            throw new InvalidOperationException();
        }

        public OneOf<N0> ToOneOf<N0>() => new OneOf<N0>(value);
        public OneOf<N0, N1> ToOneOf<N0, N1>() => new OneOf<N0, N1>(value);
        public OneOf<N0, N1, N2> ToOneOf<N0, N1, N2>() => new OneOf<N0, N1, N2>(value);
        public OneOf<N0, N1, N2, N3> ToOneOf<N0, N1, N2, N3>() => new OneOf<N0, N1, N2, N3>(value);
        public OneOf<N0, N1, N2, N3, N4> ToOneOf<N0, N1, N2, N3, N4>() => new OneOf<N0, N1, N2, N3, N4>(value);
        public OneOf<N0, N1, N2, N3, N4, N5> ToOneOf<N0, N1, N2, N3, N4, N5>() => new OneOf<N0, N1, N2, N3, N4, N5>(value);
        public OneOf<N0, N1, N2, N3, N4, N5, N6> ToOneOf<N0, N1, N2, N3, N4, N5, N6>() => new OneOf<N0, N1, N2, N3, N4, N5, N6>(value);
        public OneOf<N0, N1, N2, N3, N4, N5, N6, N7> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7>() => new OneOf<N0, N1, N2, N3, N4, N5, N6, N7>(value);
        public OneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8>() => new OneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8>(value);

        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5>(T0 value) => new OneOf<T0, T1, T2, T3, T4, T5>(value);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5>(T1 value) => new OneOf<T0, T1, T2, T3, T4, T5>(value);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5>(T2 value) => new OneOf<T0, T1, T2, T3, T4, T5>(value);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5>(T3 value) => new OneOf<T0, T1, T2, T3, T4, T5>(value);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5>(T4 value) => new OneOf<T0, T1, T2, T3, T4, T5>(value);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5>(T5 value) => new OneOf<T0, T1, T2, T3, T4, T5>(value);

        public void Switch(Action<T0> f0 = null, Action<T1> f1 = null, Action<T2> f2 = null, Action<T3> f3 = null, Action<T4> f4 = null, Action<T5> f5 = null, Action otherwise = null)
        {
            EnsureValueNotNull();
            var valueType = value.GetType();
            if (f0 != null && valueType == typeof(T0)) { f0((T0)this.value); return; }
            if (f1 != null && valueType == typeof(T1)) { f1((T1)this.value); return; }
            if (f2 != null && valueType == typeof(T2)) { f2((T2)this.value); return; }
            if (f3 != null && valueType == typeof(T3)) { f3((T3)this.value); return; }
            if (f4 != null && valueType == typeof(T4)) { f4((T4)this.value); return; }
            if (f5 != null && valueType == typeof(T5)) { f5((T5)this.value); return; }

            if (otherwise != null) { otherwise(); return; }

            throw new InvalidOperationException();
        }

        public TResult Match<TResult>(Func<T0, TResult> f0 = null, Func<T1, TResult> f1 = null, Func<T2, TResult> f2 = null, Func<T3, TResult> f3 = null, Func<T4, TResult> f4 = null, Func<T5, TResult> f5 = null, Func<TResult> otherwise = null)
        {
            EnsureValueNotNull();
            var valueType = value.GetType();
            if (f0 != null && valueType == typeof(T0)) return f0((T0)this.value);
            if (f1 != null && valueType == typeof(T1)) return f1((T1)this.value);
            if (f2 != null && valueType == typeof(T2)) return f2((T2)this.value);
            if (f3 != null && valueType == typeof(T3)) return f3((T3)this.value);
            if (f4 != null && valueType == typeof(T4)) return f4((T4)this.value);
            if (f5 != null && valueType == typeof(T5)) return f5((T5)this.value);

            if (otherwise != null) return otherwise();

            throw new InvalidOperationException();
        }

        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            if (!(obj is OneOf<T0, T1, T2, T3, T4, T5>)) return false;

            var other = (OneOf<T0, T1, T2, T3, T4, T5>)obj;
            return Equals(value, other.value);
        }

        public override int GetHashCode() => (value?.GetHashCode() ?? 0);

        public override string ToString() => (value?.ToString() ?? "");
    }

    [JsonConverter(typeof(OneOfJsonConverter))]
    public struct OneOf<T0, T1, T2, T3, T4, T5, T6> : IOneOf
    {
        readonly object value;

        internal OneOf(object value)
        {
            EnsureValueIsValid(value);
            this.value = value;
        }

        static void EnsureValueIsValid(object value)
        {
            if (value == null) throw new ArgumentNullException("value");

            var valueType = value.GetType();
            if (valueType == typeof(T0)) return;
            if (valueType == typeof(T1)) return;
            if (valueType == typeof(T2)) return;
            if (valueType == typeof(T3)) return;
            if (valueType == typeof(T4)) return;
            if (valueType == typeof(T5)) return;
            if (valueType == typeof(T6)) return;

            throw new ArgumentException("value");
        }

        void EnsureValueNotNull()
        {
            if (value == null) throw new InvalidOperationException("Value has not been set");
        }

        object IOneOf.Value => value;

        public bool Is<T>()
        {
            EnsureValueNotNull();
            if (this.value.GetType() == typeof(T)) return true;

            return false;
        }

        public T As<T>()
        {
            EnsureValueNotNull();
            if (this.value.GetType() == typeof(T)) return (T)this.value;

            throw new InvalidOperationException();
        }

        public OneOf<N0> ToOneOf<N0>() => new OneOf<N0>(value);
        public OneOf<N0, N1> ToOneOf<N0, N1>() => new OneOf<N0, N1>(value);
        public OneOf<N0, N1, N2> ToOneOf<N0, N1, N2>() => new OneOf<N0, N1, N2>(value);
        public OneOf<N0, N1, N2, N3> ToOneOf<N0, N1, N2, N3>() => new OneOf<N0, N1, N2, N3>(value);
        public OneOf<N0, N1, N2, N3, N4> ToOneOf<N0, N1, N2, N3, N4>() => new OneOf<N0, N1, N2, N3, N4>(value);
        public OneOf<N0, N1, N2, N3, N4, N5> ToOneOf<N0, N1, N2, N3, N4, N5>() => new OneOf<N0, N1, N2, N3, N4, N5>(value);
        public OneOf<N0, N1, N2, N3, N4, N5, N6> ToOneOf<N0, N1, N2, N3, N4, N5, N6>() => new OneOf<N0, N1, N2, N3, N4, N5, N6>(value);
        public OneOf<N0, N1, N2, N3, N4, N5, N6, N7> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7>() => new OneOf<N0, N1, N2, N3, N4, N5, N6, N7>(value);
        public OneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8>() => new OneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8>(value);

        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5, T6>(T0 value) => new OneOf<T0, T1, T2, T3, T4, T5, T6>(value);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5, T6>(T1 value) => new OneOf<T0, T1, T2, T3, T4, T5, T6>(value);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5, T6>(T2 value) => new OneOf<T0, T1, T2, T3, T4, T5, T6>(value);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5, T6>(T3 value) => new OneOf<T0, T1, T2, T3, T4, T5, T6>(value);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5, T6>(T4 value) => new OneOf<T0, T1, T2, T3, T4, T5, T6>(value);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5, T6>(T5 value) => new OneOf<T0, T1, T2, T3, T4, T5, T6>(value);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5, T6>(T6 value) => new OneOf<T0, T1, T2, T3, T4, T5, T6>(value);

        public void Switch(Action<T0> f0 = null, Action<T1> f1 = null, Action<T2> f2 = null, Action<T3> f3 = null, Action<T4> f4 = null, Action<T5> f5 = null, Action<T6> f6 = null, Action otherwise = null)
        {
            EnsureValueNotNull();
            var valueType = value.GetType();
            if (f0 != null && valueType == typeof(T0)) { f0((T0)this.value); return; }
            if (f1 != null && valueType == typeof(T1)) { f1((T1)this.value); return; }
            if (f2 != null && valueType == typeof(T2)) { f2((T2)this.value); return; }
            if (f3 != null && valueType == typeof(T3)) { f3((T3)this.value); return; }
            if (f4 != null && valueType == typeof(T4)) { f4((T4)this.value); return; }
            if (f5 != null && valueType == typeof(T5)) { f5((T5)this.value); return; }
            if (f6 != null && valueType == typeof(T6)) { f6((T6)this.value); return; }

            if (otherwise != null) { otherwise(); return; }

            throw new InvalidOperationException();
        }

        public TResult Match<TResult>(Func<T0, TResult> f0 = null, Func<T1, TResult> f1 = null, Func<T2, TResult> f2 = null, Func<T3, TResult> f3 = null, Func<T4, TResult> f4 = null, Func<T5, TResult> f5 = null, Func<T6, TResult> f6 = null, Func<TResult> otherwise = null)
        {
            EnsureValueNotNull();
            var valueType = value.GetType();
            if (f0 != null && valueType == typeof(T0)) return f0((T0)this.value);
            if (f1 != null && valueType == typeof(T1)) return f1((T1)this.value);
            if (f2 != null && valueType == typeof(T2)) return f2((T2)this.value);
            if (f3 != null && valueType == typeof(T3)) return f3((T3)this.value);
            if (f4 != null && valueType == typeof(T4)) return f4((T4)this.value);
            if (f5 != null && valueType == typeof(T5)) return f5((T5)this.value);
            if (f6 != null && valueType == typeof(T6)) return f6((T6)this.value);

            if (otherwise != null) return otherwise();

            throw new InvalidOperationException();
        }

        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            if (!(obj is OneOf<T0, T1, T2, T3, T4, T5, T6>)) return false;

            var other = (OneOf<T0, T1, T2, T3, T4, T5, T6>)obj;
            return Equals(value, other.value);
        }

        public override int GetHashCode() => (value?.GetHashCode() ?? 0);

        public override string ToString() => (value?.ToString() ?? "");
    }

    [JsonConverter(typeof(OneOfJsonConverter))]
    public struct OneOf<T0, T1, T2, T3, T4, T5, T6, T7> : IOneOf
    {
        readonly object value;

        internal OneOf(object value)
        {
            EnsureValueIsValid(value);
            this.value = value;
        }

        static void EnsureValueIsValid(object value)
        {
            if (value == null) throw new ArgumentNullException("value");

            var valueType = value.GetType();
            if (valueType == typeof(T0)) return;
            if (valueType == typeof(T1)) return;
            if (valueType == typeof(T2)) return;
            if (valueType == typeof(T3)) return;
            if (valueType == typeof(T4)) return;
            if (valueType == typeof(T5)) return;
            if (valueType == typeof(T6)) return;
            if (valueType == typeof(T7)) return;

            throw new ArgumentException("value");
        }

        void EnsureValueNotNull()
        {
            if (value == null) throw new InvalidOperationException("Value has not been set");
        }

        object IOneOf.Value => value;

        public bool Is<T>()
        {
            EnsureValueNotNull();
            if (this.value.GetType() == typeof(T)) return true;

            return false;
        }

        public T As<T>()
        {
            EnsureValueNotNull();
            if (this.value.GetType() == typeof(T)) return (T)this.value;

            throw new InvalidOperationException();
        }

        public OneOf<N0> ToOneOf<N0>() => new OneOf<N0>(value);
        public OneOf<N0, N1> ToOneOf<N0, N1>() => new OneOf<N0, N1>(value);
        public OneOf<N0, N1, N2> ToOneOf<N0, N1, N2>() => new OneOf<N0, N1, N2>(value);
        public OneOf<N0, N1, N2, N3> ToOneOf<N0, N1, N2, N3>() => new OneOf<N0, N1, N2, N3>(value);
        public OneOf<N0, N1, N2, N3, N4> ToOneOf<N0, N1, N2, N3, N4>() => new OneOf<N0, N1, N2, N3, N4>(value);
        public OneOf<N0, N1, N2, N3, N4, N5> ToOneOf<N0, N1, N2, N3, N4, N5>() => new OneOf<N0, N1, N2, N3, N4, N5>(value);
        public OneOf<N0, N1, N2, N3, N4, N5, N6> ToOneOf<N0, N1, N2, N3, N4, N5, N6>() => new OneOf<N0, N1, N2, N3, N4, N5, N6>(value);
        public OneOf<N0, N1, N2, N3, N4, N5, N6, N7> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7>() => new OneOf<N0, N1, N2, N3, N4, N5, N6, N7>(value);
        public OneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8>() => new OneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8>(value);

        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5, T6, T7>(T0 value) => new OneOf<T0, T1, T2, T3, T4, T5, T6, T7>(value);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5, T6, T7>(T1 value) => new OneOf<T0, T1, T2, T3, T4, T5, T6, T7>(value);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5, T6, T7>(T2 value) => new OneOf<T0, T1, T2, T3, T4, T5, T6, T7>(value);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5, T6, T7>(T3 value) => new OneOf<T0, T1, T2, T3, T4, T5, T6, T7>(value);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5, T6, T7>(T4 value) => new OneOf<T0, T1, T2, T3, T4, T5, T6, T7>(value);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5, T6, T7>(T5 value) => new OneOf<T0, T1, T2, T3, T4, T5, T6, T7>(value);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5, T6, T7>(T6 value) => new OneOf<T0, T1, T2, T3, T4, T5, T6, T7>(value);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5, T6, T7>(T7 value) => new OneOf<T0, T1, T2, T3, T4, T5, T6, T7>(value);

        public void Switch(Action<T0> f0 = null, Action<T1> f1 = null, Action<T2> f2 = null, Action<T3> f3 = null, Action<T4> f4 = null, Action<T5> f5 = null, Action<T6> f6 = null, Action<T7> f7 = null, Action otherwise = null)
        {
            EnsureValueNotNull();
            var valueType = value.GetType();
            if (f0 != null && valueType == typeof(T0)) { f0((T0)this.value); return; }
            if (f1 != null && valueType == typeof(T1)) { f1((T1)this.value); return; }
            if (f2 != null && valueType == typeof(T2)) { f2((T2)this.value); return; }
            if (f3 != null && valueType == typeof(T3)) { f3((T3)this.value); return; }
            if (f4 != null && valueType == typeof(T4)) { f4((T4)this.value); return; }
            if (f5 != null && valueType == typeof(T5)) { f5((T5)this.value); return; }
            if (f6 != null && valueType == typeof(T6)) { f6((T6)this.value); return; }
            if (f7 != null && valueType == typeof(T7)) { f7((T7)this.value); return; }

            if (otherwise != null) { otherwise(); return; }

            throw new InvalidOperationException();
        }

        public TResult Match<TResult>(Func<T0, TResult> f0 = null, Func<T1, TResult> f1 = null, Func<T2, TResult> f2 = null, Func<T3, TResult> f3 = null, Func<T4, TResult> f4 = null, Func<T5, TResult> f5 = null, Func<T6, TResult> f6 = null, Func<T7, TResult> f7 = null, Func<TResult> otherwise = null)
        {
            EnsureValueNotNull();
            var valueType = value.GetType();
            if (f0 != null && valueType == typeof(T0)) return f0((T0)this.value);
            if (f1 != null && valueType == typeof(T1)) return f1((T1)this.value);
            if (f2 != null && valueType == typeof(T2)) return f2((T2)this.value);
            if (f3 != null && valueType == typeof(T3)) return f3((T3)this.value);
            if (f4 != null && valueType == typeof(T4)) return f4((T4)this.value);
            if (f5 != null && valueType == typeof(T5)) return f5((T5)this.value);
            if (f6 != null && valueType == typeof(T6)) return f6((T6)this.value);
            if (f7 != null && valueType == typeof(T7)) return f7((T7)this.value);

            if (otherwise != null) return otherwise();

            throw new InvalidOperationException();
        }

        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            if (!(obj is OneOf<T0, T1, T2, T3, T4, T5, T6, T7>)) return false;

            var other = (OneOf<T0, T1, T2, T3, T4, T5, T6, T7>)obj;
            return Equals(value, other.value);
        }

        public override int GetHashCode() => (value?.GetHashCode() ?? 0);

        public override string ToString() => (value?.ToString() ?? "");
    }

    [JsonConverter(typeof(OneOfJsonConverter))]
    public struct OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8> : IOneOf
    {
        readonly object value;

        internal OneOf(object value)
        {
            EnsureValueIsValid(value);
            this.value = value;
        }

        static void EnsureValueIsValid(object value)
        {
            if (value == null) throw new ArgumentNullException("value");

            var valueType = value.GetType();
            if (valueType == typeof(T0)) return;
            if (valueType == typeof(T1)) return;
            if (valueType == typeof(T2)) return;
            if (valueType == typeof(T3)) return;
            if (valueType == typeof(T4)) return;
            if (valueType == typeof(T5)) return;
            if (valueType == typeof(T6)) return;
            if (valueType == typeof(T7)) return;
            if (valueType == typeof(T8)) return;

            throw new ArgumentException("value");
        }

        void EnsureValueNotNull()
        {
            if (value == null) throw new InvalidOperationException("Value has not been set");
        }

        object IOneOf.Value => value;

        public bool Is<T>()
        {
            EnsureValueNotNull();
            if (this.value.GetType() == typeof(T)) return true;

            return false;
        }

        public T As<T>()
        {
            EnsureValueNotNull();
            if (this.value.GetType() == typeof(T)) return (T)this.value;

            throw new InvalidOperationException();
        }

        public OneOf<N0> ToOneOf<N0>() => new OneOf<N0>(value);
        public OneOf<N0, N1> ToOneOf<N0, N1>() => new OneOf<N0, N1>(value);
        public OneOf<N0, N1, N2> ToOneOf<N0, N1, N2>() => new OneOf<N0, N1, N2>(value);
        public OneOf<N0, N1, N2, N3> ToOneOf<N0, N1, N2, N3>() => new OneOf<N0, N1, N2, N3>(value);
        public OneOf<N0, N1, N2, N3, N4> ToOneOf<N0, N1, N2, N3, N4>() => new OneOf<N0, N1, N2, N3, N4>(value);
        public OneOf<N0, N1, N2, N3, N4, N5> ToOneOf<N0, N1, N2, N3, N4, N5>() => new OneOf<N0, N1, N2, N3, N4, N5>(value);
        public OneOf<N0, N1, N2, N3, N4, N5, N6> ToOneOf<N0, N1, N2, N3, N4, N5, N6>() => new OneOf<N0, N1, N2, N3, N4, N5, N6>(value);
        public OneOf<N0, N1, N2, N3, N4, N5, N6, N7> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7>() => new OneOf<N0, N1, N2, N3, N4, N5, N6, N7>(value);
        public OneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8>() => new OneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8>(value);

        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8>(T0 value) => new OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8>(value);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8>(T1 value) => new OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8>(value);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8>(T2 value) => new OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8>(value);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8>(T3 value) => new OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8>(value);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8>(T4 value) => new OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8>(value);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8>(T5 value) => new OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8>(value);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8>(T6 value) => new OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8>(value);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8>(T7 value) => new OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8>(value);
        public static implicit operator OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8>(T8 value) => new OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8>(value);

        public void Switch(Action<T0> f0 = null, Action<T1> f1 = null, Action<T2> f2 = null, Action<T3> f3 = null, Action<T4> f4 = null, Action<T5> f5 = null, Action<T6> f6 = null, Action<T7> f7 = null, Action<T8> f8 = null, Action otherwise = null)
        {
            EnsureValueNotNull();
            var valueType = value.GetType();
            if (f0 != null && valueType == typeof(T0)) { f0((T0)this.value); return; }
            if (f1 != null && valueType == typeof(T1)) { f1((T1)this.value); return; }
            if (f2 != null && valueType == typeof(T2)) { f2((T2)this.value); return; }
            if (f3 != null && valueType == typeof(T3)) { f3((T3)this.value); return; }
            if (f4 != null && valueType == typeof(T4)) { f4((T4)this.value); return; }
            if (f5 != null && valueType == typeof(T5)) { f5((T5)this.value); return; }
            if (f6 != null && valueType == typeof(T6)) { f6((T6)this.value); return; }
            if (f7 != null && valueType == typeof(T7)) { f7((T7)this.value); return; }
            if (f8 != null && valueType == typeof(T8)) { f8((T8)this.value); return; }

            if (otherwise != null) { otherwise(); return; }

            throw new InvalidOperationException();
        }

        public TResult Match<TResult>(Func<T0, TResult> f0 = null, Func<T1, TResult> f1 = null, Func<T2, TResult> f2 = null, Func<T3, TResult> f3 = null, Func<T4, TResult> f4 = null, Func<T5, TResult> f5 = null, Func<T6, TResult> f6 = null, Func<T7, TResult> f7 = null, Func<T8, TResult> f8 = null, Func<TResult> otherwise = null)
        {
            EnsureValueNotNull();
            var valueType = value.GetType();
            if (f0 != null && valueType == typeof(T0)) return f0((T0)this.value);
            if (f1 != null && valueType == typeof(T1)) return f1((T1)this.value);
            if (f2 != null && valueType == typeof(T2)) return f2((T2)this.value);
            if (f3 != null && valueType == typeof(T3)) return f3((T3)this.value);
            if (f4 != null && valueType == typeof(T4)) return f4((T4)this.value);
            if (f5 != null && valueType == typeof(T5)) return f5((T5)this.value);
            if (f6 != null && valueType == typeof(T6)) return f6((T6)this.value);
            if (f7 != null && valueType == typeof(T7)) return f7((T7)this.value);
            if (f8 != null && valueType == typeof(T8)) return f8((T8)this.value);

            if (otherwise != null) return otherwise();

            throw new InvalidOperationException();
        }

        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            if (!(obj is OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8>)) return false;

            var other = (OneOf<T0, T1, T2, T3, T4, T5, T6, T7, T8>)obj;
            return Equals(value, other.value);
        }

        public override int GetHashCode() => (value?.GetHashCode() ?? 0);

        public override string ToString() => (value?.ToString() ?? "");
    }

    [JsonConverter(typeof(OneOfJsonConverter))]
    public class OneOfBase<T0> : IOneOf
    {
        readonly object value;

        internal OneOfBase(object value)
        {
            EnsureValueIsValid(value);
            this.value = value;
        }

        protected OneOfBase()
        {
            EnsureValueIsValid(this);
            this.value = this;
        }

        static void EnsureValueIsValid(object value)
        {
            if (value == null) throw new ArgumentNullException("value");

            var valueType = value.GetType();
            if (valueType == typeof(T0)) return;

            throw new ArgumentException("value");
        }

        void EnsureValueNotNull()
        {
            if (value == null) throw new InvalidOperationException("Value has not been set");
        }

        object IOneOf.Value => value;

        public bool Is<T>()
        {
            EnsureValueNotNull();
            if (this.value.GetType() == typeof(T)) return true;

            return false;
        }

        public T As<T>()
        {
            EnsureValueNotNull();
            if (this.value.GetType() == typeof(T)) return (T)this.value;

            throw new InvalidOperationException();
        }

        public OneOfBase<N0> ToOneOf<N0>() => new OneOfBase<N0>(value);
        public OneOfBase<N0, N1> ToOneOf<N0, N1>() => new OneOfBase<N0, N1>(value);
        public OneOfBase<N0, N1, N2> ToOneOf<N0, N1, N2>() => new OneOfBase<N0, N1, N2>(value);
        public OneOfBase<N0, N1, N2, N3> ToOneOf<N0, N1, N2, N3>() => new OneOfBase<N0, N1, N2, N3>(value);
        public OneOfBase<N0, N1, N2, N3, N4> ToOneOf<N0, N1, N2, N3, N4>() => new OneOfBase<N0, N1, N2, N3, N4>(value);
        public OneOfBase<N0, N1, N2, N3, N4, N5> ToOneOf<N0, N1, N2, N3, N4, N5>() => new OneOfBase<N0, N1, N2, N3, N4, N5>(value);
        public OneOfBase<N0, N1, N2, N3, N4, N5, N6> ToOneOf<N0, N1, N2, N3, N4, N5, N6>() => new OneOfBase<N0, N1, N2, N3, N4, N5, N6>(value);
        public OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7>() => new OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7>(value);
        public OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7, N8> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8>() => new OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7, N8>(value);

        public static implicit operator OneOfBase<T0>(T0 value) => new OneOfBase<T0>(value);

        public void Switch(Action<T0> f0 = null, Action otherwise = null)
        {
            EnsureValueNotNull();
            var valueType = value.GetType();
            if (f0 != null && valueType == typeof(T0)) { f0((T0)this.value); return; }

            if (otherwise != null) { otherwise(); return; }

            throw new InvalidOperationException();
        }

        public TResult Match<TResult>(Func<T0, TResult> f0 = null, Func<TResult> otherwise = null)
        {
            EnsureValueNotNull();
            var valueType = value.GetType();
            if (f0 != null && valueType == typeof(T0)) return f0((T0)this.value);

            if (otherwise != null) return otherwise();

            throw new InvalidOperationException();
        }

        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            if (!(obj is OneOfBase<T0>)) return false;

            var other = (OneOfBase<T0>)obj;
            return Equals(value, other.value);
        }

        public override int GetHashCode() => (value?.GetHashCode() ?? 0);

        public override string ToString() => (value?.ToString() ?? "");
    }

    [JsonConverter(typeof(OneOfJsonConverter))]
    public class OneOfBase<T0, T1> : IOneOf
    {
        readonly object value;

        internal OneOfBase(object value)
        {
            EnsureValueIsValid(value);
            this.value = value;
        }

        protected OneOfBase()
        {
            EnsureValueIsValid(this);
            this.value = this;
        }

        static void EnsureValueIsValid(object value)
        {
            if (value == null) throw new ArgumentNullException("value");

            var valueType = value.GetType();
            if (valueType == typeof(T0)) return;
            if (valueType == typeof(T1)) return;

            throw new ArgumentException("value");
        }

        void EnsureValueNotNull()
        {
            if (value == null) throw new InvalidOperationException("Value has not been set");
        }

        object IOneOf.Value => value;

        public bool Is<T>()
        {
            EnsureValueNotNull();
            if (this.value.GetType() == typeof(T)) return true;

            return false;
        }

        public T As<T>()
        {
            EnsureValueNotNull();
            if (this.value.GetType() == typeof(T)) return (T)this.value;

            throw new InvalidOperationException();
        }

        public OneOfBase<N0> ToOneOf<N0>() => new OneOfBase<N0>(value);
        public OneOfBase<N0, N1> ToOneOf<N0, N1>() => new OneOfBase<N0, N1>(value);
        public OneOfBase<N0, N1, N2> ToOneOf<N0, N1, N2>() => new OneOfBase<N0, N1, N2>(value);
        public OneOfBase<N0, N1, N2, N3> ToOneOf<N0, N1, N2, N3>() => new OneOfBase<N0, N1, N2, N3>(value);
        public OneOfBase<N0, N1, N2, N3, N4> ToOneOf<N0, N1, N2, N3, N4>() => new OneOfBase<N0, N1, N2, N3, N4>(value);
        public OneOfBase<N0, N1, N2, N3, N4, N5> ToOneOf<N0, N1, N2, N3, N4, N5>() => new OneOfBase<N0, N1, N2, N3, N4, N5>(value);
        public OneOfBase<N0, N1, N2, N3, N4, N5, N6> ToOneOf<N0, N1, N2, N3, N4, N5, N6>() => new OneOfBase<N0, N1, N2, N3, N4, N5, N6>(value);
        public OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7>() => new OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7>(value);
        public OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7, N8> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8>() => new OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7, N8>(value);

        public static implicit operator OneOfBase<T0, T1>(T0 value) => new OneOfBase<T0, T1>(value);
        public static implicit operator OneOfBase<T0, T1>(T1 value) => new OneOfBase<T0, T1>(value);

        public void Switch(Action<T0> f0 = null, Action<T1> f1 = null, Action otherwise = null)
        {
            EnsureValueNotNull();
            var valueType = value.GetType();
            if (f0 != null && valueType == typeof(T0)) { f0((T0)this.value); return; }
            if (f1 != null && valueType == typeof(T1)) { f1((T1)this.value); return; }

            if (otherwise != null) { otherwise(); return; }

            throw new InvalidOperationException();
        }

        public TResult Match<TResult>(Func<T0, TResult> f0 = null, Func<T1, TResult> f1 = null, Func<TResult> otherwise = null)
        {
            EnsureValueNotNull();
            var valueType = value.GetType();
            if (f0 != null && valueType == typeof(T0)) return f0((T0)this.value);
            if (f1 != null && valueType == typeof(T1)) return f1((T1)this.value);

            if (otherwise != null) return otherwise();

            throw new InvalidOperationException();
        }

        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            if (!(obj is OneOfBase<T0, T1>)) return false;

            var other = (OneOfBase<T0, T1>)obj;
            return Equals(value, other.value);
        }

        public override int GetHashCode() => (value?.GetHashCode() ?? 0);

        public override string ToString() => (value?.ToString() ?? "");
    }

    [JsonConverter(typeof(OneOfJsonConverter))]
    public class OneOfBase<T0, T1, T2> : IOneOf
    {
        readonly object value;

        internal OneOfBase(object value)
        {
            EnsureValueIsValid(value);
            this.value = value;
        }

        protected OneOfBase()
        {
            EnsureValueIsValid(this);
            this.value = this;
        }

        static void EnsureValueIsValid(object value)
        {
            if (value == null) throw new ArgumentNullException("value");

            var valueType = value.GetType();
            if (valueType == typeof(T0)) return;
            if (valueType == typeof(T1)) return;
            if (valueType == typeof(T2)) return;

            throw new ArgumentException("value");
        }

        void EnsureValueNotNull()
        {
            if (value == null) throw new InvalidOperationException("Value has not been set");
        }

        object IOneOf.Value => value;

        public bool Is<T>()
        {
            EnsureValueNotNull();
            if (this.value.GetType() == typeof(T)) return true;

            return false;
        }

        public T As<T>()
        {
            EnsureValueNotNull();
            if (this.value.GetType() == typeof(T)) return (T)this.value;

            throw new InvalidOperationException();
        }

        public OneOfBase<N0> ToOneOf<N0>() => new OneOfBase<N0>(value);
        public OneOfBase<N0, N1> ToOneOf<N0, N1>() => new OneOfBase<N0, N1>(value);
        public OneOfBase<N0, N1, N2> ToOneOf<N0, N1, N2>() => new OneOfBase<N0, N1, N2>(value);
        public OneOfBase<N0, N1, N2, N3> ToOneOf<N0, N1, N2, N3>() => new OneOfBase<N0, N1, N2, N3>(value);
        public OneOfBase<N0, N1, N2, N3, N4> ToOneOf<N0, N1, N2, N3, N4>() => new OneOfBase<N0, N1, N2, N3, N4>(value);
        public OneOfBase<N0, N1, N2, N3, N4, N5> ToOneOf<N0, N1, N2, N3, N4, N5>() => new OneOfBase<N0, N1, N2, N3, N4, N5>(value);
        public OneOfBase<N0, N1, N2, N3, N4, N5, N6> ToOneOf<N0, N1, N2, N3, N4, N5, N6>() => new OneOfBase<N0, N1, N2, N3, N4, N5, N6>(value);
        public OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7>() => new OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7>(value);
        public OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7, N8> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8>() => new OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7, N8>(value);

        public static implicit operator OneOfBase<T0, T1, T2>(T0 value) => new OneOfBase<T0, T1, T2>(value);
        public static implicit operator OneOfBase<T0, T1, T2>(T1 value) => new OneOfBase<T0, T1, T2>(value);
        public static implicit operator OneOfBase<T0, T1, T2>(T2 value) => new OneOfBase<T0, T1, T2>(value);

        public void Switch(Action<T0> f0 = null, Action<T1> f1 = null, Action<T2> f2 = null, Action otherwise = null)
        {
            EnsureValueNotNull();
            var valueType = value.GetType();
            if (f0 != null && valueType == typeof(T0)) { f0((T0)this.value); return; }
            if (f1 != null && valueType == typeof(T1)) { f1((T1)this.value); return; }
            if (f2 != null && valueType == typeof(T2)) { f2((T2)this.value); return; }

            if (otherwise != null) { otherwise(); return; }

            throw new InvalidOperationException();
        }

        public TResult Match<TResult>(Func<T0, TResult> f0 = null, Func<T1, TResult> f1 = null, Func<T2, TResult> f2 = null, Func<TResult> otherwise = null)
        {
            EnsureValueNotNull();
            var valueType = value.GetType();
            if (f0 != null && valueType == typeof(T0)) return f0((T0)this.value);
            if (f1 != null && valueType == typeof(T1)) return f1((T1)this.value);
            if (f2 != null && valueType == typeof(T2)) return f2((T2)this.value);

            if (otherwise != null) return otherwise();

            throw new InvalidOperationException();
        }

        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            if (!(obj is OneOfBase<T0, T1, T2>)) return false;

            var other = (OneOfBase<T0, T1, T2>)obj;
            return Equals(value, other.value);
        }

        public override int GetHashCode() => (value?.GetHashCode() ?? 0);

        public override string ToString() => (value?.ToString() ?? "");
    }

    [JsonConverter(typeof(OneOfJsonConverter))]
    public class OneOfBase<T0, T1, T2, T3> : IOneOf
    {
        readonly object value;

        internal OneOfBase(object value)
        {
            EnsureValueIsValid(value);
            this.value = value;
        }

        protected OneOfBase()
        {
            EnsureValueIsValid(this);
            this.value = this;
        }

        static void EnsureValueIsValid(object value)
        {
            if (value == null) throw new ArgumentNullException("value");

            var valueType = value.GetType();
            if (valueType == typeof(T0)) return;
            if (valueType == typeof(T1)) return;
            if (valueType == typeof(T2)) return;
            if (valueType == typeof(T3)) return;

            throw new ArgumentException("value");
        }

        void EnsureValueNotNull()
        {
            if (value == null) throw new InvalidOperationException("Value has not been set");
        }

        object IOneOf.Value => value;

        public bool Is<T>()
        {
            EnsureValueNotNull();
            if (this.value.GetType() == typeof(T)) return true;

            return false;
        }

        public T As<T>()
        {
            EnsureValueNotNull();
            if (this.value.GetType() == typeof(T)) return (T)this.value;

            throw new InvalidOperationException();
        }

        public OneOfBase<N0> ToOneOf<N0>() => new OneOfBase<N0>(value);
        public OneOfBase<N0, N1> ToOneOf<N0, N1>() => new OneOfBase<N0, N1>(value);
        public OneOfBase<N0, N1, N2> ToOneOf<N0, N1, N2>() => new OneOfBase<N0, N1, N2>(value);
        public OneOfBase<N0, N1, N2, N3> ToOneOf<N0, N1, N2, N3>() => new OneOfBase<N0, N1, N2, N3>(value);
        public OneOfBase<N0, N1, N2, N3, N4> ToOneOf<N0, N1, N2, N3, N4>() => new OneOfBase<N0, N1, N2, N3, N4>(value);
        public OneOfBase<N0, N1, N2, N3, N4, N5> ToOneOf<N0, N1, N2, N3, N4, N5>() => new OneOfBase<N0, N1, N2, N3, N4, N5>(value);
        public OneOfBase<N0, N1, N2, N3, N4, N5, N6> ToOneOf<N0, N1, N2, N3, N4, N5, N6>() => new OneOfBase<N0, N1, N2, N3, N4, N5, N6>(value);
        public OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7>() => new OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7>(value);
        public OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7, N8> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8>() => new OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7, N8>(value);

        public static implicit operator OneOfBase<T0, T1, T2, T3>(T0 value) => new OneOfBase<T0, T1, T2, T3>(value);
        public static implicit operator OneOfBase<T0, T1, T2, T3>(T1 value) => new OneOfBase<T0, T1, T2, T3>(value);
        public static implicit operator OneOfBase<T0, T1, T2, T3>(T2 value) => new OneOfBase<T0, T1, T2, T3>(value);
        public static implicit operator OneOfBase<T0, T1, T2, T3>(T3 value) => new OneOfBase<T0, T1, T2, T3>(value);

        public void Switch(Action<T0> f0 = null, Action<T1> f1 = null, Action<T2> f2 = null, Action<T3> f3 = null, Action otherwise = null)
        {
            EnsureValueNotNull();
            var valueType = value.GetType();
            if (f0 != null && valueType == typeof(T0)) { f0((T0)this.value); return; }
            if (f1 != null && valueType == typeof(T1)) { f1((T1)this.value); return; }
            if (f2 != null && valueType == typeof(T2)) { f2((T2)this.value); return; }
            if (f3 != null && valueType == typeof(T3)) { f3((T3)this.value); return; }

            if (otherwise != null) { otherwise(); return; }

            throw new InvalidOperationException();
        }

        public TResult Match<TResult>(Func<T0, TResult> f0 = null, Func<T1, TResult> f1 = null, Func<T2, TResult> f2 = null, Func<T3, TResult> f3 = null, Func<TResult> otherwise = null)
        {
            EnsureValueNotNull();
            var valueType = value.GetType();
            if (f0 != null && valueType == typeof(T0)) return f0((T0)this.value);
            if (f1 != null && valueType == typeof(T1)) return f1((T1)this.value);
            if (f2 != null && valueType == typeof(T2)) return f2((T2)this.value);
            if (f3 != null && valueType == typeof(T3)) return f3((T3)this.value);

            if (otherwise != null) return otherwise();

            throw new InvalidOperationException();
        }

        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            if (!(obj is OneOfBase<T0, T1, T2, T3>)) return false;

            var other = (OneOfBase<T0, T1, T2, T3>)obj;
            return Equals(value, other.value);
        }

        public override int GetHashCode() => (value?.GetHashCode() ?? 0);

        public override string ToString() => (value?.ToString() ?? "");
    }

    [JsonConverter(typeof(OneOfJsonConverter))]
    public class OneOfBase<T0, T1, T2, T3, T4> : IOneOf
    {
        readonly object value;

        internal OneOfBase(object value)
        {
            EnsureValueIsValid(value);
            this.value = value;
        }

        protected OneOfBase()
        {
            EnsureValueIsValid(this);
            this.value = this;
        }

        static void EnsureValueIsValid(object value)
        {
            if (value == null) throw new ArgumentNullException("value");

            var valueType = value.GetType();
            if (valueType == typeof(T0)) return;
            if (valueType == typeof(T1)) return;
            if (valueType == typeof(T2)) return;
            if (valueType == typeof(T3)) return;
            if (valueType == typeof(T4)) return;

            throw new ArgumentException("value");
        }

        void EnsureValueNotNull()
        {
            if (value == null) throw new InvalidOperationException("Value has not been set");
        }

        object IOneOf.Value => value;

        public bool Is<T>()
        {
            EnsureValueNotNull();
            if (this.value.GetType() == typeof(T)) return true;

            return false;
        }

        public T As<T>()
        {
            EnsureValueNotNull();
            if (this.value.GetType() == typeof(T)) return (T)this.value;

            throw new InvalidOperationException();
        }

        public OneOfBase<N0> ToOneOf<N0>() => new OneOfBase<N0>(value);
        public OneOfBase<N0, N1> ToOneOf<N0, N1>() => new OneOfBase<N0, N1>(value);
        public OneOfBase<N0, N1, N2> ToOneOf<N0, N1, N2>() => new OneOfBase<N0, N1, N2>(value);
        public OneOfBase<N0, N1, N2, N3> ToOneOf<N0, N1, N2, N3>() => new OneOfBase<N0, N1, N2, N3>(value);
        public OneOfBase<N0, N1, N2, N3, N4> ToOneOf<N0, N1, N2, N3, N4>() => new OneOfBase<N0, N1, N2, N3, N4>(value);
        public OneOfBase<N0, N1, N2, N3, N4, N5> ToOneOf<N0, N1, N2, N3, N4, N5>() => new OneOfBase<N0, N1, N2, N3, N4, N5>(value);
        public OneOfBase<N0, N1, N2, N3, N4, N5, N6> ToOneOf<N0, N1, N2, N3, N4, N5, N6>() => new OneOfBase<N0, N1, N2, N3, N4, N5, N6>(value);
        public OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7>() => new OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7>(value);
        public OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7, N8> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8>() => new OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7, N8>(value);

        public static implicit operator OneOfBase<T0, T1, T2, T3, T4>(T0 value) => new OneOfBase<T0, T1, T2, T3, T4>(value);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4>(T1 value) => new OneOfBase<T0, T1, T2, T3, T4>(value);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4>(T2 value) => new OneOfBase<T0, T1, T2, T3, T4>(value);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4>(T3 value) => new OneOfBase<T0, T1, T2, T3, T4>(value);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4>(T4 value) => new OneOfBase<T0, T1, T2, T3, T4>(value);

        public void Switch(Action<T0> f0 = null, Action<T1> f1 = null, Action<T2> f2 = null, Action<T3> f3 = null, Action<T4> f4 = null, Action otherwise = null)
        {
            EnsureValueNotNull();
            var valueType = value.GetType();
            if (f0 != null && valueType == typeof(T0)) { f0((T0)this.value); return; }
            if (f1 != null && valueType == typeof(T1)) { f1((T1)this.value); return; }
            if (f2 != null && valueType == typeof(T2)) { f2((T2)this.value); return; }
            if (f3 != null && valueType == typeof(T3)) { f3((T3)this.value); return; }
            if (f4 != null && valueType == typeof(T4)) { f4((T4)this.value); return; }

            if (otherwise != null) { otherwise(); return; }

            throw new InvalidOperationException();
        }

        public TResult Match<TResult>(Func<T0, TResult> f0 = null, Func<T1, TResult> f1 = null, Func<T2, TResult> f2 = null, Func<T3, TResult> f3 = null, Func<T4, TResult> f4 = null, Func<TResult> otherwise = null)
        {
            EnsureValueNotNull();
            var valueType = value.GetType();
            if (f0 != null && valueType == typeof(T0)) return f0((T0)this.value);
            if (f1 != null && valueType == typeof(T1)) return f1((T1)this.value);
            if (f2 != null && valueType == typeof(T2)) return f2((T2)this.value);
            if (f3 != null && valueType == typeof(T3)) return f3((T3)this.value);
            if (f4 != null && valueType == typeof(T4)) return f4((T4)this.value);

            if (otherwise != null) return otherwise();

            throw new InvalidOperationException();
        }

        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            if (!(obj is OneOfBase<T0, T1, T2, T3, T4>)) return false;

            var other = (OneOfBase<T0, T1, T2, T3, T4>)obj;
            return Equals(value, other.value);
        }

        public override int GetHashCode() => (value?.GetHashCode() ?? 0);

        public override string ToString() => (value?.ToString() ?? "");
    }

    [JsonConverter(typeof(OneOfJsonConverter))]
    public class OneOfBase<T0, T1, T2, T3, T4, T5> : IOneOf
    {
        readonly object value;

        internal OneOfBase(object value)
        {
            EnsureValueIsValid(value);
            this.value = value;
        }

        protected OneOfBase()
        {
            EnsureValueIsValid(this);
            this.value = this;
        }

        static void EnsureValueIsValid(object value)
        {
            if (value == null) throw new ArgumentNullException("value");

            var valueType = value.GetType();
            if (valueType == typeof(T0)) return;
            if (valueType == typeof(T1)) return;
            if (valueType == typeof(T2)) return;
            if (valueType == typeof(T3)) return;
            if (valueType == typeof(T4)) return;
            if (valueType == typeof(T5)) return;

            throw new ArgumentException("value");
        }

        void EnsureValueNotNull()
        {
            if (value == null) throw new InvalidOperationException("Value has not been set");
        }

        object IOneOf.Value => value;

        public bool Is<T>()
        {
            EnsureValueNotNull();
            if (this.value.GetType() == typeof(T)) return true;

            return false;
        }

        public T As<T>()
        {
            EnsureValueNotNull();
            if (this.value.GetType() == typeof(T)) return (T)this.value;

            throw new InvalidOperationException();
        }

        public OneOfBase<N0> ToOneOf<N0>() => new OneOfBase<N0>(value);
        public OneOfBase<N0, N1> ToOneOf<N0, N1>() => new OneOfBase<N0, N1>(value);
        public OneOfBase<N0, N1, N2> ToOneOf<N0, N1, N2>() => new OneOfBase<N0, N1, N2>(value);
        public OneOfBase<N0, N1, N2, N3> ToOneOf<N0, N1, N2, N3>() => new OneOfBase<N0, N1, N2, N3>(value);
        public OneOfBase<N0, N1, N2, N3, N4> ToOneOf<N0, N1, N2, N3, N4>() => new OneOfBase<N0, N1, N2, N3, N4>(value);
        public OneOfBase<N0, N1, N2, N3, N4, N5> ToOneOf<N0, N1, N2, N3, N4, N5>() => new OneOfBase<N0, N1, N2, N3, N4, N5>(value);
        public OneOfBase<N0, N1, N2, N3, N4, N5, N6> ToOneOf<N0, N1, N2, N3, N4, N5, N6>() => new OneOfBase<N0, N1, N2, N3, N4, N5, N6>(value);
        public OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7>() => new OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7>(value);
        public OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7, N8> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8>() => new OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7, N8>(value);

        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5>(T0 value) => new OneOfBase<T0, T1, T2, T3, T4, T5>(value);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5>(T1 value) => new OneOfBase<T0, T1, T2, T3, T4, T5>(value);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5>(T2 value) => new OneOfBase<T0, T1, T2, T3, T4, T5>(value);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5>(T3 value) => new OneOfBase<T0, T1, T2, T3, T4, T5>(value);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5>(T4 value) => new OneOfBase<T0, T1, T2, T3, T4, T5>(value);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5>(T5 value) => new OneOfBase<T0, T1, T2, T3, T4, T5>(value);

        public void Switch(Action<T0> f0 = null, Action<T1> f1 = null, Action<T2> f2 = null, Action<T3> f3 = null, Action<T4> f4 = null, Action<T5> f5 = null, Action otherwise = null)
        {
            EnsureValueNotNull();
            var valueType = value.GetType();
            if (f0 != null && valueType == typeof(T0)) { f0((T0)this.value); return; }
            if (f1 != null && valueType == typeof(T1)) { f1((T1)this.value); return; }
            if (f2 != null && valueType == typeof(T2)) { f2((T2)this.value); return; }
            if (f3 != null && valueType == typeof(T3)) { f3((T3)this.value); return; }
            if (f4 != null && valueType == typeof(T4)) { f4((T4)this.value); return; }
            if (f5 != null && valueType == typeof(T5)) { f5((T5)this.value); return; }

            if (otherwise != null) { otherwise(); return; }

            throw new InvalidOperationException();
        }

        public TResult Match<TResult>(Func<T0, TResult> f0 = null, Func<T1, TResult> f1 = null, Func<T2, TResult> f2 = null, Func<T3, TResult> f3 = null, Func<T4, TResult> f4 = null, Func<T5, TResult> f5 = null, Func<TResult> otherwise = null)
        {
            EnsureValueNotNull();
            var valueType = value.GetType();
            if (f0 != null && valueType == typeof(T0)) return f0((T0)this.value);
            if (f1 != null && valueType == typeof(T1)) return f1((T1)this.value);
            if (f2 != null && valueType == typeof(T2)) return f2((T2)this.value);
            if (f3 != null && valueType == typeof(T3)) return f3((T3)this.value);
            if (f4 != null && valueType == typeof(T4)) return f4((T4)this.value);
            if (f5 != null && valueType == typeof(T5)) return f5((T5)this.value);

            if (otherwise != null) return otherwise();

            throw new InvalidOperationException();
        }

        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            if (!(obj is OneOfBase<T0, T1, T2, T3, T4, T5>)) return false;

            var other = (OneOfBase<T0, T1, T2, T3, T4, T5>)obj;
            return Equals(value, other.value);
        }

        public override int GetHashCode() => (value?.GetHashCode() ?? 0);

        public override string ToString() => (value?.ToString() ?? "");
    }

    [JsonConverter(typeof(OneOfJsonConverter))]
    public class OneOfBase<T0, T1, T2, T3, T4, T5, T6> : IOneOf
    {
        readonly object value;

        internal OneOfBase(object value)
        {
            EnsureValueIsValid(value);
            this.value = value;
        }

        protected OneOfBase()
        {
            EnsureValueIsValid(this);
            this.value = this;
        }

        static void EnsureValueIsValid(object value)
        {
            if (value == null) throw new ArgumentNullException("value");

            var valueType = value.GetType();
            if (valueType == typeof(T0)) return;
            if (valueType == typeof(T1)) return;
            if (valueType == typeof(T2)) return;
            if (valueType == typeof(T3)) return;
            if (valueType == typeof(T4)) return;
            if (valueType == typeof(T5)) return;
            if (valueType == typeof(T6)) return;

            throw new ArgumentException("value");
        }

        void EnsureValueNotNull()
        {
            if (value == null) throw new InvalidOperationException("Value has not been set");
        }

        object IOneOf.Value => value;

        public bool Is<T>()
        {
            EnsureValueNotNull();
            if (this.value.GetType() == typeof(T)) return true;

            return false;
        }

        public T As<T>()
        {
            EnsureValueNotNull();
            if (this.value.GetType() == typeof(T)) return (T)this.value;

            throw new InvalidOperationException();
        }

        public OneOfBase<N0> ToOneOf<N0>() => new OneOfBase<N0>(value);
        public OneOfBase<N0, N1> ToOneOf<N0, N1>() => new OneOfBase<N0, N1>(value);
        public OneOfBase<N0, N1, N2> ToOneOf<N0, N1, N2>() => new OneOfBase<N0, N1, N2>(value);
        public OneOfBase<N0, N1, N2, N3> ToOneOf<N0, N1, N2, N3>() => new OneOfBase<N0, N1, N2, N3>(value);
        public OneOfBase<N0, N1, N2, N3, N4> ToOneOf<N0, N1, N2, N3, N4>() => new OneOfBase<N0, N1, N2, N3, N4>(value);
        public OneOfBase<N0, N1, N2, N3, N4, N5> ToOneOf<N0, N1, N2, N3, N4, N5>() => new OneOfBase<N0, N1, N2, N3, N4, N5>(value);
        public OneOfBase<N0, N1, N2, N3, N4, N5, N6> ToOneOf<N0, N1, N2, N3, N4, N5, N6>() => new OneOfBase<N0, N1, N2, N3, N4, N5, N6>(value);
        public OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7>() => new OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7>(value);
        public OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7, N8> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8>() => new OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7, N8>(value);

        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5, T6>(T0 value) => new OneOfBase<T0, T1, T2, T3, T4, T5, T6>(value);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5, T6>(T1 value) => new OneOfBase<T0, T1, T2, T3, T4, T5, T6>(value);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5, T6>(T2 value) => new OneOfBase<T0, T1, T2, T3, T4, T5, T6>(value);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5, T6>(T3 value) => new OneOfBase<T0, T1, T2, T3, T4, T5, T6>(value);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5, T6>(T4 value) => new OneOfBase<T0, T1, T2, T3, T4, T5, T6>(value);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5, T6>(T5 value) => new OneOfBase<T0, T1, T2, T3, T4, T5, T6>(value);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5, T6>(T6 value) => new OneOfBase<T0, T1, T2, T3, T4, T5, T6>(value);

        public void Switch(Action<T0> f0 = null, Action<T1> f1 = null, Action<T2> f2 = null, Action<T3> f3 = null, Action<T4> f4 = null, Action<T5> f5 = null, Action<T6> f6 = null, Action otherwise = null)
        {
            EnsureValueNotNull();
            var valueType = value.GetType();
            if (f0 != null && valueType == typeof(T0)) { f0((T0)this.value); return; }
            if (f1 != null && valueType == typeof(T1)) { f1((T1)this.value); return; }
            if (f2 != null && valueType == typeof(T2)) { f2((T2)this.value); return; }
            if (f3 != null && valueType == typeof(T3)) { f3((T3)this.value); return; }
            if (f4 != null && valueType == typeof(T4)) { f4((T4)this.value); return; }
            if (f5 != null && valueType == typeof(T5)) { f5((T5)this.value); return; }
            if (f6 != null && valueType == typeof(T6)) { f6((T6)this.value); return; }

            if (otherwise != null) { otherwise(); return; }

            throw new InvalidOperationException();
        }

        public TResult Match<TResult>(Func<T0, TResult> f0 = null, Func<T1, TResult> f1 = null, Func<T2, TResult> f2 = null, Func<T3, TResult> f3 = null, Func<T4, TResult> f4 = null, Func<T5, TResult> f5 = null, Func<T6, TResult> f6 = null, Func<TResult> otherwise = null)
        {
            EnsureValueNotNull();
            var valueType = value.GetType();
            if (f0 != null && valueType == typeof(T0)) return f0((T0)this.value);
            if (f1 != null && valueType == typeof(T1)) return f1((T1)this.value);
            if (f2 != null && valueType == typeof(T2)) return f2((T2)this.value);
            if (f3 != null && valueType == typeof(T3)) return f3((T3)this.value);
            if (f4 != null && valueType == typeof(T4)) return f4((T4)this.value);
            if (f5 != null && valueType == typeof(T5)) return f5((T5)this.value);
            if (f6 != null && valueType == typeof(T6)) return f6((T6)this.value);

            if (otherwise != null) return otherwise();

            throw new InvalidOperationException();
        }

        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            if (!(obj is OneOfBase<T0, T1, T2, T3, T4, T5, T6>)) return false;

            var other = (OneOfBase<T0, T1, T2, T3, T4, T5, T6>)obj;
            return Equals(value, other.value);
        }

        public override int GetHashCode() => (value?.GetHashCode() ?? 0);

        public override string ToString() => (value?.ToString() ?? "");
    }

    [JsonConverter(typeof(OneOfJsonConverter))]
    public class OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> : IOneOf
    {
        readonly object value;

        internal OneOfBase(object value)
        {
            EnsureValueIsValid(value);
            this.value = value;
        }

        protected OneOfBase()
        {
            EnsureValueIsValid(this);
            this.value = this;
        }

        static void EnsureValueIsValid(object value)
        {
            if (value == null) throw new ArgumentNullException("value");

            var valueType = value.GetType();
            if (valueType == typeof(T0)) return;
            if (valueType == typeof(T1)) return;
            if (valueType == typeof(T2)) return;
            if (valueType == typeof(T3)) return;
            if (valueType == typeof(T4)) return;
            if (valueType == typeof(T5)) return;
            if (valueType == typeof(T6)) return;
            if (valueType == typeof(T7)) return;

            throw new ArgumentException("value");
        }

        void EnsureValueNotNull()
        {
            if (value == null) throw new InvalidOperationException("Value has not been set");
        }

        object IOneOf.Value => value;

        public bool Is<T>()
        {
            EnsureValueNotNull();
            if (this.value.GetType() == typeof(T)) return true;

            return false;
        }

        public T As<T>()
        {
            EnsureValueNotNull();
            if (this.value.GetType() == typeof(T)) return (T)this.value;

            throw new InvalidOperationException();
        }

        public OneOfBase<N0> ToOneOf<N0>() => new OneOfBase<N0>(value);
        public OneOfBase<N0, N1> ToOneOf<N0, N1>() => new OneOfBase<N0, N1>(value);
        public OneOfBase<N0, N1, N2> ToOneOf<N0, N1, N2>() => new OneOfBase<N0, N1, N2>(value);
        public OneOfBase<N0, N1, N2, N3> ToOneOf<N0, N1, N2, N3>() => new OneOfBase<N0, N1, N2, N3>(value);
        public OneOfBase<N0, N1, N2, N3, N4> ToOneOf<N0, N1, N2, N3, N4>() => new OneOfBase<N0, N1, N2, N3, N4>(value);
        public OneOfBase<N0, N1, N2, N3, N4, N5> ToOneOf<N0, N1, N2, N3, N4, N5>() => new OneOfBase<N0, N1, N2, N3, N4, N5>(value);
        public OneOfBase<N0, N1, N2, N3, N4, N5, N6> ToOneOf<N0, N1, N2, N3, N4, N5, N6>() => new OneOfBase<N0, N1, N2, N3, N4, N5, N6>(value);
        public OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7>() => new OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7>(value);
        public OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7, N8> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8>() => new OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7, N8>(value);

        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7>(T0 value) => new OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7>(value);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7>(T1 value) => new OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7>(value);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7>(T2 value) => new OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7>(value);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7>(T3 value) => new OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7>(value);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7>(T4 value) => new OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7>(value);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7>(T5 value) => new OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7>(value);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7>(T6 value) => new OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7>(value);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7>(T7 value) => new OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7>(value);

        public void Switch(Action<T0> f0 = null, Action<T1> f1 = null, Action<T2> f2 = null, Action<T3> f3 = null, Action<T4> f4 = null, Action<T5> f5 = null, Action<T6> f6 = null, Action<T7> f7 = null, Action otherwise = null)
        {
            EnsureValueNotNull();
            var valueType = value.GetType();
            if (f0 != null && valueType == typeof(T0)) { f0((T0)this.value); return; }
            if (f1 != null && valueType == typeof(T1)) { f1((T1)this.value); return; }
            if (f2 != null && valueType == typeof(T2)) { f2((T2)this.value); return; }
            if (f3 != null && valueType == typeof(T3)) { f3((T3)this.value); return; }
            if (f4 != null && valueType == typeof(T4)) { f4((T4)this.value); return; }
            if (f5 != null && valueType == typeof(T5)) { f5((T5)this.value); return; }
            if (f6 != null && valueType == typeof(T6)) { f6((T6)this.value); return; }
            if (f7 != null && valueType == typeof(T7)) { f7((T7)this.value); return; }

            if (otherwise != null) { otherwise(); return; }

            throw new InvalidOperationException();
        }

        public TResult Match<TResult>(Func<T0, TResult> f0 = null, Func<T1, TResult> f1 = null, Func<T2, TResult> f2 = null, Func<T3, TResult> f3 = null, Func<T4, TResult> f4 = null, Func<T5, TResult> f5 = null, Func<T6, TResult> f6 = null, Func<T7, TResult> f7 = null, Func<TResult> otherwise = null)
        {
            EnsureValueNotNull();
            var valueType = value.GetType();
            if (f0 != null && valueType == typeof(T0)) return f0((T0)this.value);
            if (f1 != null && valueType == typeof(T1)) return f1((T1)this.value);
            if (f2 != null && valueType == typeof(T2)) return f2((T2)this.value);
            if (f3 != null && valueType == typeof(T3)) return f3((T3)this.value);
            if (f4 != null && valueType == typeof(T4)) return f4((T4)this.value);
            if (f5 != null && valueType == typeof(T5)) return f5((T5)this.value);
            if (f6 != null && valueType == typeof(T6)) return f6((T6)this.value);
            if (f7 != null && valueType == typeof(T7)) return f7((T7)this.value);

            if (otherwise != null) return otherwise();

            throw new InvalidOperationException();
        }

        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            if (!(obj is OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7>)) return false;

            var other = (OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7>)obj;
            return Equals(value, other.value);
        }

        public override int GetHashCode() => (value?.GetHashCode() ?? 0);

        public override string ToString() => (value?.ToString() ?? "");
    }

    [JsonConverter(typeof(OneOfJsonConverter))]
    public class OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> : IOneOf
    {
        readonly object value;

        internal OneOfBase(object value)
        {
            EnsureValueIsValid(value);
            this.value = value;
        }

        protected OneOfBase()
        {
            EnsureValueIsValid(this);
            this.value = this;
        }

        static void EnsureValueIsValid(object value)
        {
            if (value == null) throw new ArgumentNullException("value");

            var valueType = value.GetType();
            if (valueType == typeof(T0)) return;
            if (valueType == typeof(T1)) return;
            if (valueType == typeof(T2)) return;
            if (valueType == typeof(T3)) return;
            if (valueType == typeof(T4)) return;
            if (valueType == typeof(T5)) return;
            if (valueType == typeof(T6)) return;
            if (valueType == typeof(T7)) return;
            if (valueType == typeof(T8)) return;

            throw new ArgumentException("value");
        }

        void EnsureValueNotNull()
        {
            if (value == null) throw new InvalidOperationException("Value has not been set");
        }

        object IOneOf.Value => value;

        public bool Is<T>()
        {
            EnsureValueNotNull();
            if (this.value.GetType() == typeof(T)) return true;

            return false;
        }

        public T As<T>()
        {
            EnsureValueNotNull();
            if (this.value.GetType() == typeof(T)) return (T)this.value;

            throw new InvalidOperationException();
        }

        public OneOfBase<N0> ToOneOf<N0>() => new OneOfBase<N0>(value);
        public OneOfBase<N0, N1> ToOneOf<N0, N1>() => new OneOfBase<N0, N1>(value);
        public OneOfBase<N0, N1, N2> ToOneOf<N0, N1, N2>() => new OneOfBase<N0, N1, N2>(value);
        public OneOfBase<N0, N1, N2, N3> ToOneOf<N0, N1, N2, N3>() => new OneOfBase<N0, N1, N2, N3>(value);
        public OneOfBase<N0, N1, N2, N3, N4> ToOneOf<N0, N1, N2, N3, N4>() => new OneOfBase<N0, N1, N2, N3, N4>(value);
        public OneOfBase<N0, N1, N2, N3, N4, N5> ToOneOf<N0, N1, N2, N3, N4, N5>() => new OneOfBase<N0, N1, N2, N3, N4, N5>(value);
        public OneOfBase<N0, N1, N2, N3, N4, N5, N6> ToOneOf<N0, N1, N2, N3, N4, N5, N6>() => new OneOfBase<N0, N1, N2, N3, N4, N5, N6>(value);
        public OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7>() => new OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7>(value);
        public OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7, N8> ToOneOf<N0, N1, N2, N3, N4, N5, N6, N7, N8>() => new OneOfBase<N0, N1, N2, N3, N4, N5, N6, N7, N8>(value);

        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8>(T0 value) => new OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8>(value);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8>(T1 value) => new OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8>(value);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8>(T2 value) => new OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8>(value);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8>(T3 value) => new OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8>(value);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8>(T4 value) => new OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8>(value);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8>(T5 value) => new OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8>(value);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8>(T6 value) => new OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8>(value);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8>(T7 value) => new OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8>(value);
        public static implicit operator OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8>(T8 value) => new OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8>(value);

        public void Switch(Action<T0> f0 = null, Action<T1> f1 = null, Action<T2> f2 = null, Action<T3> f3 = null, Action<T4> f4 = null, Action<T5> f5 = null, Action<T6> f6 = null, Action<T7> f7 = null, Action<T8> f8 = null, Action otherwise = null)
        {
            EnsureValueNotNull();
            var valueType = value.GetType();
            if (f0 != null && valueType == typeof(T0)) { f0((T0)this.value); return; }
            if (f1 != null && valueType == typeof(T1)) { f1((T1)this.value); return; }
            if (f2 != null && valueType == typeof(T2)) { f2((T2)this.value); return; }
            if (f3 != null && valueType == typeof(T3)) { f3((T3)this.value); return; }
            if (f4 != null && valueType == typeof(T4)) { f4((T4)this.value); return; }
            if (f5 != null && valueType == typeof(T5)) { f5((T5)this.value); return; }
            if (f6 != null && valueType == typeof(T6)) { f6((T6)this.value); return; }
            if (f7 != null && valueType == typeof(T7)) { f7((T7)this.value); return; }
            if (f8 != null && valueType == typeof(T8)) { f8((T8)this.value); return; }

            if (otherwise != null) { otherwise(); return; }

            throw new InvalidOperationException();
        }

        public TResult Match<TResult>(Func<T0, TResult> f0 = null, Func<T1, TResult> f1 = null, Func<T2, TResult> f2 = null, Func<T3, TResult> f3 = null, Func<T4, TResult> f4 = null, Func<T5, TResult> f5 = null, Func<T6, TResult> f6 = null, Func<T7, TResult> f7 = null, Func<T8, TResult> f8 = null, Func<TResult> otherwise = null)
        {
            EnsureValueNotNull();
            var valueType = value.GetType();
            if (f0 != null && valueType == typeof(T0)) return f0((T0)this.value);
            if (f1 != null && valueType == typeof(T1)) return f1((T1)this.value);
            if (f2 != null && valueType == typeof(T2)) return f2((T2)this.value);
            if (f3 != null && valueType == typeof(T3)) return f3((T3)this.value);
            if (f4 != null && valueType == typeof(T4)) return f4((T4)this.value);
            if (f5 != null && valueType == typeof(T5)) return f5((T5)this.value);
            if (f6 != null && valueType == typeof(T6)) return f6((T6)this.value);
            if (f7 != null && valueType == typeof(T7)) return f7((T7)this.value);
            if (f8 != null && valueType == typeof(T8)) return f8((T8)this.value);

            if (otherwise != null) return otherwise();

            throw new InvalidOperationException();
        }

        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            if (!(obj is OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8>)) return false;

            var other = (OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8>)obj;
            return Equals(value, other.value);
        }

        public override int GetHashCode() => (value?.GetHashCode() ?? 0);

        public override string ToString() => (value?.ToString() ?? "");
    }

}
