<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="Microsoft.CSharp" #>
<#@ assembly name="$(SolutionDir)OneOf.TemplatingModels\bin\Release\OneOf.TemplatingModels.dll" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="Microsoft.VisualStudio.TextTemplating" #>
<#@ import namespace="OneOf.TemplatingModels" #>
<#@ output extension=".cs" #>
<#
GenerateClasses();
#>
<#+
void GenerateClasses()
{
    WriteLine("// ===========================================================================");
    WriteLine("// Generated by {0}", System.IO.Path.GetFileName(Host.TemplateFile));
    WriteLine("// ===========================================================================");
    WriteLine("");
    WriteLine("using System;");
	
    WriteLine("");
    WriteLine("namespace OneOf");
    WriteLine("// ReSharper disable InconsistentNaming - The underscores allow us to easily see what type of matcher we're using.");
    using(new WriteBraces(this))
    {
        WriteMatcherInterface(Constants.MaxAritySupported);
    } 
}

void WriteMatcherInterface(int countOfgenericParams) 
{
	var genericParamsNum = Enumerable.Range(1, countOfgenericParams).ToList();
	var fullCountDisambiguator = CreateInterfaceDisambiguator(genericParamsNum);
    var fullCountGenericParams = GenerateGenericArgs(genericParamsNum) + ", TResult";

    WriteLine("");
    foreach(var combo in CombinationsOfLength1ThroughN(Enumerable.Range(1, countOfgenericParams), countOfgenericParams))
    {
        var comboArray = combo.ToArray();
        var genericArgs = GenerateGenericArgs(comboArray) + ", TResult";
        var interfaceDisambiguator = CreateInterfaceDisambiguator(comboArray);
        WriteLine($"public interface IOneOfMatcher{interfaceDisambiguator}<{genericArgs}> : IOneOfMatcherTerminator<TResult>" );
        using(new WriteBraces(this))
        {
            if(comboArray.Length == 1)
            {                
                WriteLine($"TResult Match(Func<T{comboArray[0]},TResult> matchFunc);");
            }
            foreach(var parmIndex in comboArray)
            {
                var lesserArityTs = combo.Except(new []{parmIndex}).ToArray();
                if(lesserArityTs.Length >0)
                {
                    var lesserArityArgs = GenerateGenericArgs(lesserArityTs) + ", TResult";
                    var lesserArityDisambiguator= CreateInterfaceDisambiguator(lesserArityTs);
                    WriteLine($"IOneOfMatcher{lesserArityDisambiguator}<{lesserArityArgs}> Match(Func<T{parmIndex},TResult> matchFunc);");
                }
            }
		}
    }
}

string GenerateGenericArgs(IEnumerable<int> argNumbers)
{
	return string.Join(", ", argNumbers.Select(n => "T" + n));
}

string CreateInterfaceDisambiguator(IEnumerable<int> ints){return string.Join("_", ints.Select(i=>i.ToString()));}

class WriteBraces: IDisposable
{
	TextTransformation textTransformation;

	public WriteBraces(TextTransformation textTransformation)
	{
		this.textTransformation = textTransformation;

		textTransformation.WriteLine("{");
		textTransformation.PushIndent("    ");
	}

	public void Dispose()
	{
		textTransformation.PopIndent();
		textTransformation.WriteLine("}");
	}
}

        static IEnumerable<IEnumerable<int>> CombinationsOfLengthN(IEnumerable<int> elementsToCombine, int n)
        {
              var elementsToCombineList = elementsToCombine.ToList();
              return n == 0 ? new[] { new int[0] } :
                elementsToCombineList.SelectMany((e, i) =>
                  CombinationsOfLengthN(elementsToCombineList.Skip(i + 1),n - 1)
                  .Select(c => (new[] { e })
                  .Concat(c)));
        }

        static IEnumerable<IEnumerable<int>> CombinationsOfLength1ThroughN(IEnumerable<int> elementsToCombine, int n)
        {
            var accumulatedResult = new List<List<IEnumerable<int>>>();
            var listOfElementsToCombine = elementsToCombine.ToList();

            for( var i = 1; i <= n + 1; i++)
            {
                accumulatedResult.Add(CombinationsOfLengthN(listOfElementsToCombine,i).ToList());
            }

            return accumulatedResult.SelectMany(i => i);
        }
#>